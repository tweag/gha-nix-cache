import {
  __commonJS,
  __require,
  require_auth,
  require_core,
  require_exec,
  require_io,
  require_lib
} from "./index-p06xw57k.js";

// node_modules/@actions/glob/lib/internal-glob-options-helper.js
var require_internal_glob_options_helper = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOptions = undefined;
  var core = __importStar(require_core());
  function getOptions(copy) {
    const result = {
      followSymbolicLinks: true,
      implicitDescendants: true,
      omitBrokenSymbolicLinks: true
    };
    if (copy) {
      if (typeof copy.followSymbolicLinks === "boolean") {
        result.followSymbolicLinks = copy.followSymbolicLinks;
        core.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
      }
      if (typeof copy.implicitDescendants === "boolean") {
        result.implicitDescendants = copy.implicitDescendants;
        core.debug(`implicitDescendants '${result.implicitDescendants}'`);
      }
      if (typeof copy.omitBrokenSymbolicLinks === "boolean") {
        result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
        core.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
      }
    }
    return result;
  }
  exports.getOptions = getOptions;
});

// node_modules/@actions/glob/lib/internal-path-helper.js
var require_internal_path_helper = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.safeTrimTrailingSeparator = exports.normalizeSeparators = exports.hasRoot = exports.hasAbsoluteRoot = exports.ensureAbsoluteRoot = exports.dirname = undefined;
  var path = __importStar(__require("path"));
  var assert_1 = __importDefault(__require("assert"));
  var IS_WINDOWS = process.platform === "win32";
  function dirname(p) {
    p = safeTrimTrailingSeparator(p);
    if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
      return p;
    }
    let result = path.dirname(p);
    if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
      result = safeTrimTrailingSeparator(result);
    }
    return result;
  }
  exports.dirname = dirname;
  function ensureAbsoluteRoot(root, itemPath) {
    assert_1.default(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
    assert_1.default(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
    if (hasAbsoluteRoot(itemPath)) {
      return itemPath;
    }
    if (IS_WINDOWS) {
      if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
        let cwd = process.cwd();
        assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
        if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
          if (itemPath.length === 2) {
            return `${itemPath[0]}:\\${cwd.substr(3)}`;
          } else {
            if (!cwd.endsWith("\\")) {
              cwd += "\\";
            }
            return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
          }
        } else {
          return `${itemPath[0]}:\\${itemPath.substr(2)}`;
        }
      } else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
        const cwd = process.cwd();
        assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
        return `${cwd[0]}:\\${itemPath.substr(1)}`;
      }
    }
    assert_1.default(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
    if (root.endsWith("/") || IS_WINDOWS && root.endsWith("\\")) {
    } else {
      root += path.sep;
    }
    return root + itemPath;
  }
  exports.ensureAbsoluteRoot = ensureAbsoluteRoot;
  function hasAbsoluteRoot(itemPath) {
    assert_1.default(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
    itemPath = normalizeSeparators(itemPath);
    if (IS_WINDOWS) {
      return itemPath.startsWith("\\\\") || /^[A-Z]:\\/i.test(itemPath);
    }
    return itemPath.startsWith("/");
  }
  exports.hasAbsoluteRoot = hasAbsoluteRoot;
  function hasRoot(itemPath) {
    assert_1.default(itemPath, `isRooted parameter 'itemPath' must not be empty`);
    itemPath = normalizeSeparators(itemPath);
    if (IS_WINDOWS) {
      return itemPath.startsWith("\\") || /^[A-Z]:/i.test(itemPath);
    }
    return itemPath.startsWith("/");
  }
  exports.hasRoot = hasRoot;
  function normalizeSeparators(p) {
    p = p || "";
    if (IS_WINDOWS) {
      p = p.replace(/\//g, "\\");
      const isUnc = /^\\\\+[^\\]/.test(p);
      return (isUnc ? "\\" : "") + p.replace(/\\\\+/g, "\\");
    }
    return p.replace(/\/\/+/g, "/");
  }
  exports.normalizeSeparators = normalizeSeparators;
  function safeTrimTrailingSeparator(p) {
    if (!p) {
      return "";
    }
    p = normalizeSeparators(p);
    if (!p.endsWith(path.sep)) {
      return p;
    }
    if (p === path.sep) {
      return p;
    }
    if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
      return p;
    }
    return p.substr(0, p.length - 1);
  }
  exports.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
});

// node_modules/@actions/glob/lib/internal-match-kind.js
var require_internal_match_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MatchKind = undefined;
  var MatchKind;
  (function(MatchKind2) {
    MatchKind2[MatchKind2["None"] = 0] = "None";
    MatchKind2[MatchKind2["Directory"] = 1] = "Directory";
    MatchKind2[MatchKind2["File"] = 2] = "File";
    MatchKind2[MatchKind2["All"] = 3] = "All";
  })(MatchKind = exports.MatchKind || (exports.MatchKind = {}));
});

// node_modules/@actions/glob/lib/internal-pattern-helper.js
var require_internal_pattern_helper = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.partialMatch = exports.match = exports.getSearchPaths = undefined;
  var pathHelper = __importStar(require_internal_path_helper());
  var internal_match_kind_1 = require_internal_match_kind();
  var IS_WINDOWS = process.platform === "win32";
  function getSearchPaths(patterns) {
    patterns = patterns.filter((x) => !x.negate);
    const searchPathMap = {};
    for (const pattern of patterns) {
      const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
      searchPathMap[key] = "candidate";
    }
    const result = [];
    for (const pattern of patterns) {
      const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
      if (searchPathMap[key] === "included") {
        continue;
      }
      let foundAncestor = false;
      let tempKey = key;
      let parent = pathHelper.dirname(tempKey);
      while (parent !== tempKey) {
        if (searchPathMap[parent]) {
          foundAncestor = true;
          break;
        }
        tempKey = parent;
        parent = pathHelper.dirname(tempKey);
      }
      if (!foundAncestor) {
        result.push(pattern.searchPath);
        searchPathMap[key] = "included";
      }
    }
    return result;
  }
  exports.getSearchPaths = getSearchPaths;
  function match(patterns, itemPath) {
    let result = internal_match_kind_1.MatchKind.None;
    for (const pattern of patterns) {
      if (pattern.negate) {
        result &= ~pattern.match(itemPath);
      } else {
        result |= pattern.match(itemPath);
      }
    }
    return result;
  }
  exports.match = match;
  function partialMatch(patterns, itemPath) {
    return patterns.some((x) => !x.negate && x.partialMatch(itemPath));
  }
  exports.partialMatch = partialMatch;
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports, module) => {
  module.exports = function(xs, fn) {
    var res = [];
    for (var i = 0;i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports, module) => {
  module.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports, module) => {
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module.exports = expandTop;
  var escSlash = "\x00SLASH" + Math.random() + "\x00";
  var escOpen = "\x00OPEN" + Math.random() + "\x00";
  var escClose = "\x00CLOSE" + Math.random() + "\x00";
  var escComma = "\x00COMMA" + Math.random() + "\x00";
  var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x;test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0;j < N.length; j++) {
      for (var k = 0;k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports, module) => {
  module.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path = function() {
    try {
      return __require("path");
    } catch (e) {
    }
  }() || {
    sep: "/"
  };
  minimatch.sep = path.sep;
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  function ext(a, b) {
    b = b || {};
    var t = {};
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    var orig = minimatch;
    var m = function minimatch(p, pattern, options) {
      return orig(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    m.Minimatch.defaults = function defaults(options) {
      return orig.defaults(ext(def, options)).Minimatch;
    };
    m.filter = function filter(pattern, options) {
      return orig.filter(pattern, ext(def, options));
    };
    m.defaults = function defaults(options) {
      return orig.defaults(ext(def, options));
    };
    m.makeRe = function makeRe(pattern, options) {
      return orig.makeRe(pattern, ext(def, options));
    };
    m.braceExpand = function braceExpand(pattern, options) {
      return orig.braceExpand(pattern, ext(def, options));
    };
    m.match = function(list, pattern, options) {
      return orig.match(list, pattern, ext(def, options));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    assertValidPattern(pattern);
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    assertValidPattern(pattern);
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (!options.allowWindowsEscape && path.sep !== "/") {
      pattern = pattern.split(path.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = function debug() {
        console.error.apply(console, arguments);
      };
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l = pattern.length;i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  }
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = function(pattern) {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  function parse(pattern, isSub) {
    assertValidPattern(pattern);
    var options = this.options;
    if (pattern === "**") {
      if (!options.noglobstar)
        return GLOBSTAR;
      else
        pattern = "*";
    }
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c;i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s\t%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop();pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug(`tail=%j
   %s`, tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1;n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0;i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = function match(f, partial) {
    if (typeof partial === "undefined")
      partial = this.partial;
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path.sep !== "/") {
      f = f.split(path.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1;i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0;i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  };
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", { this: this, file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (;fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug(`
globstar while`, file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug(`
>>> no match, partial?`, file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});

// node_modules/@actions/glob/lib/internal-path.js
var require_internal_path = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Path = undefined;
  var path = __importStar(__require("path"));
  var pathHelper = __importStar(require_internal_path_helper());
  var assert_1 = __importDefault(__require("assert"));
  var IS_WINDOWS = process.platform === "win32";

  class Path {
    constructor(itemPath) {
      this.segments = [];
      if (typeof itemPath === "string") {
        assert_1.default(itemPath, `Parameter 'itemPath' must not be empty`);
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        if (!pathHelper.hasRoot(itemPath)) {
          this.segments = itemPath.split(path.sep);
        } else {
          let remaining = itemPath;
          let dir = pathHelper.dirname(remaining);
          while (dir !== remaining) {
            const basename = path.basename(remaining);
            this.segments.unshift(basename);
            remaining = dir;
            dir = pathHelper.dirname(remaining);
          }
          this.segments.unshift(remaining);
        }
      } else {
        assert_1.default(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
        for (let i = 0;i < itemPath.length; i++) {
          let segment = itemPath[i];
          assert_1.default(segment, `Parameter 'itemPath' must not contain any empty segments`);
          segment = pathHelper.normalizeSeparators(itemPath[i]);
          if (i === 0 && pathHelper.hasRoot(segment)) {
            segment = pathHelper.safeTrimTrailingSeparator(segment);
            assert_1.default(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
            this.segments.push(segment);
          } else {
            assert_1.default(!segment.includes(path.sep), `Parameter 'itemPath' contains unexpected path separators`);
            this.segments.push(segment);
          }
        }
      }
    }
    toString() {
      let result = this.segments[0];
      let skipSlash = result.endsWith(path.sep) || IS_WINDOWS && /^[A-Z]:$/i.test(result);
      for (let i = 1;i < this.segments.length; i++) {
        if (skipSlash) {
          skipSlash = false;
        } else {
          result += path.sep;
        }
        result += this.segments[i];
      }
      return result;
    }
  }
  exports.Path = Path;
});

// node_modules/@actions/glob/lib/internal-pattern.js
var require_internal_pattern = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pattern = undefined;
  var os = __importStar(__require("os"));
  var path = __importStar(__require("path"));
  var pathHelper = __importStar(require_internal_path_helper());
  var assert_1 = __importDefault(__require("assert"));
  var minimatch_1 = require_minimatch();
  var internal_match_kind_1 = require_internal_match_kind();
  var internal_path_1 = require_internal_path();
  var IS_WINDOWS = process.platform === "win32";

  class Pattern {
    constructor(patternOrNegate, isImplicitPattern = false, segments, homedir) {
      this.negate = false;
      let pattern;
      if (typeof patternOrNegate === "string") {
        pattern = patternOrNegate.trim();
      } else {
        segments = segments || [];
        assert_1.default(segments.length, `Parameter 'segments' must not empty`);
        const root = Pattern.getLiteral(segments[0]);
        assert_1.default(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
        pattern = new internal_path_1.Path(segments).toString().trim();
        if (patternOrNegate) {
          pattern = `!${pattern}`;
        }
      }
      while (pattern.startsWith("!")) {
        this.negate = !this.negate;
        pattern = pattern.substr(1).trim();
      }
      pattern = Pattern.fixupPattern(pattern, homedir);
      this.segments = new internal_path_1.Path(pattern).segments;
      this.trailingSeparator = pathHelper.normalizeSeparators(pattern).endsWith(path.sep);
      pattern = pathHelper.safeTrimTrailingSeparator(pattern);
      let foundGlob = false;
      const searchSegments = this.segments.map((x) => Pattern.getLiteral(x)).filter((x) => !foundGlob && !(foundGlob = x === ""));
      this.searchPath = new internal_path_1.Path(searchSegments).toString();
      this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? "i" : "");
      this.isImplicitPattern = isImplicitPattern;
      const minimatchOptions = {
        dot: true,
        nobrace: true,
        nocase: IS_WINDOWS,
        nocomment: true,
        noext: true,
        nonegate: true
      };
      pattern = IS_WINDOWS ? pattern.replace(/\\/g, "/") : pattern;
      this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
    }
    match(itemPath) {
      if (this.segments[this.segments.length - 1] === "**") {
        itemPath = pathHelper.normalizeSeparators(itemPath);
        if (!itemPath.endsWith(path.sep) && this.isImplicitPattern === false) {
          itemPath = `${itemPath}${path.sep}`;
        }
      } else {
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
      }
      if (this.minimatch.match(itemPath)) {
        return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
      }
      return internal_match_kind_1.MatchKind.None;
    }
    partialMatch(itemPath) {
      itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
      if (pathHelper.dirname(itemPath) === itemPath) {
        return this.rootRegExp.test(itemPath);
      }
      return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
    }
    static globEscape(s) {
      return (IS_WINDOWS ? s : s.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
    }
    static fixupPattern(pattern, homedir) {
      assert_1.default(pattern, "pattern cannot be empty");
      const literalSegments = new internal_path_1.Path(pattern).segments.map((x) => Pattern.getLiteral(x));
      assert_1.default(literalSegments.every((x, i) => (x !== "." || i === 0) && x !== ".."), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
      assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
      pattern = pathHelper.normalizeSeparators(pattern);
      if (pattern === "." || pattern.startsWith(`.${path.sep}`)) {
        pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
      } else if (pattern === "~" || pattern.startsWith(`~${path.sep}`)) {
        homedir = homedir || os.homedir();
        assert_1.default(homedir, "Unable to determine HOME directory");
        assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
        pattern = Pattern.globEscape(homedir) + pattern.substr(1);
      } else if (IS_WINDOWS && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
        let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", pattern.substr(0, 2));
        if (pattern.length > 2 && !root.endsWith("\\")) {
          root += "\\";
        }
        pattern = Pattern.globEscape(root) + pattern.substr(2);
      } else if (IS_WINDOWS && (pattern === "\\" || pattern.match(/^\\[^\\]/))) {
        let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", "\\");
        if (!root.endsWith("\\")) {
          root += "\\";
        }
        pattern = Pattern.globEscape(root) + pattern.substr(1);
      } else {
        pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
      }
      return pathHelper.normalizeSeparators(pattern);
    }
    static getLiteral(segment) {
      let literal = "";
      for (let i = 0;i < segment.length; i++) {
        const c = segment[i];
        if (c === "\\" && !IS_WINDOWS && i + 1 < segment.length) {
          literal += segment[++i];
          continue;
        } else if (c === "*" || c === "?") {
          return "";
        } else if (c === "[" && i + 1 < segment.length) {
          let set = "";
          let closed = -1;
          for (let i2 = i + 1;i2 < segment.length; i2++) {
            const c2 = segment[i2];
            if (c2 === "\\" && !IS_WINDOWS && i2 + 1 < segment.length) {
              set += segment[++i2];
              continue;
            } else if (c2 === "]") {
              closed = i2;
              break;
            } else {
              set += c2;
            }
          }
          if (closed >= 0) {
            if (set.length > 1) {
              return "";
            }
            if (set) {
              literal += set;
              i = closed;
              continue;
            }
          }
        }
        literal += c;
      }
      return literal;
    }
    static regExpEscape(s) {
      return s.replace(/[[\\^$.|?*+()]/g, "\\$&");
    }
  }
  exports.Pattern = Pattern;
});

// node_modules/@actions/glob/lib/internal-search-state.js
var require_internal_search_state = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SearchState = undefined;

  class SearchState {
    constructor(path, level) {
      this.path = path;
      this.level = level;
    }
  }
  exports.SearchState = SearchState;
});

// node_modules/@actions/glob/lib/internal-globber.js
var require_internal_globber = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultGlobber = undefined;
  var core = __importStar(require_core());
  var fs = __importStar(__require("fs"));
  var globOptionsHelper = __importStar(require_internal_glob_options_helper());
  var path = __importStar(__require("path"));
  var patternHelper = __importStar(require_internal_pattern_helper());
  var internal_match_kind_1 = require_internal_match_kind();
  var internal_pattern_1 = require_internal_pattern();
  var internal_search_state_1 = require_internal_search_state();
  var IS_WINDOWS = process.platform === "win32";

  class DefaultGlobber {
    constructor(options) {
      this.patterns = [];
      this.searchPaths = [];
      this.options = globOptionsHelper.getOptions(options);
    }
    getSearchPaths() {
      return this.searchPaths.slice();
    }
    glob() {
      var e_1, _a;
      return __awaiter(this, undefined, undefined, function* () {
        const result = [];
        try {
          for (var _b = __asyncValues(this.globGenerator()), _c;_c = yield _b.next(), !_c.done; ) {
            const itemPath = _c.value;
            result.push(itemPath);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              yield _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return result;
      });
    }
    globGenerator() {
      return __asyncGenerator(this, arguments, function* globGenerator_1() {
        const options = globOptionsHelper.getOptions(this.options);
        const patterns = [];
        for (const pattern of this.patterns) {
          patterns.push(pattern);
          if (options.implicitDescendants && (pattern.trailingSeparator || pattern.segments[pattern.segments.length - 1] !== "**")) {
            patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat("**")));
          }
        }
        const stack = [];
        for (const searchPath of patternHelper.getSearchPaths(patterns)) {
          core.debug(`Search path '${searchPath}'`);
          try {
            yield __await(fs.promises.lstat(searchPath));
          } catch (err) {
            if (err.code === "ENOENT") {
              continue;
            }
            throw err;
          }
          stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
        }
        const traversalChain = [];
        while (stack.length) {
          const item = stack.pop();
          const match = patternHelper.match(patterns, item.path);
          const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
          if (!match && !partialMatch) {
            continue;
          }
          const stats = yield __await(DefaultGlobber.stat(item, options, traversalChain));
          if (!stats) {
            continue;
          }
          if (stats.isDirectory()) {
            if (match & internal_match_kind_1.MatchKind.Directory) {
              yield yield __await(item.path);
            } else if (!partialMatch) {
              continue;
            }
            const childLevel = item.level + 1;
            const childItems = (yield __await(fs.promises.readdir(item.path))).map((x) => new internal_search_state_1.SearchState(path.join(item.path, x), childLevel));
            stack.push(...childItems.reverse());
          } else if (match & internal_match_kind_1.MatchKind.File) {
            yield yield __await(item.path);
          }
        }
      });
    }
    static create(patterns, options) {
      return __awaiter(this, undefined, undefined, function* () {
        const result = new DefaultGlobber(options);
        if (IS_WINDOWS) {
          patterns = patterns.replace(/\r\n/g, `
`);
          patterns = patterns.replace(/\r/g, `
`);
        }
        const lines = patterns.split(`
`).map((x) => x.trim());
        for (const line of lines) {
          if (!line || line.startsWith("#")) {
            continue;
          } else {
            result.patterns.push(new internal_pattern_1.Pattern(line));
          }
        }
        result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
        return result;
      });
    }
    static stat(item, options, traversalChain) {
      return __awaiter(this, undefined, undefined, function* () {
        let stats;
        if (options.followSymbolicLinks) {
          try {
            stats = yield fs.promises.stat(item.path);
          } catch (err) {
            if (err.code === "ENOENT") {
              if (options.omitBrokenSymbolicLinks) {
                core.debug(`Broken symlink '${item.path}'`);
                return;
              }
              throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
            }
            throw err;
          }
        } else {
          stats = yield fs.promises.lstat(item.path);
        }
        if (stats.isDirectory() && options.followSymbolicLinks) {
          const realPath = yield fs.promises.realpath(item.path);
          while (traversalChain.length >= item.level) {
            traversalChain.pop();
          }
          if (traversalChain.some((x) => x === realPath)) {
            core.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
            return;
          }
          traversalChain.push(realPath);
        }
        return stats;
      });
    }
  }
  exports.DefaultGlobber = DefaultGlobber;
});

// node_modules/@actions/glob/lib/glob.js
var require_glob = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.create = undefined;
  var internal_globber_1 = require_internal_globber();
  function create(patterns, options) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield internal_globber_1.DefaultGlobber.create(patterns, options);
    });
  }
  exports.create = create;
});

// node_modules/semver/semver.js
var require_semver = __commonJS((exports, module) => {
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.tokens = {};
  var R = 0;
  function tok(n) {
    t[n] = R++;
  }
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  function makeSafeRe(value) {
    for (var i2 = 0;i2 < safeRegexReplacements.length; i2++) {
      var token = safeRegexReplacements[i2][0];
      var max = safeRegexReplacements[i2][1];
      value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value;
  }
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\." + "(" + src[t.NUMERICIDENTIFIER] + ")\\." + "(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?" + ")?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?" + ")?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])" + "(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})" + "(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?" + "(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?" + "(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + "(" + src[t.XRANGEPLAIN] + ")" + "\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + "(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (i = 0;i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
      safeRe[i] = new RegExp(makeSafeRe(src[i]));
    }
  }
  var i;
  exports.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug("prerelease compare", i2, a, b);
      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = undefined;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports.compareBuild = compareBuild;
  function compareBuild(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  exports.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(a, b, loose);
    });
  }
  exports.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports.compareBuild(b, a, loose);
    });
  }
  exports.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    comp = comp.trim().split(/\s+/).join(" ");
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== undefined ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range.trim().split(/\s+/).join(" ");
    this.set = this.raw.split("||").map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
    range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  }
  exports.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(safeRe[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0;i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0;i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0;i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0;i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0;i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports.coerce = coerce;
  function coerce(version, options) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version.match(safeRe[t.COERCE]);
    } else {
      var next;
      while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      safeRe[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  }
});

// node_modules/@actions/cache/lib/internal/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheFileSizeLimit = exports.ManifestFilename = exports.TarFilename = exports.SystemTarPathOnWindows = exports.GnuTarPathOnWindows = exports.SocketTimeout = exports.DefaultRetryDelay = exports.DefaultRetryAttempts = exports.ArchiveToolType = exports.CompressionMethod = exports.CacheFilename = undefined;
  var CacheFilename;
  (function(CacheFilename2) {
    CacheFilename2["Gzip"] = "cache.tgz";
    CacheFilename2["Zstd"] = "cache.tzst";
  })(CacheFilename || (exports.CacheFilename = CacheFilename = {}));
  var CompressionMethod;
  (function(CompressionMethod2) {
    CompressionMethod2["Gzip"] = "gzip";
    CompressionMethod2["ZstdWithoutLong"] = "zstd-without-long";
    CompressionMethod2["Zstd"] = "zstd";
  })(CompressionMethod || (exports.CompressionMethod = CompressionMethod = {}));
  var ArchiveToolType;
  (function(ArchiveToolType2) {
    ArchiveToolType2["GNU"] = "gnu";
    ArchiveToolType2["BSD"] = "bsd";
  })(ArchiveToolType || (exports.ArchiveToolType = ArchiveToolType = {}));
  exports.DefaultRetryAttempts = 2;
  exports.DefaultRetryDelay = 5000;
  exports.SocketTimeout = 5000;
  exports.GnuTarPathOnWindows = `${process.env["PROGRAMFILES"]}\\Git\\usr\\bin\\tar.exe`;
  exports.SystemTarPathOnWindows = `${process.env["SYSTEMDRIVE"]}\\Windows\\System32\\tar.exe`;
  exports.TarFilename = "cache.tar";
  exports.ManifestFilename = "manifest.txt";
  exports.CacheFileSizeLimit = 10 * Math.pow(1024, 3);
});

// node_modules/@actions/cache/lib/internal/cacheUtils.js
var require_cacheUtils = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeToken = exports.getCacheVersion = exports.assertDefined = exports.getGnuTarPathOnWindows = exports.getCacheFileName = exports.getCompressionMethod = exports.unlinkFile = exports.resolvePaths = exports.getArchiveFileSizeInBytes = exports.createTempDirectory = undefined;
  var core = __importStar(require_core());
  var exec = __importStar(require_exec());
  var glob = __importStar(require_glob());
  var io = __importStar(require_io());
  var crypto = __importStar(__require("crypto"));
  var fs = __importStar(__require("fs"));
  var path = __importStar(__require("path"));
  var semver = __importStar(require_semver());
  var util = __importStar(__require("util"));
  var constants_1 = require_constants();
  var versionSalt = "1.0";
  function createTempDirectory() {
    return __awaiter(this, undefined, undefined, function* () {
      const IS_WINDOWS = process.platform === "win32";
      let tempDirectory = process.env["RUNNER_TEMP"] || "";
      if (!tempDirectory) {
        let baseLocation;
        if (IS_WINDOWS) {
          baseLocation = process.env["USERPROFILE"] || "C:\\";
        } else {
          if (process.platform === "darwin") {
            baseLocation = "/Users";
          } else {
            baseLocation = "/home";
          }
        }
        tempDirectory = path.join(baseLocation, "actions", "temp");
      }
      const dest = path.join(tempDirectory, crypto.randomUUID());
      yield io.mkdirP(dest);
      return dest;
    });
  }
  exports.createTempDirectory = createTempDirectory;
  function getArchiveFileSizeInBytes(filePath) {
    return fs.statSync(filePath).size;
  }
  exports.getArchiveFileSizeInBytes = getArchiveFileSizeInBytes;
  function resolvePaths(patterns) {
    var _a, e_1, _b, _c;
    var _d;
    return __awaiter(this, undefined, undefined, function* () {
      const paths = [];
      const workspace = (_d = process.env["GITHUB_WORKSPACE"]) !== null && _d !== undefined ? _d : process.cwd();
      const globber = yield glob.create(patterns.join(`
`), {
        implicitDescendants: false
      });
      try {
        for (var _e = true, _f = __asyncValues(globber.globGenerator()), _g;_g = yield _f.next(), _a = _g.done, !_a; _e = true) {
          _c = _g.value;
          _e = false;
          const file = _c;
          const relativeFile = path.relative(workspace, file).replace(new RegExp(`\\${path.sep}`, "g"), "/");
          core.debug(`Matched: ${relativeFile}`);
          if (relativeFile === "") {
            paths.push(".");
          } else {
            paths.push(`${relativeFile}`);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_e && !_a && (_b = _f.return))
            yield _b.call(_f);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return paths;
    });
  }
  exports.resolvePaths = resolvePaths;
  function unlinkFile(filePath) {
    return __awaiter(this, undefined, undefined, function* () {
      return util.promisify(fs.unlink)(filePath);
    });
  }
  exports.unlinkFile = unlinkFile;
  function getVersion(app, additionalArgs = []) {
    return __awaiter(this, undefined, undefined, function* () {
      let versionOutput = "";
      additionalArgs.push("--version");
      core.debug(`Checking ${app} ${additionalArgs.join(" ")}`);
      try {
        yield exec.exec(`${app}`, additionalArgs, {
          ignoreReturnCode: true,
          silent: true,
          listeners: {
            stdout: (data) => versionOutput += data.toString(),
            stderr: (data) => versionOutput += data.toString()
          }
        });
      } catch (err) {
        core.debug(err.message);
      }
      versionOutput = versionOutput.trim();
      core.debug(versionOutput);
      return versionOutput;
    });
  }
  function getCompressionMethod() {
    return __awaiter(this, undefined, undefined, function* () {
      const versionOutput = yield getVersion("zstd", ["--quiet"]);
      const version = semver.clean(versionOutput);
      core.debug(`zstd version: ${version}`);
      if (versionOutput === "") {
        return constants_1.CompressionMethod.Gzip;
      } else {
        return constants_1.CompressionMethod.ZstdWithoutLong;
      }
    });
  }
  exports.getCompressionMethod = getCompressionMethod;
  function getCacheFileName(compressionMethod) {
    return compressionMethod === constants_1.CompressionMethod.Gzip ? constants_1.CacheFilename.Gzip : constants_1.CacheFilename.Zstd;
  }
  exports.getCacheFileName = getCacheFileName;
  function getGnuTarPathOnWindows() {
    return __awaiter(this, undefined, undefined, function* () {
      if (fs.existsSync(constants_1.GnuTarPathOnWindows)) {
        return constants_1.GnuTarPathOnWindows;
      }
      const versionOutput = yield getVersion("tar");
      return versionOutput.toLowerCase().includes("gnu tar") ? io.which("tar") : "";
    });
  }
  exports.getGnuTarPathOnWindows = getGnuTarPathOnWindows;
  function assertDefined(name, value) {
    if (value === undefined) {
      throw Error(`Expected ${name} but value was undefiend`);
    }
    return value;
  }
  exports.assertDefined = assertDefined;
  function getCacheVersion(paths, compressionMethod, enableCrossOsArchive = false) {
    const components = paths.slice();
    if (compressionMethod) {
      components.push(compressionMethod);
    }
    if (process.platform === "win32" && !enableCrossOsArchive) {
      components.push("windows-only");
    }
    components.push(versionSalt);
    return crypto.createHash("sha256").update(components.join("|")).digest("hex");
  }
  exports.getCacheVersion = getCacheVersion;
  function getRuntimeToken() {
    const token = process.env["ACTIONS_RUNTIME_TOKEN"];
    if (!token) {
      throw new Error("Unable to get the ACTIONS_RUNTIME_TOKEN env variable");
    }
    return token;
  }
  exports.getRuntimeToken = getRuntimeToken;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipeline.js
var require_pipeline = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createEmptyPipeline = createEmptyPipeline;
  var ValidPhaseNames = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);

  class HttpPipeline {
    constructor(policies) {
      var _a;
      this._policies = [];
      this._policies = (_a = policies === null || policies === undefined ? undefined : policies.slice(0)) !== null && _a !== undefined ? _a : [];
      this._orderedPolicies = undefined;
    }
    addPolicy(policy, options = {}) {
      if (options.phase && options.afterPhase) {
        throw new Error("Policies inside a phase cannot specify afterPhase.");
      }
      if (options.phase && !ValidPhaseNames.has(options.phase)) {
        throw new Error(`Invalid phase name: ${options.phase}`);
      }
      if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
        throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
      }
      this._policies.push({
        policy,
        options
      });
      this._orderedPolicies = undefined;
    }
    removePolicy(options) {
      const removedPolicies = [];
      this._policies = this._policies.filter((policyDescriptor) => {
        if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
          removedPolicies.push(policyDescriptor.policy);
          return false;
        } else {
          return true;
        }
      });
      this._orderedPolicies = undefined;
      return removedPolicies;
    }
    sendRequest(httpClient, request) {
      const policies = this.getOrderedPolicies();
      const pipeline = policies.reduceRight((next, policy) => {
        return (req) => {
          return policy.sendRequest(req, next);
        };
      }, (req) => httpClient.sendRequest(req));
      return pipeline(request);
    }
    getOrderedPolicies() {
      if (!this._orderedPolicies) {
        this._orderedPolicies = this.orderPolicies();
      }
      return this._orderedPolicies;
    }
    clone() {
      return new HttpPipeline(this._policies);
    }
    static create() {
      return new HttpPipeline;
    }
    orderPolicies() {
      const result = [];
      const policyMap = new Map;
      function createPhase(name) {
        return {
          name,
          policies: new Set,
          hasRun: false,
          hasAfterPolicies: false
        };
      }
      const serializePhase = createPhase("Serialize");
      const noPhase = createPhase("None");
      const deserializePhase = createPhase("Deserialize");
      const retryPhase = createPhase("Retry");
      const signPhase = createPhase("Sign");
      const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
      function getPhase(phase) {
        if (phase === "Retry") {
          return retryPhase;
        } else if (phase === "Serialize") {
          return serializePhase;
        } else if (phase === "Deserialize") {
          return deserializePhase;
        } else if (phase === "Sign") {
          return signPhase;
        } else {
          return noPhase;
        }
      }
      for (const descriptor of this._policies) {
        const policy = descriptor.policy;
        const options = descriptor.options;
        const policyName = policy.name;
        if (policyMap.has(policyName)) {
          throw new Error("Duplicate policy names not allowed in pipeline");
        }
        const node = {
          policy,
          dependsOn: new Set,
          dependants: new Set
        };
        if (options.afterPhase) {
          node.afterPhase = getPhase(options.afterPhase);
          node.afterPhase.hasAfterPolicies = true;
        }
        policyMap.set(policyName, node);
        const phase = getPhase(options.phase);
        phase.policies.add(node);
      }
      for (const descriptor of this._policies) {
        const { policy, options } = descriptor;
        const policyName = policy.name;
        const node = policyMap.get(policyName);
        if (!node) {
          throw new Error(`Missing node for policy ${policyName}`);
        }
        if (options.afterPolicies) {
          for (const afterPolicyName of options.afterPolicies) {
            const afterNode = policyMap.get(afterPolicyName);
            if (afterNode) {
              node.dependsOn.add(afterNode);
              afterNode.dependants.add(node);
            }
          }
        }
        if (options.beforePolicies) {
          for (const beforePolicyName of options.beforePolicies) {
            const beforeNode = policyMap.get(beforePolicyName);
            if (beforeNode) {
              beforeNode.dependsOn.add(node);
              node.dependants.add(beforeNode);
            }
          }
        }
      }
      function walkPhase(phase) {
        phase.hasRun = true;
        for (const node of phase.policies) {
          if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
            continue;
          }
          if (node.dependsOn.size === 0) {
            result.push(node.policy);
            for (const dependant of node.dependants) {
              dependant.dependsOn.delete(node);
            }
            policyMap.delete(node.policy.name);
            phase.policies.delete(node);
          }
        }
      }
      function walkPhases() {
        for (const phase of orderedPhases) {
          walkPhase(phase);
          if (phase.policies.size > 0 && phase !== noPhase) {
            if (!noPhase.hasRun) {
              walkPhase(noPhase);
            }
            return;
          }
          if (phase.hasAfterPolicies) {
            walkPhase(noPhase);
          }
        }
      }
      let iteration = 0;
      while (policyMap.size > 0) {
        iteration++;
        const initialResultLength = result.length;
        walkPhases();
        if (result.length <= initialResultLength && iteration > 1) {
          throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
        }
      }
      return result;
    }
  }
  function createEmptyPipeline() {
    return HttpPipeline.create();
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values2;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values2 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values2);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/@azure/logger/dist/commonjs/log.js
var require_log = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.log = log;
  var tslib_1 = require_tslib();
  var node_os_1 = __require("node:os");
  var node_util_1 = tslib_1.__importDefault(__require("node:util"));
  var process2 = tslib_1.__importStar(__require("node:process"));
  function log(message, ...args) {
    process2.stderr.write(`${node_util_1.default.format(message, ...args)}${node_os_1.EOL}`);
  }
});

// node_modules/@azure/logger/dist/commonjs/debug.js
var require_debug = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var log_js_1 = require_log();
  var debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || undefined;
  var enabledString;
  var enabledNamespaces = [];
  var skippedNamespaces = [];
  var debuggers = [];
  if (debugEnvVariable) {
    enable(debugEnvVariable);
  }
  var debugObj = Object.assign((namespace) => {
    return createDebugger(namespace);
  }, {
    enable,
    enabled,
    disable,
    log: log_js_1.log
  });
  function enable(namespaces) {
    enabledString = namespaces;
    enabledNamespaces = [];
    skippedNamespaces = [];
    const wildcard = /\*/g;
    const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
    for (const ns of namespaceList) {
      if (ns.startsWith("-")) {
        skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
      } else {
        enabledNamespaces.push(new RegExp(`^${ns}$`));
      }
    }
    for (const instance of debuggers) {
      instance.enabled = enabled(instance.namespace);
    }
  }
  function enabled(namespace) {
    if (namespace.endsWith("*")) {
      return true;
    }
    for (const skipped of skippedNamespaces) {
      if (skipped.test(namespace)) {
        return false;
      }
    }
    for (const enabledNamespace of enabledNamespaces) {
      if (enabledNamespace.test(namespace)) {
        return true;
      }
    }
    return false;
  }
  function disable() {
    const result = enabledString || "";
    enable("");
    return result;
  }
  function createDebugger(namespace) {
    const newDebugger = Object.assign(debug, {
      enabled: enabled(namespace),
      destroy,
      log: debugObj.log,
      namespace,
      extend
    });
    function debug(...args) {
      if (!newDebugger.enabled) {
        return;
      }
      if (args.length > 0) {
        args[0] = `${namespace} ${args[0]}`;
      }
      newDebugger.log(...args);
    }
    debuggers.push(newDebugger);
    return newDebugger;
  }
  function destroy() {
    const index = debuggers.indexOf(this);
    if (index >= 0) {
      debuggers.splice(index, 1);
      return true;
    }
    return false;
  }
  function extend(namespace) {
    const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
    newDebugger.log = this.log;
    return newDebugger;
  }
  exports.default = debugObj;
});

// node_modules/@azure/logger/dist/commonjs/index.js
var require_commonjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureLogger = undefined;
  exports.setLogLevel = setLogLevel;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger;
  var tslib_1 = require_tslib();
  var debug_js_1 = tslib_1.__importDefault(require_debug());
  var registeredLoggers = new Set;
  var logLevelFromEnv = typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL || undefined;
  var azureLogLevel;
  exports.AzureLogger = (0, debug_js_1.default)("azure");
  exports.AzureLogger.log = (...args) => {
    debug_js_1.default.log(...args);
  };
  var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
  if (logLevelFromEnv) {
    if (isAzureLogLevel(logLevelFromEnv)) {
      setLogLevel(logLevelFromEnv);
    } else {
      console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
    }
  }
  function setLogLevel(level) {
    if (level && !isAzureLogLevel(level)) {
      throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
    }
    azureLogLevel = level;
    const enabledNamespaces = [];
    for (const logger of registeredLoggers) {
      if (shouldEnable(logger)) {
        enabledNamespaces.push(logger.namespace);
      }
    }
    debug_js_1.default.enable(enabledNamespaces.join(","));
  }
  function getLogLevel() {
    return azureLogLevel;
  }
  var levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
  };
  function createClientLogger(namespace) {
    const clientRootLogger = exports.AzureLogger.extend(namespace);
    patchLogMethod(exports.AzureLogger, clientRootLogger);
    return {
      error: createLogger(clientRootLogger, "error"),
      warning: createLogger(clientRootLogger, "warning"),
      info: createLogger(clientRootLogger, "info"),
      verbose: createLogger(clientRootLogger, "verbose")
    };
  }
  function patchLogMethod(parent, child) {
    child.log = (...args) => {
      parent.log(...args);
    };
  }
  function createLogger(parent, level) {
    const logger = Object.assign(parent.extend(level), {
      level
    });
    patchLogMethod(parent, logger);
    if (shouldEnable(logger)) {
      const enabledNamespaces = debug_js_1.default.disable();
      debug_js_1.default.enable(enabledNamespaces + "," + logger.namespace);
    }
    registeredLoggers.add(logger);
    return logger;
  }
  function shouldEnable(logger) {
    return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);
  }
  function isAzureLogLevel(logLevel) {
    return AZURE_LOG_LEVELS.includes(logLevel);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/log.js
var require_log2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs();
  exports.logger = (0, logger_1.createClientLogger)("core-rest-pipeline");
});

// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;

  class AbortError extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError;
});

// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;
  var AbortError_js_1 = require_AbortError();
  Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
    return AbortError_js_1.AbortError;
  } });
});

// node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js
var require_createAbortablePromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createAbortablePromise = createAbortablePromise;
  var abort_controller_1 = require_commonjs2();
  function createAbortablePromise(buildPromise, options) {
    const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options !== null && options !== undefined ? options : {};
    return new Promise((resolve, reject) => {
      function rejectOnAbort() {
        reject(new abort_controller_1.AbortError(abortErrorMsg !== null && abortErrorMsg !== undefined ? abortErrorMsg : "The operation was aborted."));
      }
      function removeListeners() {
        abortSignal === null || abortSignal === undefined || abortSignal.removeEventListener("abort", onAbort);
      }
      function onAbort() {
        cleanupBeforeAbort === null || cleanupBeforeAbort === undefined || cleanupBeforeAbort();
        removeListeners();
        rejectOnAbort();
      }
      if (abortSignal === null || abortSignal === undefined ? undefined : abortSignal.aborted) {
        return rejectOnAbort();
      }
      try {
        buildPromise((x) => {
          removeListeners();
          resolve(x);
        }, (x) => {
          removeListeners();
          reject(x);
        });
      } catch (err) {
        reject(err);
      }
      abortSignal === null || abortSignal === undefined || abortSignal.addEventListener("abort", onAbort);
    });
  }
});

// node_modules/@azure/core-util/dist/commonjs/random.js
var require_random = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
  function getRandomIntegerInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
  }
});

// node_modules/@azure/core-util/dist/commonjs/delay.js
var require_delay = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = delay;
  exports.calculateRetryDelay = calculateRetryDelay;
  var createAbortablePromise_js_1 = require_createAbortablePromise();
  var random_js_1 = require_random();
  var StandardAbortMessage = "The delay was aborted.";
  function delay(timeInMs, options) {
    let token;
    const { abortSignal, abortErrorMsg } = options !== null && options !== undefined ? options : {};
    return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
      token = setTimeout(resolve, timeInMs);
    }, {
      cleanupBeforeAbort: () => clearTimeout(token),
      abortSignal,
      abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== undefined ? abortErrorMsg : StandardAbortMessage
    });
  }
  function calculateRetryDelay(retryAttempt, config) {
    const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
    const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
    const retryAfterInMs = clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
    return { retryAfterInMs };
  }
});

// node_modules/@azure/core-util/dist/commonjs/aborterUtils.js
var require_aborterUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cancelablePromiseRace = cancelablePromiseRace;
  async function cancelablePromiseRace(abortablePromiseBuilders, options) {
    var _a, _b;
    const aborter = new AbortController;
    function abortHandler() {
      aborter.abort();
    }
    (_a = options === null || options === undefined ? undefined : options.abortSignal) === null || _a === undefined || _a.addEventListener("abort", abortHandler);
    try {
      return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
    } finally {
      aborter.abort();
      (_b = options === null || options === undefined ? undefined : options.abortSignal) === null || _b === undefined || _b.removeEventListener("abort", abortHandler);
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/object.js
var require_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObject = isObject;
  function isObject(input) {
    return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
  }
});

// node_modules/@azure/core-util/dist/commonjs/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isError = isError;
  exports.getErrorMessage = getErrorMessage;
  var object_js_1 = require_object();
  function isError(e) {
    if ((0, object_js_1.isObject)(e)) {
      const hasName = typeof e.name === "string";
      const hasMessage = typeof e.message === "string";
      return hasName && hasMessage;
    }
    return false;
  }
  function getErrorMessage(e) {
    if (isError(e)) {
      return e.message;
    } else {
      let stringified;
      try {
        if (typeof e === "object" && e) {
          stringified = JSON.stringify(e);
        } else {
          stringified = String(e);
        }
      } catch (err) {
        stringified = "[unable to stringify input]";
      }
      return `Unknown error ${stringified}`;
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/sha256.js
var require_sha256 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.computeSha256Hmac = computeSha256Hmac;
  exports.computeSha256Hash = computeSha256Hash;
  var crypto_1 = __require("crypto");
  async function computeSha256Hmac(key, stringToSign, encoding) {
    const decodedKey = Buffer.from(key, "base64");
    return (0, crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
  }
  async function computeSha256Hash(content, encoding) {
    return (0, crypto_1.createHash)("sha256").update(content).digest(encoding);
  }
});

// node_modules/@azure/core-util/dist/commonjs/typeGuards.js
var require_typeGuards = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDefined = isDefined;
  exports.isObjectWithProperties = isObjectWithProperties;
  exports.objectHasProperty = objectHasProperty;
  function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
  }
  function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object") {
      return false;
    }
    for (const property of properties) {
      if (!objectHasProperty(thing, property)) {
        return false;
      }
    }
    return true;
  }
  function objectHasProperty(thing, property) {
    return isDefined(thing) && typeof thing === "object" && property in thing;
  }
});

// node_modules/@azure/core-util/dist/commonjs/uuidUtils.js
var require_uuidUtils = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomUUID = randomUUID;
  var crypto_1 = __require("crypto");
  var uuidFunction = typeof ((_a = globalThis === null || globalThis === undefined ? undefined : globalThis.crypto) === null || _a === undefined ? undefined : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : crypto_1.randomUUID;
  function randomUUID() {
    return uuidFunction();
  }
});

// node_modules/@azure/core-util/dist/commonjs/checkEnvironment.js
var require_checkEnvironment = __commonJS((exports) => {
  var _a;
  var _b;
  var _c;
  var _d;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isReactNative = exports.isNodeRuntime = exports.isNode = exports.isNodeLike = exports.isBun = exports.isDeno = exports.isWebWorker = exports.isBrowser = undefined;
  exports.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  exports.isWebWorker = typeof self === "object" && typeof (self === null || self === undefined ? undefined : self.importScripts) === "function" && (((_a = self.constructor) === null || _a === undefined ? undefined : _a.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === undefined ? undefined : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === undefined ? undefined : _c.name) === "SharedWorkerGlobalScope");
  exports.isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
  exports.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
  exports.isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean((_d = globalThis.process.versions) === null || _d === undefined ? undefined : _d.node);
  exports.isNode = exports.isNodeLike;
  exports.isNodeRuntime = exports.isNodeLike && !exports.isBun && !exports.isDeno;
  exports.isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === undefined ? undefined : navigator.product) === "ReactNative";
});

// node_modules/@azure/core-util/dist/commonjs/bytesEncoding.js
var require_bytesEncoding = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uint8ArrayToString = uint8ArrayToString;
  exports.stringToUint8Array = stringToUint8Array;
  function uint8ArrayToString(bytes, format) {
    return Buffer.from(bytes).toString(format);
  }
  function stringToUint8Array(value, format) {
    return Buffer.from(value, format);
  }
});

// node_modules/@azure/core-util/dist/commonjs/index.js
var require_commonjs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringToUint8Array = exports.uint8ArrayToString = exports.isWebWorker = exports.isReactNative = exports.isDeno = exports.isNodeRuntime = exports.isNodeLike = exports.isNode = exports.isBun = exports.isBrowser = exports.randomUUID = exports.objectHasProperty = exports.isObjectWithProperties = exports.isDefined = exports.computeSha256Hmac = exports.computeSha256Hash = exports.getErrorMessage = exports.isError = exports.isObject = exports.getRandomIntegerInclusive = exports.createAbortablePromise = exports.cancelablePromiseRace = exports.calculateRetryDelay = exports.delay = undefined;
  var delay_js_1 = require_delay();
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_js_1.delay;
  } });
  Object.defineProperty(exports, "calculateRetryDelay", { enumerable: true, get: function() {
    return delay_js_1.calculateRetryDelay;
  } });
  var aborterUtils_js_1 = require_aborterUtils();
  Object.defineProperty(exports, "cancelablePromiseRace", { enumerable: true, get: function() {
    return aborterUtils_js_1.cancelablePromiseRace;
  } });
  var createAbortablePromise_js_1 = require_createAbortablePromise();
  Object.defineProperty(exports, "createAbortablePromise", { enumerable: true, get: function() {
    return createAbortablePromise_js_1.createAbortablePromise;
  } });
  var random_js_1 = require_random();
  Object.defineProperty(exports, "getRandomIntegerInclusive", { enumerable: true, get: function() {
    return random_js_1.getRandomIntegerInclusive;
  } });
  var object_js_1 = require_object();
  Object.defineProperty(exports, "isObject", { enumerable: true, get: function() {
    return object_js_1.isObject;
  } });
  var error_js_1 = require_error();
  Object.defineProperty(exports, "isError", { enumerable: true, get: function() {
    return error_js_1.isError;
  } });
  Object.defineProperty(exports, "getErrorMessage", { enumerable: true, get: function() {
    return error_js_1.getErrorMessage;
  } });
  var sha256_js_1 = require_sha256();
  Object.defineProperty(exports, "computeSha256Hash", { enumerable: true, get: function() {
    return sha256_js_1.computeSha256Hash;
  } });
  Object.defineProperty(exports, "computeSha256Hmac", { enumerable: true, get: function() {
    return sha256_js_1.computeSha256Hmac;
  } });
  var typeGuards_js_1 = require_typeGuards();
  Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
    return typeGuards_js_1.isDefined;
  } });
  Object.defineProperty(exports, "isObjectWithProperties", { enumerable: true, get: function() {
    return typeGuards_js_1.isObjectWithProperties;
  } });
  Object.defineProperty(exports, "objectHasProperty", { enumerable: true, get: function() {
    return typeGuards_js_1.objectHasProperty;
  } });
  var uuidUtils_js_1 = require_uuidUtils();
  Object.defineProperty(exports, "randomUUID", { enumerable: true, get: function() {
    return uuidUtils_js_1.randomUUID;
  } });
  var checkEnvironment_js_1 = require_checkEnvironment();
  Object.defineProperty(exports, "isBrowser", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isBrowser;
  } });
  Object.defineProperty(exports, "isBun", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isBun;
  } });
  Object.defineProperty(exports, "isNode", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isNode;
  } });
  Object.defineProperty(exports, "isNodeLike", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isNodeLike;
  } });
  Object.defineProperty(exports, "isNodeRuntime", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isNodeRuntime;
  } });
  Object.defineProperty(exports, "isDeno", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isDeno;
  } });
  Object.defineProperty(exports, "isReactNative", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isReactNative;
  } });
  Object.defineProperty(exports, "isWebWorker", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isWebWorker;
  } });
  var bytesEncoding_js_1 = require_bytesEncoding();
  Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function() {
    return bytesEncoding_js_1.uint8ArrayToString;
  } });
  Object.defineProperty(exports, "stringToUint8Array", { enumerable: true, get: function() {
    return bytesEncoding_js_1.stringToUint8Array;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/sanitizer.js
var require_sanitizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Sanitizer = undefined;
  var core_util_1 = require_commonjs3();
  var RedactedString = "REDACTED";
  var defaultAllowedHeaderNames = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "x-ms-useragent",
    "x-ms-correlation-request-id",
    "x-ms-request-id",
    "client-request-id",
    "ms-cv",
    "return-client-request-id",
    "traceparent",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Origin",
    "Accept",
    "Accept-Encoding",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent",
    "WWW-Authenticate"
  ];
  var defaultAllowedQueryParameters = ["api-version"];

  class Sanitizer {
    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
      allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
      allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
      this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
      this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
    }
    sanitize(obj) {
      const seen = new Set;
      return JSON.stringify(obj, (key, value) => {
        if (value instanceof Error) {
          return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
        }
        if (key === "headers") {
          return this.sanitizeHeaders(value);
        } else if (key === "url") {
          return this.sanitizeUrl(value);
        } else if (key === "query") {
          return this.sanitizeQuery(value);
        } else if (key === "body") {
          return;
        } else if (key === "response") {
          return;
        } else if (key === "operationSpec") {
          return;
        } else if (Array.isArray(value) || (0, core_util_1.isObject)(value)) {
          if (seen.has(value)) {
            return "[Circular]";
          }
          seen.add(value);
        }
        return value;
      }, 2);
    }
    sanitizeUrl(value) {
      if (typeof value !== "string" || value === null || value === "") {
        return value;
      }
      const url = new URL(value);
      if (!url.search) {
        return value;
      }
      for (const [key] of url.searchParams) {
        if (!this.allowedQueryParameters.has(key.toLowerCase())) {
          url.searchParams.set(key, RedactedString);
        }
      }
      return url.toString();
    }
    sanitizeHeaders(obj) {
      const sanitized = {};
      for (const key of Object.keys(obj)) {
        if (this.allowedHeaderNames.has(key.toLowerCase())) {
          sanitized[key] = obj[key];
        } else {
          sanitized[key] = RedactedString;
        }
      }
      return sanitized;
    }
    sanitizeQuery(value) {
      if (typeof value !== "object" || value === null) {
        return value;
      }
      const sanitized = {};
      for (const k of Object.keys(value)) {
        if (this.allowedQueryParameters.has(k.toLowerCase())) {
          sanitized[k] = value[k];
        } else {
          sanitized[k] = RedactedString;
        }
      }
      return sanitized;
    }
  }
  exports.Sanitizer = Sanitizer;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/logPolicy.js
var require_logPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logPolicyName = undefined;
  exports.logPolicy = logPolicy;
  var log_js_1 = require_log2();
  var sanitizer_js_1 = require_sanitizer();
  exports.logPolicyName = "logPolicy";
  function logPolicy(options = {}) {
    var _a;
    const logger = (_a = options.logger) !== null && _a !== undefined ? _a : log_js_1.logger.info;
    const sanitizer = new sanitizer_js_1.Sanitizer({
      additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
      additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
    });
    return {
      name: exports.logPolicyName,
      async sendRequest(request, next) {
        if (!logger.enabled) {
          return next(request);
        }
        logger(`Request: ${sanitizer.sanitize(request)}`);
        const response = await next(request);
        logger(`Response status code: ${response.status}`);
        logger(`Headers: ${sanitizer.sanitize(response.headers)}`);
        return response;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redirectPolicyName = undefined;
  exports.redirectPolicy = redirectPolicy;
  exports.redirectPolicyName = "redirectPolicy";
  var allowedRedirect = ["GET", "HEAD"];
  function redirectPolicy(options = {}) {
    const { maxRetries = 20 } = options;
    return {
      name: exports.redirectPolicyName,
      async sendRequest(request, next) {
        const response = await next(request);
        return handleRedirect(next, response, maxRetries);
      }
    };
  }
  async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
    const { request, status, headers } = response;
    const locationHeader = headers.get("location");
    if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
      const url = new URL(locationHeader, request.url);
      request.url = url.toString();
      if (status === 303) {
        request.method = "GET";
        request.headers.delete("Content-Length");
        delete request.body;
      }
      request.headers.delete("Authorization");
      const res = await next(request);
      return handleRedirect(next, res, maxRetries, currentRetries + 1);
    }
    return response;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHeaderName = getHeaderName;
  exports.setPlatformSpecificData = setPlatformSpecificData;
  var tslib_1 = require_tslib();
  var os = tslib_1.__importStar(__require("node:os"));
  var process2 = tslib_1.__importStar(__require("node:process"));
  function getHeaderName() {
    return "User-Agent";
  }
  async function setPlatformSpecificData(map) {
    if (process2 && process2.versions) {
      const versions = process2.versions;
      if (versions.bun) {
        map.set("Bun", versions.bun);
      } else if (versions.deno) {
        map.set("Deno", versions.deno);
      } else if (versions.node) {
        map.set("Node", versions.node);
      }
    }
    map.set("OS", `(${os.arch()}-${os.type()}-${os.release()})`);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = undefined;
  exports.SDK_VERSION = "1.18.2";
  exports.DEFAULT_RETRY_POLICY_COUNT = 3;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgent.js
var require_userAgent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentHeaderName = getUserAgentHeaderName;
  exports.getUserAgentValue = getUserAgentValue;
  var userAgentPlatform_js_1 = require_userAgentPlatform();
  var constants_js_1 = require_constants2();
  function getUserAgentString(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo) {
      const token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  function getUserAgentHeaderName() {
    return (0, userAgentPlatform_js_1.getHeaderName)();
  }
  async function getUserAgentValue(prefix) {
    const runtimeInfo = new Map;
    runtimeInfo.set("core-rest-pipeline", constants_js_1.SDK_VERSION);
    await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
    const defaultAgent = getUserAgentString(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.userAgentPolicyName = undefined;
  exports.userAgentPolicy = userAgentPolicy;
  var userAgent_js_1 = require_userAgent();
  var UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
  exports.userAgentPolicyName = "userAgentPolicy";
  function userAgentPolicy(options = {}) {
    const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
    return {
      name: exports.userAgentPolicyName,
      async sendRequest(request, next) {
        if (!request.headers.has(UserAgentHeaderName)) {
          request.headers.set(UserAgentHeaderName, await userAgentValue);
        }
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/typeGuards.js
var require_typeGuards2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNodeReadableStream = isNodeReadableStream;
  exports.isWebReadableStream = isWebReadableStream;
  exports.isReadableStream = isReadableStream;
  exports.isBlob = isBlob;
  function isNodeReadableStream(x) {
    return Boolean(x && typeof x["pipe"] === "function");
  }
  function isWebReadableStream(x) {
    return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
  }
  function isReadableStream(x) {
    return isNodeReadableStream(x) || isWebReadableStream(x);
  }
  function isBlob(x) {
    return typeof x.stream === "function";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/file.js
var require_file = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRawContent = getRawContent;
  exports.createFileFromStream = createFileFromStream;
  exports.createFile = createFile;
  var core_util_1 = require_commonjs3();
  var typeGuards_js_1 = require_typeGuards2();
  var unimplementedMethods = {
    arrayBuffer: () => {
      throw new Error("Not implemented");
    },
    bytes: () => {
      throw new Error("Not implemented");
    },
    slice: () => {
      throw new Error("Not implemented");
    },
    text: () => {
      throw new Error("Not implemented");
    }
  };
  var rawContent = Symbol("rawContent");
  function hasRawContent(x) {
    return typeof x[rawContent] === "function";
  }
  function getRawContent(blob) {
    if (hasRawContent(blob)) {
      return blob[rawContent]();
    } else {
      return blob.stream();
    }
  }
  function createFileFromStream(stream, name, options = {}) {
    var _a, _b, _c, _d;
    return Object.assign(Object.assign({}, unimplementedMethods), { type: (_a = options.type) !== null && _a !== undefined ? _a : "", lastModified: (_b = options.lastModified) !== null && _b !== undefined ? _b : new Date().getTime(), webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== undefined ? _c : "", size: (_d = options.size) !== null && _d !== undefined ? _d : -1, name, stream: () => {
      const s = stream();
      if ((0, typeGuards_js_1.isNodeReadableStream)(s)) {
        throw new Error("Not supported: a Node stream was provided as input to createFileFromStream.");
      }
      return s;
    }, [rawContent]: stream });
  }
  function createFile(content, name, options = {}) {
    var _a, _b, _c;
    if (core_util_1.isNodeLike) {
      return Object.assign(Object.assign({}, unimplementedMethods), { type: (_a = options.type) !== null && _a !== undefined ? _a : "", lastModified: (_b = options.lastModified) !== null && _b !== undefined ? _b : new Date().getTime(), webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== undefined ? _c : "", size: content.byteLength, name, arrayBuffer: async () => content.buffer, stream: () => new Blob([content]).stream(), [rawContent]: () => content });
    } else {
      return new File([content], name, options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/concat.js
var require_concat = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = concat;
  var tslib_1 = require_tslib();
  var node_stream_1 = __require("node:stream");
  var typeGuards_js_1 = require_typeGuards2();
  var file_js_1 = require_file();
  function streamAsyncIterator() {
    return tslib_1.__asyncGenerator(this, arguments, function* streamAsyncIterator_1() {
      const reader = this.getReader();
      try {
        while (true) {
          const { done, value } = yield tslib_1.__await(reader.read());
          if (done) {
            return yield tslib_1.__await(undefined);
          }
          yield yield tslib_1.__await(value);
        }
      } finally {
        reader.releaseLock();
      }
    });
  }
  function makeAsyncIterable(webStream) {
    if (!webStream[Symbol.asyncIterator]) {
      webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
    }
    if (!webStream.values) {
      webStream.values = streamAsyncIterator.bind(webStream);
    }
  }
  function ensureNodeStream(stream) {
    if (stream instanceof ReadableStream) {
      makeAsyncIterable(stream);
      return node_stream_1.Readable.fromWeb(stream);
    } else {
      return stream;
    }
  }
  function toStream(source) {
    if (source instanceof Uint8Array) {
      return node_stream_1.Readable.from(Buffer.from(source));
    } else if ((0, typeGuards_js_1.isBlob)(source)) {
      return toStream((0, file_js_1.getRawContent)(source));
    } else {
      return ensureNodeStream(source);
    }
  }
  async function concat(sources) {
    return function() {
      const streams = sources.map((x) => typeof x === "function" ? x() : x).map(toStream);
      return node_stream_1.Readable.from(function() {
        return tslib_1.__asyncGenerator(this, arguments, function* () {
          var _a, e_1, _b, _c;
          for (const stream of streams) {
            try {
              for (var _d = true, stream_1 = (e_1 = undefined, tslib_1.__asyncValues(stream)), stream_1_1;stream_1_1 = yield tslib_1.__await(stream_1.next()), _a = stream_1_1.done, !_a; _d = true) {
                _c = stream_1_1.value;
                _d = false;
                const chunk = _c;
                yield yield tslib_1.__await(chunk);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_d && !_a && (_b = stream_1.return))
                  yield tslib_1.__await(_b.call(stream_1));
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      }());
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multipartPolicyName = undefined;
  exports.multipartPolicy = multipartPolicy;
  var core_util_1 = require_commonjs3();
  var concat_js_1 = require_concat();
  var typeGuards_js_1 = require_typeGuards2();
  function generateBoundary() {
    return `----AzSDKFormBoundary${(0, core_util_1.randomUUID)()}`;
  }
  function encodeHeaders(headers) {
    let result = "";
    for (const [key, value] of headers) {
      result += `${key}: ${value}\r
`;
    }
    return result;
  }
  function getLength(source) {
    if (source instanceof Uint8Array) {
      return source.byteLength;
    } else if ((0, typeGuards_js_1.isBlob)(source)) {
      return source.size === -1 ? undefined : source.size;
    } else {
      return;
    }
  }
  function getTotalLength(sources) {
    let total = 0;
    for (const source of sources) {
      const partLength = getLength(source);
      if (partLength === undefined) {
        return;
      } else {
        total += partLength;
      }
    }
    return total;
  }
  async function buildRequestBody(request, parts, boundary) {
    const sources = [
      (0, core_util_1.stringToUint8Array)(`--${boundary}`, "utf-8"),
      ...parts.flatMap((part) => [
        (0, core_util_1.stringToUint8Array)(`\r
`, "utf-8"),
        (0, core_util_1.stringToUint8Array)(encodeHeaders(part.headers), "utf-8"),
        (0, core_util_1.stringToUint8Array)(`\r
`, "utf-8"),
        part.body,
        (0, core_util_1.stringToUint8Array)(`\r
--${boundary}`, "utf-8")
      ]),
      (0, core_util_1.stringToUint8Array)(`--\r
\r
`, "utf-8")
    ];
    const contentLength = getTotalLength(sources);
    if (contentLength) {
      request.headers.set("Content-Length", contentLength);
    }
    request.body = await (0, concat_js_1.concat)(sources);
  }
  exports.multipartPolicyName = "multipartPolicy";
  var maxBoundaryLength = 70;
  var validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
  function assertValidBoundary(boundary) {
    if (boundary.length > maxBoundaryLength) {
      throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
    }
    if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
      throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
    }
  }
  function multipartPolicy() {
    return {
      name: exports.multipartPolicyName,
      async sendRequest(request, next) {
        var _a;
        if (!request.multipartBody) {
          return next(request);
        }
        if (request.body) {
          throw new Error("multipartBody and regular body cannot be set at the same time");
        }
        let boundary = request.multipartBody.boundary;
        const contentTypeHeader = (_a = request.headers.get("Content-Type")) !== null && _a !== undefined ? _a : "multipart/mixed";
        const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
        if (!parsedHeader) {
          throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
        }
        const [, contentType, parsedBoundary] = parsedHeader;
        if (parsedBoundary && boundary && parsedBoundary !== boundary) {
          throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
        }
        boundary !== null && boundary !== undefined || (boundary = parsedBoundary);
        if (boundary) {
          assertValidBoundary(boundary);
        } else {
          boundary = generateBoundary();
        }
        request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
        await buildRequestBody(request, request.multipartBody.parts, boundary);
        request.multipartBody = undefined;
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decompressResponsePolicyName = undefined;
  exports.decompressResponsePolicy = decompressResponsePolicy;
  exports.decompressResponsePolicyName = "decompressResponsePolicy";
  function decompressResponsePolicy() {
    return {
      name: exports.decompressResponsePolicyName,
      async sendRequest(request, next) {
        if (request.method !== "HEAD") {
          request.headers.set("Accept-Encoding", "gzip,deflate");
        }
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;

  class AbortError extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError;
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;
  var AbortError_js_1 = require_AbortError2();
  Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
    return AbortError_js_1.AbortError;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = delay;
  exports.parseHeaderValueAsNumber = parseHeaderValueAsNumber;
  var abort_controller_1 = require_commonjs4();
  var StandardAbortMessage = "The operation was aborted.";
  function delay(delayInMs, value, options) {
    return new Promise((resolve, reject) => {
      let timer = undefined;
      let onAborted = undefined;
      const rejectOnAbort = () => {
        return reject(new abort_controller_1.AbortError((options === null || options === undefined ? undefined : options.abortErrorMsg) ? options === null || options === undefined ? undefined : options.abortErrorMsg : StandardAbortMessage));
      };
      const removeListeners = () => {
        if ((options === null || options === undefined ? undefined : options.abortSignal) && onAborted) {
          options.abortSignal.removeEventListener("abort", onAborted);
        }
      };
      onAborted = () => {
        if (timer) {
          clearTimeout(timer);
        }
        removeListeners();
        return rejectOnAbort();
      };
      if ((options === null || options === undefined ? undefined : options.abortSignal) && options.abortSignal.aborted) {
        return rejectOnAbort();
      }
      timer = setTimeout(() => {
        removeListeners();
        resolve(value);
      }, delayInMs);
      if (options === null || options === undefined ? undefined : options.abortSignal) {
        options.abortSignal.addEventListener("abort", onAborted);
      }
    });
  }
  function parseHeaderValueAsNumber(response, headerName) {
    const value = response.headers.get(headerName);
    if (!value)
      return;
    const valueAsNum = Number(value);
    if (Number.isNaN(valueAsNum))
      return;
    return valueAsNum;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/retryStrategies/throttlingRetryStrategy.js
var require_throttlingRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isThrottlingRetryResponse = isThrottlingRetryResponse;
  exports.throttlingRetryStrategy = throttlingRetryStrategy;
  var helpers_js_1 = require_helpers();
  var RetryAfterHeader = "Retry-After";
  var AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
  function getRetryAfterInMs(response) {
    if (!(response && [429, 503].includes(response.status)))
      return;
    try {
      for (const header of AllRetryAfterHeaders) {
        const retryAfterValue = (0, helpers_js_1.parseHeaderValueAsNumber)(response, header);
        if (retryAfterValue === 0 || retryAfterValue) {
          const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;
          return retryAfterValue * multiplyingFactor;
        }
      }
      const retryAfterHeader = response.headers.get(RetryAfterHeader);
      if (!retryAfterHeader)
        return;
      const date = Date.parse(retryAfterHeader);
      const diff = date - Date.now();
      return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
    } catch (_a) {
      return;
    }
  }
  function isThrottlingRetryResponse(response) {
    return Number.isFinite(getRetryAfterInMs(response));
  }
  function throttlingRetryStrategy() {
    return {
      name: "throttlingRetryStrategy",
      retry({ response }) {
        const retryAfterInMs = getRetryAfterInMs(response);
        if (!Number.isFinite(retryAfterInMs)) {
          return { skipStrategy: true };
        }
        return {
          retryAfterInMs
        };
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/retryStrategies/exponentialRetryStrategy.js
var require_exponentialRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exponentialRetryStrategy = exponentialRetryStrategy;
  exports.isExponentialRetryResponse = isExponentialRetryResponse;
  exports.isSystemError = isSystemError;
  var core_util_1 = require_commonjs3();
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
  var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
  function exponentialRetryStrategy(options = {}) {
    var _a, _b;
    const retryInterval = (_a = options.retryDelayInMs) !== null && _a !== undefined ? _a : DEFAULT_CLIENT_RETRY_INTERVAL;
    const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== undefined ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    return {
      name: "exponentialRetryStrategy",
      retry({ retryCount, response, responseError }) {
        const matchedSystemError = isSystemError(responseError);
        const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
        const isExponential = isExponentialRetryResponse(response);
        const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
        const unknownResponse = response && ((0, throttlingRetryStrategy_js_1.isThrottlingRetryResponse)(response) || !isExponential);
        if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
          return { skipStrategy: true };
        }
        if (responseError && !matchedSystemError && !isExponential) {
          return { errorToThrow: responseError };
        }
        return (0, core_util_1.calculateRetryDelay)(retryCount, {
          retryDelayInMs: retryInterval,
          maxRetryDelayInMs: maxRetryInterval
        });
      }
    };
  }
  function isExponentialRetryResponse(response) {
    return Boolean(response && response.status !== undefined && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
  }
  function isSystemError(err) {
    if (!err) {
      return false;
    }
    return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryPolicy = retryPolicy;
  var helpers_js_1 = require_helpers();
  var logger_1 = require_commonjs();
  var abort_controller_1 = require_commonjs4();
  var constants_js_1 = require_constants2();
  var retryPolicyLogger = (0, logger_1.createClientLogger)("core-rest-pipeline retryPolicy");
  var retryPolicyName = "retryPolicy";
  function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
    const logger = options.logger || retryPolicyLogger;
    return {
      name: retryPolicyName,
      async sendRequest(request, next) {
        var _a, _b;
        let response;
        let responseError;
        let retryCount = -1;
        retryRequest:
          while (true) {
            retryCount += 1;
            response = undefined;
            responseError = undefined;
            try {
              logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
              response = await next(request);
              logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
            } catch (e) {
              logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
              responseError = e;
              if (!e || responseError.name !== "RestError") {
                throw e;
              }
              response = responseError.response;
            }
            if ((_a = request.abortSignal) === null || _a === undefined ? undefined : _a.aborted) {
              logger.error(`Retry ${retryCount}: Request aborted.`);
              const abortError = new abort_controller_1.AbortError;
              throw abortError;
            }
            if (retryCount >= ((_b = options.maxRetries) !== null && _b !== undefined ? _b : constants_js_1.DEFAULT_RETRY_POLICY_COUNT)) {
              logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
              if (responseError) {
                throw responseError;
              } else if (response) {
                return response;
              } else {
                throw new Error("Maximum retries reached with no response or error to throw");
              }
            }
            logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
            strategiesLoop:
              for (const strategy of strategies) {
                const strategyLogger = strategy.logger || retryPolicyLogger;
                strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                const modifiers = strategy.retry({
                  retryCount,
                  response,
                  responseError
                });
                if (modifiers.skipStrategy) {
                  strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                  continue strategiesLoop;
                }
                const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
                if (errorToThrow) {
                  strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                  throw errorToThrow;
                }
                if (retryAfterInMs || retryAfterInMs === 0) {
                  strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                  await (0, helpers_js_1.delay)(retryAfterInMs, undefined, { abortSignal: request.abortSignal });
                  continue retryRequest;
                }
                if (redirectTo) {
                  strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                  request.url = redirectTo;
                  continue retryRequest;
                }
              }
            if (responseError) {
              logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
              throw responseError;
            }
            if (response) {
              logger.info(`None of the retry strategies could work with the received response. Returning it.`);
              return response;
            }
          }
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultRetryPolicyName = undefined;
  exports.defaultRetryPolicy = defaultRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants2();
  exports.defaultRetryPolicyName = "defaultRetryPolicy";
  function defaultRetryPolicy(options = {}) {
    var _a;
    return {
      name: exports.defaultRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)(), (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(options)], {
        maxRetries: (_a = options.maxRetries) !== null && _a !== undefined ? _a : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/httpHeaders.js
var require_httpHeaders = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpHeaders = createHttpHeaders;
  function normalizeName(name) {
    return name.toLowerCase();
  }
  function* headerIterator(map) {
    for (const entry of map.values()) {
      yield [entry.name, entry.value];
    }
  }

  class HttpHeadersImpl {
    constructor(rawHeaders) {
      this._headersMap = new Map;
      if (rawHeaders) {
        for (const headerName of Object.keys(rawHeaders)) {
          this.set(headerName, rawHeaders[headerName]);
        }
      }
    }
    set(name, value) {
      this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
    }
    get(name) {
      var _a;
      return (_a = this._headersMap.get(normalizeName(name))) === null || _a === undefined ? undefined : _a.value;
    }
    has(name) {
      return this._headersMap.has(normalizeName(name));
    }
    delete(name) {
      this._headersMap.delete(normalizeName(name));
    }
    toJSON(options = {}) {
      const result = {};
      if (options.preserveCase) {
        for (const entry of this._headersMap.values()) {
          result[entry.name] = entry.value;
        }
      } else {
        for (const [normalizedName, entry] of this._headersMap) {
          result[normalizedName] = entry.value;
        }
      }
      return result;
    }
    toString() {
      return JSON.stringify(this.toJSON({ preserveCase: true }));
    }
    [Symbol.iterator]() {
      return headerIterator(this._headersMap);
    }
  }
  function createHttpHeaders(rawHeaders) {
    return new HttpHeadersImpl(rawHeaders);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formDataPolicyName = undefined;
  exports.formDataPolicy = formDataPolicy;
  var core_util_1 = require_commonjs3();
  var httpHeaders_js_1 = require_httpHeaders();
  exports.formDataPolicyName = "formDataPolicy";
  function formDataToFormDataMap(formData) {
    var _a;
    const formDataMap = {};
    for (const [key, value] of formData.entries()) {
      (_a = formDataMap[key]) !== null && _a !== undefined || (formDataMap[key] = []);
      formDataMap[key].push(value);
    }
    return formDataMap;
  }
  function formDataPolicy() {
    return {
      name: exports.formDataPolicyName,
      async sendRequest(request, next) {
        if (core_util_1.isNodeLike && typeof FormData !== "undefined" && request.body instanceof FormData) {
          request.formData = formDataToFormDataMap(request.body);
          request.body = undefined;
        }
        if (request.formData) {
          const contentType = request.headers.get("Content-Type");
          if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
            request.body = wwwFormUrlEncode(request.formData);
          } else {
            await prepareFormData(request.formData, request);
          }
          request.formData = undefined;
        }
        return next(request);
      }
    };
  }
  function wwwFormUrlEncode(formData) {
    const urlSearchParams = new URLSearchParams;
    for (const [key, value] of Object.entries(formData)) {
      if (Array.isArray(value)) {
        for (const subValue of value) {
          urlSearchParams.append(key, subValue.toString());
        }
      } else {
        urlSearchParams.append(key, value.toString());
      }
    }
    return urlSearchParams.toString();
  }
  async function prepareFormData(formData, request) {
    const contentType = request.headers.get("Content-Type");
    if (contentType && !contentType.startsWith("multipart/form-data")) {
      return;
    }
    request.headers.set("Content-Type", contentType !== null && contentType !== undefined ? contentType : "multipart/form-data");
    const parts = [];
    for (const [fieldName, values] of Object.entries(formData)) {
      for (const value of Array.isArray(values) ? values : [values]) {
        if (typeof value === "string") {
          parts.push({
            headers: (0, httpHeaders_js_1.createHttpHeaders)({
              "Content-Disposition": `form-data; name="${fieldName}"`
            }),
            body: (0, core_util_1.stringToUint8Array)(value, "utf-8")
          });
        } else if (value === undefined || value === null || typeof value !== "object") {
          throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
        } else {
          const fileName = value.name || "blob";
          const headers = (0, httpHeaders_js_1.createHttpHeaders)();
          headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
          headers.set("Content-Type", value.type || "application/octet-stream");
          parts.push({
            headers,
            body: value
          });
        }
      }
    }
    request.multipartBody = { parts };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error("Cannot require module "+"supports-color");})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.req = exports.json = exports.toBuffer = undefined;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  async function toBuffer(stream) {
    let length = 0;
    const chunks = [];
    for await (const chunk of stream) {
      length += chunk.length;
      chunks.push(chunk);
    }
    return Buffer.concat(chunks, length);
  }
  exports.toBuffer = toBuffer;
  async function json(stream) {
    const buf = await toBuffer(stream);
    const str = buf.toString("utf8");
    try {
      return JSON.parse(str);
    } catch (_err) {
      const err = _err;
      err.message += ` (input: ${str})`;
      throw err;
    }
  }
  exports.json = json;
  function req(url, opts = {}) {
    const href = typeof url === "string" ? url : url.href;
    const req2 = (href.startsWith("https:") ? https : http).request(url, opts);
    const promise = new Promise((resolve, reject) => {
      req2.once("response", resolve).once("error", reject).end();
    });
    req2.then = promise.then.bind(promise);
    return req2;
  }
  exports.req = req;
});

// node_modules/agent-base/dist/index.js
var require_dist = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Agent = undefined;
  var net = __importStar(__require("net"));
  var http = __importStar(__require("http"));
  var https_1 = __require("https");
  __exportStar(require_helpers2(), exports);
  var INTERNAL = Symbol("AgentBaseInternalState");

  class Agent extends http.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error;
      if (typeof stack !== "string")
        return false;
      return stack.split(`
`).some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    incrementSockets(name) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name]) {
        this.sockets[name] = [];
      }
      const fakeSocket = new net.Socket({ writable: false });
      this.sockets[name].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name, socket) {
      if (!this.sockets[name] || socket === null) {
        return;
      }
      const sockets = this.sockets[name];
      const index = sockets.indexOf(socket);
      if (index !== -1) {
        sockets.splice(index, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name];
        }
      }
    }
    getName(options) {
      const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_1.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name);
      Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
        this.decrementSockets(name, fakeSocket);
        if (socket instanceof http.Agent) {
          try {
            return socket.addRequest(req, connectOpts);
          } catch (err) {
            return cb(err);
          }
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req, options, cb);
      }, (err) => {
        this.decrementSockets(name, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = undefined;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports.Agent = Agent;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseProxyResponse = undefined;
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("readable", read);
      }
      function onend() {
        cleanup();
        debug("onend");
        reject(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function onerror(err) {
        cleanup();
        debug("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf(`\r
\r
`);
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split(`\r
`);
        const firstLine = headerParts.shift();
        if (!firstLine) {
          socket.destroy();
          return reject(new Error("No header received from proxy CONNECT response"));
        }
        const firstLineParts = firstLine.split(" ");
        const statusCode = +firstLineParts[1];
        const statusText = firstLineParts.slice(2).join(" ");
        const headers = {};
        for (const header of headerParts) {
          if (!header)
            continue;
          const firstColon = header.indexOf(":");
          if (firstColon === -1) {
            socket.destroy();
            return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
          }
          const key = header.slice(0, firstColon).toLowerCase();
          const value = header.slice(firstColon + 1).trimStart();
          const current = headers[key];
          if (typeof current === "string") {
            headers[key] = [current, value];
          } else if (Array.isArray(current)) {
            current.push(value);
          } else {
            headers[key] = value;
          }
        }
        debug("got proxy server response: %o %o", firstLine, headers);
        cleanup();
        resolve({
          connect: {
            statusCode,
            statusText,
            headers
          },
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("end", onend);
      read();
    });
  }
  exports.parseProxyResponse = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpsProxyAgent = undefined;
  var net = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var assert_1 = __importDefault(__require("assert"));
  var debug_1 = __importDefault(require_src());
  var agent_base_1 = require_dist();
  var url_1 = __require("url");
  var parse_proxy_response_1 = require_parse_proxy_response();
  var debug = (0, debug_1.default)("https-proxy-agent");
  var setServernameFromNonIpHost = (options) => {
    if (options.servername === undefined && options.host && !net.isIP(options.host)) {
      return {
        ...options,
        servername: options.host
      };
    }
    return options;
  };

  class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.options = { path: undefined };
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    async connect(req, opts) {
      const { proxy } = this;
      if (!opts.host) {
        throw new TypeError('No "host" provided');
      }
      let socket;
      if (proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
      } else {
        debug("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
      let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      headers.Host = `${host}:${opts.port}`;
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        payload += `${name}: ${headers[name]}\r
`;
      }
      const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
      socket.write(`${payload}\r
`);
      const { connect, buffered } = await proxyResponsePromise;
      req.emit("proxyConnect", connect);
      this.emit("proxyConnect", connect, req);
      if (connect.statusCode === 200) {
        req.once("socket", resume);
        if (opts.secureEndpoint) {
          debug("Upgrading socket connection to TLS");
          return tls.connect({
            ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
            socket
          });
        }
        return socket;
      }
      socket.destroy();
      const fakeSocket = new net.Socket({ writable: false });
      fakeSocket.readable = true;
      req.once("socket", (s) => {
        debug("Replaying proxy buffer for failed request");
        (0, assert_1.default)(s.listenerCount("data") > 0);
        s.push(buffered);
        s.push(null);
      });
      return fakeSocket;
    }
  }
  HttpsProxyAgent.protocols = ["http", "https"];
  exports.HttpsProxyAgent = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpProxyAgent = undefined;
  var net = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var debug_1 = __importDefault(require_src());
  var events_1 = __require("events");
  var agent_base_1 = require_dist();
  var url_1 = __require("url");
  var debug = (0, debug_1.default)("http-proxy-agent");

  class HttpProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    addRequest(req, opts) {
      req._header = null;
      this.setRequestProps(req, opts);
      super.addRequest(req, opts);
    }
    setRequestProps(req, opts) {
      const { proxy } = this;
      const protocol = opts.secureEndpoint ? "https:" : "http:";
      const hostname = req.getHeader("host") || "localhost";
      const base = `${protocol}//${hostname}`;
      const url = new url_1.URL(req.path, base);
      if (opts.port !== 80) {
        url.port = String(opts.port);
      }
      req.path = String(url);
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        const value = headers[name];
        if (value) {
          req.setHeader(name, value);
        }
      }
    }
    async connect(req, opts) {
      req._header = null;
      if (!req.path.includes("://")) {
        this.setRequestProps(req, opts);
      }
      let first;
      let endOfHeaders;
      debug("Regenerating stored HTTP header string for request");
      req._implicitHeader();
      if (req.outputData && req.outputData.length > 0) {
        debug("Patching connection write() output buffer with updated header");
        first = req.outputData[0].data;
        endOfHeaders = first.indexOf(`\r
\r
`) + 4;
        req.outputData[0].data = req._header + first.substring(endOfHeaders);
        debug("Output buffer: %o", req.outputData[0].data);
      }
      let socket;
      if (this.proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(this.connectOpts);
      } else {
        debug("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      await (0, events_1.once)(socket, "connect");
      return socket;
    }
  }
  HttpProxyAgent.protocols = ["http", "https"];
  exports.HttpProxyAgent = HttpProxyAgent;
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.globalNoProxyList = exports.proxyPolicyName = undefined;
  exports.loadNoProxy = loadNoProxy;
  exports.getDefaultProxySettings = getDefaultProxySettings;
  exports.proxyPolicy = proxyPolicy;
  var https_proxy_agent_1 = require_dist2();
  var http_proxy_agent_1 = require_dist3();
  var log_js_1 = require_log2();
  var HTTPS_PROXY = "HTTPS_PROXY";
  var HTTP_PROXY = "HTTP_PROXY";
  var ALL_PROXY = "ALL_PROXY";
  var NO_PROXY = "NO_PROXY";
  exports.proxyPolicyName = "proxyPolicy";
  exports.globalNoProxyList = [];
  var noProxyListLoaded = false;
  var globalBypassedMap = new Map;
  function getEnvironmentValue(name) {
    if (process.env[name]) {
      return process.env[name];
    } else if (process.env[name.toLowerCase()]) {
      return process.env[name.toLowerCase()];
    }
    return;
  }
  function loadEnvironmentProxyValue() {
    if (!process) {
      return;
    }
    const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
    const allProxy = getEnvironmentValue(ALL_PROXY);
    const httpProxy = getEnvironmentValue(HTTP_PROXY);
    return httpsProxy || allProxy || httpProxy;
  }
  function isBypassed(uri, noProxyList, bypassedMap) {
    if (noProxyList.length === 0) {
      return false;
    }
    const host = new URL(uri).hostname;
    if (bypassedMap === null || bypassedMap === undefined ? undefined : bypassedMap.has(host)) {
      return bypassedMap.get(host);
    }
    let isBypassedFlag = false;
    for (const pattern of noProxyList) {
      if (pattern[0] === ".") {
        if (host.endsWith(pattern)) {
          isBypassedFlag = true;
        } else {
          if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
            isBypassedFlag = true;
          }
        }
      } else {
        if (host === pattern) {
          isBypassedFlag = true;
        }
      }
    }
    bypassedMap === null || bypassedMap === undefined || bypassedMap.set(host, isBypassedFlag);
    return isBypassedFlag;
  }
  function loadNoProxy() {
    const noProxy = getEnvironmentValue(NO_PROXY);
    noProxyListLoaded = true;
    if (noProxy) {
      return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
    }
    return [];
  }
  function getDefaultProxySettings(proxyUrl) {
    if (!proxyUrl) {
      proxyUrl = loadEnvironmentProxyValue();
      if (!proxyUrl) {
        return;
      }
    }
    const parsedUrl = new URL(proxyUrl);
    const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
    return {
      host: schema + parsedUrl.hostname,
      port: Number.parseInt(parsedUrl.port || "80"),
      username: parsedUrl.username,
      password: parsedUrl.password
    };
  }
  function getDefaultProxySettingsInternal() {
    const envProxy = loadEnvironmentProxyValue();
    return envProxy ? new URL(envProxy) : undefined;
  }
  function getUrlFromProxySettings(settings) {
    let parsedProxyUrl;
    try {
      parsedProxyUrl = new URL(settings.host);
    } catch (_a) {
      throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
    }
    parsedProxyUrl.port = String(settings.port);
    if (settings.username) {
      parsedProxyUrl.username = settings.username;
    }
    if (settings.password) {
      parsedProxyUrl.password = settings.password;
    }
    return parsedProxyUrl;
  }
  function setProxyAgentOnRequest(request, cachedAgents, proxyUrl) {
    if (request.agent) {
      return;
    }
    const url = new URL(request.url);
    const isInsecure = url.protocol !== "https:";
    if (request.tlsSettings) {
      log_js_1.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
    }
    const headers = request.headers.toJSON();
    if (isInsecure) {
      if (!cachedAgents.httpProxyAgent) {
        cachedAgents.httpProxyAgent = new http_proxy_agent_1.HttpProxyAgent(proxyUrl, { headers });
      }
      request.agent = cachedAgents.httpProxyAgent;
    } else {
      if (!cachedAgents.httpsProxyAgent) {
        cachedAgents.httpsProxyAgent = new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, { headers });
      }
      request.agent = cachedAgents.httpsProxyAgent;
    }
  }
  function proxyPolicy(proxySettings, options) {
    if (!noProxyListLoaded) {
      exports.globalNoProxyList.push(...loadNoProxy());
    }
    const defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal();
    const cachedAgents = {};
    return {
      name: exports.proxyPolicyName,
      async sendRequest(request, next) {
        var _a;
        if (!request.proxySettings && defaultProxy && !isBypassed(request.url, (_a = options === null || options === undefined ? undefined : options.customNoProxyList) !== null && _a !== undefined ? _a : exports.globalNoProxyList, (options === null || options === undefined ? undefined : options.customNoProxyList) ? undefined : globalBypassedMap)) {
          setProxyAgentOnRequest(request, cachedAgents, defaultProxy);
        } else if (request.proxySettings) {
          setProxyAgentOnRequest(request, cachedAgents, getUrlFromProxySettings(request.proxySettings));
        }
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/setClientRequestIdPolicy.js
var require_setClientRequestIdPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setClientRequestIdPolicyName = undefined;
  exports.setClientRequestIdPolicy = setClientRequestIdPolicy;
  exports.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
    return {
      name: exports.setClientRequestIdPolicyName,
      async sendRequest(request, next) {
        if (!request.headers.has(requestIdHeaderName)) {
          request.headers.set(requestIdHeaderName, request.requestId);
        }
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tlsPolicyName = undefined;
  exports.tlsPolicy = tlsPolicy;
  exports.tlsPolicyName = "tlsPolicy";
  function tlsPolicy(tlsSettings) {
    return {
      name: exports.tlsPolicyName,
      sendRequest: async (req, next) => {
        if (!req.tlsSettings) {
          req.tlsSettings = tlsSettings;
        }
        return next(req);
      }
    };
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingContext.js
var require_tracingContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TracingContextImpl = exports.knownContextKeys = undefined;
  exports.createTracingContext = createTracingContext;
  exports.knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace")
  };
  function createTracingContext(options = {}) {
    let context = new TracingContextImpl(options.parentContext);
    if (options.span) {
      context = context.setValue(exports.knownContextKeys.span, options.span);
    }
    if (options.namespace) {
      context = context.setValue(exports.knownContextKeys.namespace, options.namespace);
    }
    return context;
  }

  class TracingContextImpl {
    constructor(initialContext) {
      this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : new Map;
    }
    setValue(key, value) {
      const newContext = new TracingContextImpl(this);
      newContext._contextMap.set(key, value);
      return newContext;
    }
    getValue(key) {
      return this._contextMap.get(key);
    }
    deleteValue(key) {
      const newContext = new TracingContextImpl(this);
      newContext._contextMap.delete(key);
      return newContext;
    }
  }
  exports.TracingContextImpl = TracingContextImpl;
});

// node_modules/@azure/core-tracing/dist/commonjs/state.js
var require_state = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.state = undefined;
  exports.state = {
    instrumenterImplementation: undefined
  };
});

// node_modules/@azure/core-tracing/dist/commonjs/instrumenter.js
var require_instrumenter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultTracingSpan = createDefaultTracingSpan;
  exports.createDefaultInstrumenter = createDefaultInstrumenter;
  exports.useInstrumenter = useInstrumenter;
  exports.getInstrumenter = getInstrumenter;
  var tracingContext_js_1 = require_tracingContext();
  var state_js_1 = require_state();
  function createDefaultTracingSpan() {
    return {
      end: () => {
      },
      isRecording: () => false,
      recordException: () => {
      },
      setAttribute: () => {
      },
      setStatus: () => {
      },
      addEvent: () => {
      }
    };
  }
  function createDefaultInstrumenter() {
    return {
      createRequestHeaders: () => {
        return {};
      },
      parseTraceparentHeader: () => {
        return;
      },
      startSpan: (_name, spanOptions) => {
        return {
          span: createDefaultTracingSpan(),
          tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext })
        };
      },
      withContext(_context, callback, ...callbackArgs) {
        return callback(...callbackArgs);
      }
    };
  }
  function useInstrumenter(instrumenter) {
    state_js_1.state.instrumenterImplementation = instrumenter;
  }
  function getInstrumenter() {
    if (!state_js_1.state.instrumenterImplementation) {
      state_js_1.state.instrumenterImplementation = createDefaultInstrumenter();
    }
    return state_js_1.state.instrumenterImplementation;
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingClient.js
var require_tracingClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTracingClient = createTracingClient;
  var instrumenter_js_1 = require_instrumenter();
  var tracingContext_js_1 = require_tracingContext();
  function createTracingClient(options) {
    const { namespace, packageName, packageVersion } = options;
    function startSpan(name, operationOptions, spanOptions) {
      var _a;
      const startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a = operationOptions === null || operationOptions === undefined ? undefined : operationOptions.tracingOptions) === null || _a === undefined ? undefined : _a.tracingContext }));
      let tracingContext = startSpanResult.tracingContext;
      const span = startSpanResult.span;
      if (!tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace)) {
        tracingContext = tracingContext.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
      }
      span.setAttribute("az.namespace", tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace));
      const updatedOptions = Object.assign({}, operationOptions, {
        tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === undefined ? undefined : operationOptions.tracingOptions), { tracingContext })
      });
      return {
        span,
        updatedOptions
      };
    }
    async function withSpan(name, operationOptions, callback, spanOptions) {
      const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
      try {
        const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
        span.setStatus({ status: "success" });
        return result;
      } catch (err) {
        span.setStatus({ status: "error", error: err });
        throw err;
      } finally {
        span.end();
      }
    }
    function withContext(context, callback, ...callbackArgs) {
      return (0, instrumenter_js_1.getInstrumenter)().withContext(context, callback, ...callbackArgs);
    }
    function parseTraceparentHeader(traceparentHeader) {
      return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
    }
    function createRequestHeaders(tracingContext) {
      return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext);
    }
    return {
      startSpan,
      withSpan,
      withContext,
      parseTraceparentHeader,
      createRequestHeaders
    };
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/index.js
var require_commonjs5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTracingClient = exports.useInstrumenter = undefined;
  var instrumenter_js_1 = require_instrumenter();
  Object.defineProperty(exports, "useInstrumenter", { enumerable: true, get: function() {
    return instrumenter_js_1.useInstrumenter;
  } });
  var tracingClient_js_1 = require_tracingClient();
  Object.defineProperty(exports, "createTracingClient", { enumerable: true, get: function() {
    return tracingClient_js_1.createTracingClient;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/inspect.js
var require_inspect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.custom = undefined;
  var node_util_1 = __require("node:util");
  exports.custom = node_util_1.inspect.custom;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/restError.js
var require_restError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RestError = undefined;
  exports.isRestError = isRestError;
  var core_util_1 = require_commonjs3();
  var inspect_js_1 = require_inspect();
  var sanitizer_js_1 = require_sanitizer();
  var errorSanitizer = new sanitizer_js_1.Sanitizer;

  class RestError extends Error {
    constructor(message, options = {}) {
      super(message);
      this.name = "RestError";
      this.code = options.code;
      this.statusCode = options.statusCode;
      Object.defineProperty(this, "request", { value: options.request, enumerable: false });
      Object.defineProperty(this, "response", { value: options.response, enumerable: false });
      Object.setPrototypeOf(this, RestError.prototype);
    }
    [inspect_js_1.custom]() {
      return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(Object.assign(Object.assign({}, this), { request: this.request, response: this.response }))}`;
    }
  }
  exports.RestError = RestError;
  RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
  RestError.PARSE_ERROR = "PARSE_ERROR";
  function isRestError(e) {
    if (e instanceof RestError) {
      return true;
    }
    return (0, core_util_1.isError)(e) && e.name === "RestError";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tracingPolicy.js
var require_tracingPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tracingPolicyName = undefined;
  exports.tracingPolicy = tracingPolicy;
  var core_tracing_1 = require_commonjs5();
  var constants_js_1 = require_constants2();
  var userAgent_js_1 = require_userAgent();
  var log_js_1 = require_log2();
  var core_util_1 = require_commonjs3();
  var restError_js_1 = require_restError();
  var sanitizer_js_1 = require_sanitizer();
  exports.tracingPolicyName = "tracingPolicy";
  function tracingPolicy(options = {}) {
    const userAgentPromise = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
    const sanitizer = new sanitizer_js_1.Sanitizer({
      additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
    });
    const tracingClient = tryCreateTracingClient();
    return {
      name: exports.tracingPolicyName,
      async sendRequest(request, next) {
        var _a;
        if (!tracingClient) {
          return next(request);
        }
        const userAgent = await userAgentPromise;
        const spanAttributes = {
          "http.url": sanitizer.sanitizeUrl(request.url),
          "http.method": request.method,
          "http.user_agent": userAgent,
          requestId: request.requestId
        };
        if (userAgent) {
          spanAttributes["http.user_agent"] = userAgent;
        }
        const { span, tracingContext } = (_a = tryCreateSpan(tracingClient, request, spanAttributes)) !== null && _a !== undefined ? _a : {};
        if (!span || !tracingContext) {
          return next(request);
        }
        try {
          const response = await tracingClient.withContext(tracingContext, next, request);
          tryProcessResponse(span, response);
          return response;
        } catch (err) {
          tryProcessError(span, err);
          throw err;
        }
      }
    };
  }
  function tryCreateTracingClient() {
    try {
      return (0, core_tracing_1.createTracingClient)({
        namespace: "",
        packageName: "@azure/core-rest-pipeline",
        packageVersion: constants_js_1.SDK_VERSION
      });
    } catch (e) {
      log_js_1.logger.warning(`Error when creating the TracingClient: ${(0, core_util_1.getErrorMessage)(e)}`);
      return;
    }
  }
  function tryCreateSpan(tracingClient, request, spanAttributes) {
    try {
      const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
        spanKind: "client",
        spanAttributes
      });
      if (!span.isRecording()) {
        span.end();
        return;
      }
      const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
      for (const [key, value] of Object.entries(headers)) {
        request.headers.set(key, value);
      }
      return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
    } catch (e) {
      log_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
      return;
    }
  }
  function tryProcessError(span, error) {
    try {
      span.setStatus({
        status: "error",
        error: (0, core_util_1.isError)(error) ? error : undefined
      });
      if ((0, restError_js_1.isRestError)(error) && error.statusCode) {
        span.setAttribute("http.status_code", error.statusCode);
      }
      span.end();
    } catch (e) {
      log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
    }
  }
  function tryProcessResponse(span, response) {
    try {
      span.setAttribute("http.status_code", response.status);
      const serviceRequestId = response.headers.get("x-ms-request-id");
      if (serviceRequestId) {
        span.setAttribute("serviceRequestId", serviceRequestId);
      }
      if (response.status >= 400) {
        span.setStatus({
          status: "error"
        });
      }
      span.end();
    } catch (e) {
      log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineFromOptions = createPipelineFromOptions;
  var logPolicy_js_1 = require_logPolicy();
  var pipeline_js_1 = require_pipeline();
  var redirectPolicy_js_1 = require_redirectPolicy();
  var userAgentPolicy_js_1 = require_userAgentPolicy();
  var multipartPolicy_js_1 = require_multipartPolicy();
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
  var formDataPolicy_js_1 = require_formDataPolicy();
  var core_util_1 = require_commonjs3();
  var proxyPolicy_js_1 = require_proxyPolicy();
  var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
  var tlsPolicy_js_1 = require_tlsPolicy();
  var tracingPolicy_js_1 = require_tracingPolicy();
  function createPipelineFromOptions(options) {
    var _a;
    const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
    if (core_util_1.isNodeLike) {
      if (options.tlsOptions) {
        pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
      }
      pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
      pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
    }
    pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
    pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
    pipeline.addPolicy((0, setClientRequestIdPolicy_js_1.setClientRequestIdPolicy)((_a = options.telemetryOptions) === null || _a === undefined ? undefined : _a.clientRequestIdHeaderName));
    pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
    pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
    pipeline.addPolicy((0, tracingPolicy_js_1.tracingPolicy)(Object.assign(Object.assign({}, options.userAgentOptions), options.loggingOptions)), {
      afterPhase: "Retry"
    });
    if (core_util_1.isNodeLike) {
      pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
    }
    pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
    return pipeline;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/nodeHttpClient.js
var require_nodeHttpClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBodyLength = getBodyLength;
  exports.createNodeHttpClient = createNodeHttpClient;
  var tslib_1 = require_tslib();
  var http = tslib_1.__importStar(__require("node:http"));
  var https = tslib_1.__importStar(__require("node:https"));
  var zlib = tslib_1.__importStar(__require("node:zlib"));
  var node_stream_1 = __require("node:stream");
  var abort_controller_1 = require_commonjs4();
  var httpHeaders_js_1 = require_httpHeaders();
  var restError_js_1 = require_restError();
  var log_js_1 = require_log2();
  var DEFAULT_TLS_SETTINGS = {};
  function isReadableStream(body) {
    return body && typeof body.pipe === "function";
  }
  function isStreamComplete(stream) {
    if (stream.readable === false) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      const handler = () => {
        resolve();
        stream.removeListener("close", handler);
        stream.removeListener("end", handler);
        stream.removeListener("error", handler);
      };
      stream.on("close", handler);
      stream.on("end", handler);
      stream.on("error", handler);
    });
  }
  function isArrayBuffer(body) {
    return body && typeof body.byteLength === "number";
  }

  class ReportTransform extends node_stream_1.Transform {
    _transform(chunk, _encoding, callback) {
      this.push(chunk);
      this.loadedBytes += chunk.length;
      try {
        this.progressCallback({ loadedBytes: this.loadedBytes });
        callback();
      } catch (e) {
        callback(e);
      }
    }
    constructor(progressCallback) {
      super();
      this.loadedBytes = 0;
      this.progressCallback = progressCallback;
    }
  }

  class NodeHttpClient {
    constructor() {
      this.cachedHttpsAgents = new WeakMap;
    }
    async sendRequest(request) {
      var _a, _b, _c;
      const abortController = new AbortController;
      let abortListener;
      if (request.abortSignal) {
        if (request.abortSignal.aborted) {
          throw new abort_controller_1.AbortError("The operation was aborted.");
        }
        abortListener = (event) => {
          if (event.type === "abort") {
            abortController.abort();
          }
        };
        request.abortSignal.addEventListener("abort", abortListener);
      }
      if (request.timeout > 0) {
        setTimeout(() => {
          abortController.abort();
        }, request.timeout);
      }
      const acceptEncoding = request.headers.get("Accept-Encoding");
      const shouldDecompress = (acceptEncoding === null || acceptEncoding === undefined ? undefined : acceptEncoding.includes("gzip")) || (acceptEncoding === null || acceptEncoding === undefined ? undefined : acceptEncoding.includes("deflate"));
      let body = typeof request.body === "function" ? request.body() : request.body;
      if (body && !request.headers.has("Content-Length")) {
        const bodyLength = getBodyLength(body);
        if (bodyLength !== null) {
          request.headers.set("Content-Length", bodyLength);
        }
      }
      let responseStream;
      try {
        if (body && request.onUploadProgress) {
          const onUploadProgress = request.onUploadProgress;
          const uploadReportStream = new ReportTransform(onUploadProgress);
          uploadReportStream.on("error", (e) => {
            log_js_1.logger.error("Error in upload progress", e);
          });
          if (isReadableStream(body)) {
            body.pipe(uploadReportStream);
          } else {
            uploadReportStream.end(body);
          }
          body = uploadReportStream;
        }
        const res = await this.makeRequest(request, abortController, body);
        const headers = getResponseHeaders(res);
        const status = (_a = res.statusCode) !== null && _a !== undefined ? _a : 0;
        const response = {
          status,
          headers,
          request
        };
        if (request.method === "HEAD") {
          res.resume();
          return response;
        }
        responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
        const onDownloadProgress = request.onDownloadProgress;
        if (onDownloadProgress) {
          const downloadReportStream = new ReportTransform(onDownloadProgress);
          downloadReportStream.on("error", (e) => {
            log_js_1.logger.error("Error in download progress", e);
          });
          responseStream.pipe(downloadReportStream);
          responseStream = downloadReportStream;
        }
        if (((_b = request.streamResponseStatusCodes) === null || _b === undefined ? undefined : _b.has(Number.POSITIVE_INFINITY)) || ((_c = request.streamResponseStatusCodes) === null || _c === undefined ? undefined : _c.has(response.status))) {
          response.readableStreamBody = responseStream;
        } else {
          response.bodyAsText = await streamToText(responseStream);
        }
        return response;
      } finally {
        if (request.abortSignal && abortListener) {
          let uploadStreamDone = Promise.resolve();
          if (isReadableStream(body)) {
            uploadStreamDone = isStreamComplete(body);
          }
          let downloadStreamDone = Promise.resolve();
          if (isReadableStream(responseStream)) {
            downloadStreamDone = isStreamComplete(responseStream);
          }
          Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
            var _a2;
            if (abortListener) {
              (_a2 = request.abortSignal) === null || _a2 === undefined || _a2.removeEventListener("abort", abortListener);
            }
          }).catch((e) => {
            log_js_1.logger.warning("Error when cleaning up abortListener on httpRequest", e);
          });
        }
      }
    }
    makeRequest(request, abortController, body) {
      var _a;
      const url = new URL(request.url);
      const isInsecure = url.protocol !== "https:";
      if (isInsecure && !request.allowInsecureConnection) {
        throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
      }
      const agent = (_a = request.agent) !== null && _a !== undefined ? _a : this.getOrCreateAgent(request, isInsecure);
      const options = {
        agent,
        hostname: url.hostname,
        path: `${url.pathname}${url.search}`,
        port: url.port,
        method: request.method,
        headers: request.headers.toJSON({ preserveCase: true })
      };
      return new Promise((resolve, reject) => {
        const req = isInsecure ? http.request(options, resolve) : https.request(options, resolve);
        req.once("error", (err) => {
          var _a2;
          reject(new restError_js_1.RestError(err.message, { code: (_a2 = err.code) !== null && _a2 !== undefined ? _a2 : restError_js_1.RestError.REQUEST_SEND_ERROR, request }));
        });
        abortController.signal.addEventListener("abort", () => {
          const abortError = new abort_controller_1.AbortError("The operation was aborted.");
          req.destroy(abortError);
          reject(abortError);
        });
        if (body && isReadableStream(body)) {
          body.pipe(req);
        } else if (body) {
          if (typeof body === "string" || Buffer.isBuffer(body)) {
            req.end(body);
          } else if (isArrayBuffer(body)) {
            req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
          } else {
            log_js_1.logger.error("Unrecognized body type", body);
            reject(new restError_js_1.RestError("Unrecognized body type"));
          }
        } else {
          req.end();
        }
      });
    }
    getOrCreateAgent(request, isInsecure) {
      var _a;
      const disableKeepAlive = request.disableKeepAlive;
      if (isInsecure) {
        if (disableKeepAlive) {
          return http.globalAgent;
        }
        if (!this.cachedHttpAgent) {
          this.cachedHttpAgent = new http.Agent({ keepAlive: true });
        }
        return this.cachedHttpAgent;
      } else {
        if (disableKeepAlive && !request.tlsSettings) {
          return https.globalAgent;
        }
        const tlsSettings = (_a = request.tlsSettings) !== null && _a !== undefined ? _a : DEFAULT_TLS_SETTINGS;
        let agent = this.cachedHttpsAgents.get(tlsSettings);
        if (agent && agent.options.keepAlive === !disableKeepAlive) {
          return agent;
        }
        log_js_1.logger.info("No cached TLS Agent exist, creating a new Agent");
        agent = new https.Agent(Object.assign({
          keepAlive: !disableKeepAlive
        }, tlsSettings));
        this.cachedHttpsAgents.set(tlsSettings, agent);
        return agent;
      }
    }
  }
  function getResponseHeaders(res) {
    const headers = (0, httpHeaders_js_1.createHttpHeaders)();
    for (const header of Object.keys(res.headers)) {
      const value = res.headers[header];
      if (Array.isArray(value)) {
        if (value.length > 0) {
          headers.set(header, value[0]);
        }
      } else if (value) {
        headers.set(header, value);
      }
    }
    return headers;
  }
  function getDecodedResponseStream(stream, headers) {
    const contentEncoding = headers.get("Content-Encoding");
    if (contentEncoding === "gzip") {
      const unzip = zlib.createGunzip();
      stream.pipe(unzip);
      return unzip;
    } else if (contentEncoding === "deflate") {
      const inflate = zlib.createInflate();
      stream.pipe(inflate);
      return inflate;
    }
    return stream;
  }
  function streamToText(stream) {
    return new Promise((resolve, reject) => {
      const buffer = [];
      stream.on("data", (chunk) => {
        if (Buffer.isBuffer(chunk)) {
          buffer.push(chunk);
        } else {
          buffer.push(Buffer.from(chunk));
        }
      });
      stream.on("end", () => {
        resolve(Buffer.concat(buffer).toString("utf8"));
      });
      stream.on("error", (e) => {
        if (e && (e === null || e === undefined ? undefined : e.name) === "AbortError") {
          reject(e);
        } else {
          reject(new restError_js_1.RestError(`Error reading response as text: ${e.message}`, {
            code: restError_js_1.RestError.PARSE_ERROR
          }));
        }
      });
    });
  }
  function getBodyLength(body) {
    if (!body) {
      return 0;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (isReadableStream(body)) {
      return null;
    } else if (isArrayBuffer(body)) {
      return body.byteLength;
    } else if (typeof body === "string") {
      return Buffer.from(body).length;
    } else {
      return null;
    }
  }
  function createNodeHttpClient() {
    return new NodeHttpClient;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultHttpClient = createDefaultHttpClient;
  var nodeHttpClient_js_1 = require_nodeHttpClient();
  function createDefaultHttpClient() {
    return (0, nodeHttpClient_js_1.createNodeHttpClient)();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipelineRequest.js
var require_pipelineRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineRequest = createPipelineRequest;
  var httpHeaders_js_1 = require_httpHeaders();
  var core_util_1 = require_commonjs3();

  class PipelineRequestImpl {
    constructor(options) {
      var _a, _b, _c, _d, _e, _f, _g;
      this.url = options.url;
      this.body = options.body;
      this.headers = (_a = options.headers) !== null && _a !== undefined ? _a : (0, httpHeaders_js_1.createHttpHeaders)();
      this.method = (_b = options.method) !== null && _b !== undefined ? _b : "GET";
      this.timeout = (_c = options.timeout) !== null && _c !== undefined ? _c : 0;
      this.multipartBody = options.multipartBody;
      this.formData = options.formData;
      this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== undefined ? _d : false;
      this.proxySettings = options.proxySettings;
      this.streamResponseStatusCodes = options.streamResponseStatusCodes;
      this.withCredentials = (_e = options.withCredentials) !== null && _e !== undefined ? _e : false;
      this.abortSignal = options.abortSignal;
      this.tracingOptions = options.tracingOptions;
      this.onUploadProgress = options.onUploadProgress;
      this.onDownloadProgress = options.onDownloadProgress;
      this.requestId = options.requestId || (0, core_util_1.randomUUID)();
      this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== undefined ? _f : false;
      this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== undefined ? _g : false;
    }
  }
  function createPipelineRequest(options) {
    return new PipelineRequestImpl(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exponentialRetryPolicyName = undefined;
  exports.exponentialRetryPolicy = exponentialRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants2();
  exports.exponentialRetryPolicyName = "exponentialRetryPolicy";
  function exponentialRetryPolicy(options = {}) {
    var _a;
    return (0, retryPolicy_js_1.retryPolicy)([
      (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(Object.assign(Object.assign({}, options), { ignoreSystemErrors: true }))
    ], {
      maxRetries: (_a = options.maxRetries) !== null && _a !== undefined ? _a : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
    });
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.systemErrorRetryPolicyName = undefined;
  exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants2();
  exports.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
  function systemErrorRetryPolicy(options = {}) {
    var _a;
    return {
      name: exports.systemErrorRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([
        (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(Object.assign(Object.assign({}, options), { ignoreHttpStatusCodes: true }))
      ], {
        maxRetries: (_a = options.maxRetries) !== null && _a !== undefined ? _a : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttlingRetryPolicyName = undefined;
  exports.throttlingRetryPolicy = throttlingRetryPolicy;
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants2();
  exports.throttlingRetryPolicyName = "throttlingRetryPolicy";
  function throttlingRetryPolicy(options = {}) {
    var _a;
    return {
      name: exports.throttlingRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)()], {
        maxRetries: (_a = options.maxRetries) !== null && _a !== undefined ? _a : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/tokenCycler.js
var require_tokenCycler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_CYCLER_OPTIONS = undefined;
  exports.createTokenCycler = createTokenCycler;
  var helpers_js_1 = require_helpers();
  exports.DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 1000 * 60 * 2
  };
  async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
    async function tryGetAccessToken() {
      if (Date.now() < refreshTimeout) {
        try {
          return await getAccessToken();
        } catch (_a) {
          return null;
        }
      } else {
        const finalToken = await getAccessToken();
        if (finalToken === null) {
          throw new Error("Failed to refresh access token.");
        }
        return finalToken;
      }
    }
    let token = await tryGetAccessToken();
    while (token === null) {
      await (0, helpers_js_1.delay)(retryIntervalInMs);
      token = await tryGetAccessToken();
    }
    return token;
  }
  function createTokenCycler(credential, tokenCyclerOptions) {
    let refreshWorker = null;
    let token = null;
    let tenantId;
    const options = Object.assign(Object.assign({}, exports.DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
    const cycler = {
      get isRefreshing() {
        return refreshWorker !== null;
      },
      get shouldRefresh() {
        var _a;
        if (cycler.isRefreshing) {
          return false;
        }
        if ((token === null || token === undefined ? undefined : token.refreshAfterTimestamp) && token.refreshAfterTimestamp < Date.now()) {
          return true;
        }
        return ((_a = token === null || token === undefined ? undefined : token.expiresOnTimestamp) !== null && _a !== undefined ? _a : 0) - options.refreshWindowInMs < Date.now();
      },
      get mustRefresh() {
        return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
      }
    };
    function refresh(scopes, getTokenOptions) {
      var _a;
      if (!cycler.isRefreshing) {
        const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
        refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, (_a = token === null || token === undefined ? undefined : token.expiresOnTimestamp) !== null && _a !== undefined ? _a : Date.now()).then((_token) => {
          refreshWorker = null;
          token = _token;
          tenantId = getTokenOptions.tenantId;
          return token;
        }).catch((reason) => {
          refreshWorker = null;
          token = null;
          tenantId = undefined;
          throw reason;
        });
      }
      return refreshWorker;
    }
    return async (scopes, tokenOptions) => {
      const hasClaimChallenge = Boolean(tokenOptions.claims);
      const tenantIdChanged = tenantId !== tokenOptions.tenantId;
      if (hasClaimChallenge) {
        token = null;
      }
      const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
      if (mustRefresh) {
        return refresh(scopes, tokenOptions);
      }
      if (cycler.shouldRefresh) {
        refresh(scopes, tokenOptions);
      }
      return token;
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/bearerTokenAuthenticationPolicy.js
var require_bearerTokenAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bearerTokenAuthenticationPolicyName = undefined;
  exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
  exports.parseChallenges = parseChallenges;
  var tokenCycler_js_1 = require_tokenCycler();
  var log_js_1 = require_log2();
  var restError_js_1 = require_restError();
  exports.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  async function trySendRequest(request, next) {
    try {
      return [await next(request), undefined];
    } catch (e) {
      if ((0, restError_js_1.isRestError)(e) && e.response) {
        return [e.response, e];
      } else {
        throw e;
      }
    }
  }
  async function defaultAuthorizeRequest(options) {
    const { scopes, getAccessToken, request } = options;
    const getTokenOptions = {
      abortSignal: request.abortSignal,
      tracingOptions: request.tracingOptions,
      enableCae: true
    };
    const accessToken = await getAccessToken(scopes, getTokenOptions);
    if (accessToken) {
      options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
    }
  }
  function isChallengeResponse(response) {
    return response.status === 401 && response.headers.has("WWW-Authenticate");
  }
  async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
    var _a;
    const { scopes } = onChallengeOptions;
    const accessToken = await onChallengeOptions.getAccessToken(scopes, {
      enableCae: true,
      claims: caeClaims
    });
    if (!accessToken) {
      return false;
    }
    onChallengeOptions.request.headers.set("Authorization", `${(_a = accessToken.tokenType) !== null && _a !== undefined ? _a : "Bearer"} ${accessToken.token}`);
    return true;
  }
  function bearerTokenAuthenticationPolicy(options) {
    var _a, _b, _c;
    const { credential, scopes, challengeCallbacks } = options;
    const logger = options.logger || log_js_1.logger;
    const callbacks = {
      authorizeRequest: (_b = (_a = challengeCallbacks === null || challengeCallbacks === undefined ? undefined : challengeCallbacks.authorizeRequest) === null || _a === undefined ? undefined : _a.bind(challengeCallbacks)) !== null && _b !== undefined ? _b : defaultAuthorizeRequest,
      authorizeRequestOnChallenge: (_c = challengeCallbacks === null || challengeCallbacks === undefined ? undefined : challengeCallbacks.authorizeRequestOnChallenge) === null || _c === undefined ? undefined : _c.bind(challengeCallbacks)
    };
    const getAccessToken = credential ? (0, tokenCycler_js_1.createTokenCycler)(credential) : () => Promise.resolve(null);
    return {
      name: exports.bearerTokenAuthenticationPolicyName,
      async sendRequest(request, next) {
        if (!request.url.toLowerCase().startsWith("https://")) {
          throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
        }
        await callbacks.authorizeRequest({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request,
          getAccessToken,
          logger
        });
        let response;
        let error;
        let shouldSendRequest;
        [response, error] = await trySendRequest(request, next);
        if (isChallengeResponse(response)) {
          let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
          if (claims) {
            let parsedClaim;
            try {
              parsedClaim = atob(claims);
            } catch (e) {
              logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
              return response;
            }
            shouldSendRequest = await authorizeRequestOnCaeChallenge({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              response,
              request,
              getAccessToken,
              logger
            }, parsedClaim);
            if (shouldSendRequest) {
              [response, error] = await trySendRequest(request, next);
            }
          } else if (callbacks.authorizeRequestOnChallenge) {
            shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              request,
              response,
              getAccessToken,
              logger
            });
            if (shouldSendRequest) {
              [response, error] = await trySendRequest(request, next);
            }
            if (isChallengeResponse(response)) {
              claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
              if (claims) {
                let parsedClaim;
                try {
                  parsedClaim = atob(claims);
                } catch (e) {
                  logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                  return response;
                }
                shouldSendRequest = await authorizeRequestOnCaeChallenge({
                  scopes: Array.isArray(scopes) ? scopes : [scopes],
                  response,
                  request,
                  getAccessToken,
                  logger
                }, parsedClaim);
                if (shouldSendRequest) {
                  [response, error] = await trySendRequest(request, next);
                }
              }
            }
          }
        }
        if (error) {
          throw error;
        } else {
          return response;
        }
      }
    };
  }
  function parseChallenges(challenges) {
    const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
    const paramRegex = /(\w+)="([^"]*)"/g;
    const parsedChallenges = [];
    let match;
    while ((match = challengeRegex.exec(challenges)) !== null) {
      const scheme = match[1];
      const paramsString = match[2];
      const params = {};
      let paramMatch;
      while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
        params[paramMatch[1]] = paramMatch[2];
      }
      parsedChallenges.push({ scheme, params });
    }
    return parsedChallenges;
  }
  function getCaeChallengeClaims(challenges) {
    var _a;
    if (!challenges) {
      return;
    }
    const parsedChallenges = parseChallenges(challenges);
    return (_a = parsedChallenges.find((x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims")) === null || _a === undefined ? undefined : _a.params.claims;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/ndJsonPolicy.js
var require_ndJsonPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ndJsonPolicyName = undefined;
  exports.ndJsonPolicy = ndJsonPolicy;
  exports.ndJsonPolicyName = "ndJsonPolicy";
  function ndJsonPolicy() {
    return {
      name: exports.ndJsonPolicyName,
      async sendRequest(request, next) {
        if (typeof request.body === "string" && request.body.startsWith("[")) {
          const body = JSON.parse(request.body);
          if (Array.isArray(body)) {
            request.body = body.map((item) => JSON.stringify(item) + `
`).join("");
          }
        }
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/auxiliaryAuthenticationHeaderPolicy.js
var require_auxiliaryAuthenticationHeaderPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auxiliaryAuthenticationHeaderPolicyName = undefined;
  exports.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
  var tokenCycler_js_1 = require_tokenCycler();
  var log_js_1 = require_log2();
  exports.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
  var AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
  async function sendAuthorizeRequest(options) {
    var _a, _b;
    const { scopes, getAccessToken, request } = options;
    const getTokenOptions = {
      abortSignal: request.abortSignal,
      tracingOptions: request.tracingOptions
    };
    return (_b = (_a = await getAccessToken(scopes, getTokenOptions)) === null || _a === undefined ? undefined : _a.token) !== null && _b !== undefined ? _b : "";
  }
  function auxiliaryAuthenticationHeaderPolicy(options) {
    const { credentials, scopes } = options;
    const logger = options.logger || log_js_1.logger;
    const tokenCyclerMap = new WeakMap;
    return {
      name: exports.auxiliaryAuthenticationHeaderPolicyName,
      async sendRequest(request, next) {
        if (!request.url.toLowerCase().startsWith("https://")) {
          throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
        }
        if (!credentials || credentials.length === 0) {
          logger.info(`${exports.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);
          return next(request);
        }
        const tokenPromises = [];
        for (const credential of credentials) {
          let getAccessToken = tokenCyclerMap.get(credential);
          if (!getAccessToken) {
            getAccessToken = (0, tokenCycler_js_1.createTokenCycler)(credential);
            tokenCyclerMap.set(credential, getAccessToken);
          }
          tokenPromises.push(sendAuthorizeRequest({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request,
            getAccessToken,
            logger
          }));
        }
        const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
        if (auxiliaryTokens.length === 0) {
          logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);
          return next(request);
        }
        request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "));
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/index.js
var require_commonjs6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFileFromStream = exports.createFile = exports.auxiliaryAuthenticationHeaderPolicyName = exports.auxiliaryAuthenticationHeaderPolicy = exports.ndJsonPolicyName = exports.ndJsonPolicy = exports.bearerTokenAuthenticationPolicyName = exports.bearerTokenAuthenticationPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.userAgentPolicyName = exports.userAgentPolicy = exports.defaultRetryPolicy = exports.tracingPolicyName = exports.tracingPolicy = exports.retryPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.setClientRequestIdPolicyName = exports.setClientRequestIdPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.isRestError = exports.RestError = exports.createPipelineRequest = exports.createHttpHeaders = exports.createDefaultHttpClient = exports.createPipelineFromOptions = exports.createEmptyPipeline = undefined;
  var pipeline_js_1 = require_pipeline();
  Object.defineProperty(exports, "createEmptyPipeline", { enumerable: true, get: function() {
    return pipeline_js_1.createEmptyPipeline;
  } });
  var createPipelineFromOptions_js_1 = require_createPipelineFromOptions();
  Object.defineProperty(exports, "createPipelineFromOptions", { enumerable: true, get: function() {
    return createPipelineFromOptions_js_1.createPipelineFromOptions;
  } });
  var defaultHttpClient_js_1 = require_defaultHttpClient();
  Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: true, get: function() {
    return defaultHttpClient_js_1.createDefaultHttpClient;
  } });
  var httpHeaders_js_1 = require_httpHeaders();
  Object.defineProperty(exports, "createHttpHeaders", { enumerable: true, get: function() {
    return httpHeaders_js_1.createHttpHeaders;
  } });
  var pipelineRequest_js_1 = require_pipelineRequest();
  Object.defineProperty(exports, "createPipelineRequest", { enumerable: true, get: function() {
    return pipelineRequest_js_1.createPipelineRequest;
  } });
  var restError_js_1 = require_restError();
  Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
    return restError_js_1.RestError;
  } });
  Object.defineProperty(exports, "isRestError", { enumerable: true, get: function() {
    return restError_js_1.isRestError;
  } });
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
  Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicy;
  } });
  Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicyName;
  } });
  var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy();
  Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
  } });
  Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
  } });
  var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
  Object.defineProperty(exports, "setClientRequestIdPolicy", { enumerable: true, get: function() {
    return setClientRequestIdPolicy_js_1.setClientRequestIdPolicy;
  } });
  Object.defineProperty(exports, "setClientRequestIdPolicyName", { enumerable: true, get: function() {
    return setClientRequestIdPolicy_js_1.setClientRequestIdPolicyName;
  } });
  var logPolicy_js_1 = require_logPolicy();
  Object.defineProperty(exports, "logPolicy", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicy;
  } });
  Object.defineProperty(exports, "logPolicyName", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicyName;
  } });
  var multipartPolicy_js_1 = require_multipartPolicy();
  Object.defineProperty(exports, "multipartPolicy", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicy;
  } });
  Object.defineProperty(exports, "multipartPolicyName", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicyName;
  } });
  var proxyPolicy_js_1 = require_proxyPolicy();
  Object.defineProperty(exports, "proxyPolicy", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicy;
  } });
  Object.defineProperty(exports, "proxyPolicyName", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicyName;
  } });
  Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: true, get: function() {
    return proxyPolicy_js_1.getDefaultProxySettings;
  } });
  var redirectPolicy_js_1 = require_redirectPolicy();
  Object.defineProperty(exports, "redirectPolicy", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicy;
  } });
  Object.defineProperty(exports, "redirectPolicyName", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicyName;
  } });
  var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy();
  Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
  } });
  Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
  } });
  var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy();
  Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
  } });
  Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
  } });
  var retryPolicy_js_1 = require_retryPolicy();
  Object.defineProperty(exports, "retryPolicy", { enumerable: true, get: function() {
    return retryPolicy_js_1.retryPolicy;
  } });
  var tracingPolicy_js_1 = require_tracingPolicy();
  Object.defineProperty(exports, "tracingPolicy", { enumerable: true, get: function() {
    return tracingPolicy_js_1.tracingPolicy;
  } });
  Object.defineProperty(exports, "tracingPolicyName", { enumerable: true, get: function() {
    return tracingPolicy_js_1.tracingPolicyName;
  } });
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
  Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: true, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicy;
  } });
  var userAgentPolicy_js_1 = require_userAgentPolicy();
  Object.defineProperty(exports, "userAgentPolicy", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicy;
  } });
  Object.defineProperty(exports, "userAgentPolicyName", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicyName;
  } });
  var tlsPolicy_js_1 = require_tlsPolicy();
  Object.defineProperty(exports, "tlsPolicy", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicy;
  } });
  Object.defineProperty(exports, "tlsPolicyName", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicyName;
  } });
  var formDataPolicy_js_1 = require_formDataPolicy();
  Object.defineProperty(exports, "formDataPolicy", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicy;
  } });
  Object.defineProperty(exports, "formDataPolicyName", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicyName;
  } });
  var bearerTokenAuthenticationPolicy_js_1 = require_bearerTokenAuthenticationPolicy();
  Object.defineProperty(exports, "bearerTokenAuthenticationPolicy", { enumerable: true, get: function() {
    return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicy;
  } });
  Object.defineProperty(exports, "bearerTokenAuthenticationPolicyName", { enumerable: true, get: function() {
    return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicyName;
  } });
  var ndJsonPolicy_js_1 = require_ndJsonPolicy();
  Object.defineProperty(exports, "ndJsonPolicy", { enumerable: true, get: function() {
    return ndJsonPolicy_js_1.ndJsonPolicy;
  } });
  Object.defineProperty(exports, "ndJsonPolicyName", { enumerable: true, get: function() {
    return ndJsonPolicy_js_1.ndJsonPolicyName;
  } });
  var auxiliaryAuthenticationHeaderPolicy_js_1 = require_auxiliaryAuthenticationHeaderPolicy();
  Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicy", { enumerable: true, get: function() {
    return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicy;
  } });
  Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicyName", { enumerable: true, get: function() {
    return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicyName;
  } });
  var file_js_1 = require_file();
  Object.defineProperty(exports, "createFile", { enumerable: true, get: function() {
    return file_js_1.createFile;
  } });
  Object.defineProperty(exports, "createFileFromStream", { enumerable: true, get: function() {
    return file_js_1.createFileFromStream;
  } });
});

// node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js
var require_azureKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureKeyCredential = undefined;

  class AzureKeyCredential {
    get key() {
      return this._key;
    }
    constructor(key) {
      if (!key) {
        throw new Error("key must be a non-empty string");
      }
      this._key = key;
    }
    update(newKey) {
      this._key = newKey;
    }
  }
  exports.AzureKeyCredential = AzureKeyCredential;
});

// node_modules/@azure/core-auth/dist/commonjs/keyCredential.js
var require_keyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isKeyCredential = isKeyCredential;
  var core_util_1 = require_commonjs3();
  function isKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js
var require_azureNamedKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureNamedKeyCredential = undefined;
  exports.isNamedKeyCredential = isNamedKeyCredential;
  var core_util_1 = require_commonjs3();

  class AzureNamedKeyCredential {
    get key() {
      return this._key;
    }
    get name() {
      return this._name;
    }
    constructor(name, key) {
      if (!name || !key) {
        throw new TypeError("name and key must be non-empty strings");
      }
      this._name = name;
      this._key = key;
    }
    update(newName, newKey) {
      if (!newName || !newKey) {
        throw new TypeError("newName and newKey must be non-empty strings");
      }
      this._name = newName;
      this._key = newKey;
    }
  }
  exports.AzureNamedKeyCredential = AzureNamedKeyCredential;
  function isNamedKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js
var require_azureSASCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureSASCredential = undefined;
  exports.isSASCredential = isSASCredential;
  var core_util_1 = require_commonjs3();

  class AzureSASCredential {
    get signature() {
      return this._signature;
    }
    constructor(signature) {
      if (!signature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = signature;
    }
    update(newSignature) {
      if (!newSignature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = newSignature;
    }
  }
  exports.AzureSASCredential = AzureSASCredential;
  function isSASCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js
var require_tokenCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isBearerToken = isBearerToken;
  exports.isPopToken = isPopToken;
  exports.isTokenCredential = isTokenCredential;
  function isBearerToken(accessToken) {
    return !accessToken.tokenType || accessToken.tokenType === "Bearer";
  }
  function isPopToken(accessToken) {
    return accessToken.tokenType === "pop";
  }
  function isTokenCredential(credential) {
    const castCredential = credential;
    return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === undefined || castCredential.getToken.length > 0);
  }
});

// node_modules/@azure/core-auth/dist/commonjs/index.js
var require_commonjs7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTokenCredential = exports.isSASCredential = exports.AzureSASCredential = exports.isNamedKeyCredential = exports.AzureNamedKeyCredential = exports.isKeyCredential = exports.AzureKeyCredential = undefined;
  var azureKeyCredential_js_1 = require_azureKeyCredential();
  Object.defineProperty(exports, "AzureKeyCredential", { enumerable: true, get: function() {
    return azureKeyCredential_js_1.AzureKeyCredential;
  } });
  var keyCredential_js_1 = require_keyCredential();
  Object.defineProperty(exports, "isKeyCredential", { enumerable: true, get: function() {
    return keyCredential_js_1.isKeyCredential;
  } });
  var azureNamedKeyCredential_js_1 = require_azureNamedKeyCredential();
  Object.defineProperty(exports, "AzureNamedKeyCredential", { enumerable: true, get: function() {
    return azureNamedKeyCredential_js_1.AzureNamedKeyCredential;
  } });
  Object.defineProperty(exports, "isNamedKeyCredential", { enumerable: true, get: function() {
    return azureNamedKeyCredential_js_1.isNamedKeyCredential;
  } });
  var azureSASCredential_js_1 = require_azureSASCredential();
  Object.defineProperty(exports, "AzureSASCredential", { enumerable: true, get: function() {
    return azureSASCredential_js_1.AzureSASCredential;
  } });
  Object.defineProperty(exports, "isSASCredential", { enumerable: true, get: function() {
    return azureSASCredential_js_1.isSASCredential;
  } });
  var tokenCredential_js_1 = require_tokenCredential();
  Object.defineProperty(exports, "isTokenCredential", { enumerable: true, get: function() {
    return tokenCredential_js_1.isTokenCredential;
  } });
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/disableKeepAlivePolicy.js
var require_disableKeepAlivePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pipelineContainsDisableKeepAlivePolicy = exports.createDisableKeepAlivePolicy = exports.disableKeepAlivePolicyName = undefined;
  exports.disableKeepAlivePolicyName = "DisableKeepAlivePolicy";
  function createDisableKeepAlivePolicy() {
    return {
      name: exports.disableKeepAlivePolicyName,
      async sendRequest(request, next) {
        request.disableKeepAlive = true;
        return next(request);
      }
    };
  }
  exports.createDisableKeepAlivePolicy = createDisableKeepAlivePolicy;
  function pipelineContainsDisableKeepAlivePolicy(pipeline) {
    return pipeline.getOrderedPolicies().some((policy) => policy.name === exports.disableKeepAlivePolicyName);
  }
  exports.pipelineContainsDisableKeepAlivePolicy = pipelineContainsDisableKeepAlivePolicy;
});

// node_modules/@azure/core-client/dist/commonjs/base64.js
var require_base64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeStringToString = exports.decodeString = exports.encodeByteArray = exports.encodeString = undefined;
  function encodeString(value) {
    return Buffer.from(value).toString("base64");
  }
  exports.encodeString = encodeString;
  function encodeByteArray(value) {
    const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
    return bufferValue.toString("base64");
  }
  exports.encodeByteArray = encodeByteArray;
  function decodeString(value) {
    return Buffer.from(value, "base64");
  }
  exports.decodeString = decodeString;
  function decodeStringToString(value) {
    return Buffer.from(value, "base64").toString();
  }
  exports.decodeStringToString = decodeStringToString;
});

// node_modules/@azure/core-client/dist/commonjs/interfaces.js
var require_interfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = undefined;
  exports.XML_ATTRKEY = "$";
  exports.XML_CHARKEY = "_";
});

// node_modules/@azure/core-client/dist/commonjs/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flattenResponse = exports.isValidUuid = exports.isDuration = exports.isPrimitiveBody = undefined;
  function isPrimitiveBody(value, mapperTypeName) {
    return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === undefined ? undefined : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === undefined || value === null);
  }
  exports.isPrimitiveBody = isPrimitiveBody;
  var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function isDuration(value) {
    return validateISODuration.test(value);
  }
  exports.isDuration = isDuration;
  var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
  function isValidUuid(uuid) {
    return validUuidRegex.test(uuid);
  }
  exports.isValidUuid = isValidUuid;
  function handleNullableResponseAndWrappableBody(responseObject) {
    const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
    if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
      return responseObject.shouldWrapBody ? { body: null } : null;
    } else {
      return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
    }
  }
  function flattenResponse(fullResponse, responseSpec) {
    var _a, _b;
    const parsedHeaders = fullResponse.parsedHeaders;
    if (fullResponse.request.method === "HEAD") {
      return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
    }
    const bodyMapper = responseSpec && responseSpec.bodyMapper;
    const isNullable = Boolean(bodyMapper === null || bodyMapper === undefined ? undefined : bodyMapper.nullable);
    const expectedBodyTypeName = bodyMapper === null || bodyMapper === undefined ? undefined : bodyMapper.type.name;
    if (expectedBodyTypeName === "Stream") {
      return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
    }
    const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
    if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
      const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== undefined ? _a : [];
      for (const key of Object.keys(modelProperties)) {
        if (modelProperties[key].serializedName) {
          arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === undefined ? undefined : _b[key];
        }
      }
      if (parsedHeaders) {
        for (const key of Object.keys(parsedHeaders)) {
          arrayResponse[key] = parsedHeaders[key];
        }
      }
      return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
    }
    return handleNullableResponseAndWrappableBody({
      body: fullResponse.parsedBody,
      headers: parsedHeaders,
      hasNullableType: isNullable,
      shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
    });
  }
  exports.flattenResponse = flattenResponse;
});

// node_modules/@azure/core-client/dist/commonjs/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MapperTypeNames = exports.createSerializer = undefined;
  var tslib_1 = require_tslib();
  var base64 = tslib_1.__importStar(require_base64());
  var interfaces_js_1 = require_interfaces();
  var utils_js_1 = require_utils();

  class SerializerImpl {
    constructor(modelMappers = {}, isXML = false) {
      this.modelMappers = modelMappers;
      this.isXML = isXML;
    }
    validateConstraints(mapper, value, objectName) {
      const failValidation = (constraintName, constraintValue) => {
        throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
      };
      if (mapper.constraints && value !== undefined && value !== null) {
        const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
        if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {
          failValidation("ExclusiveMaximum", ExclusiveMaximum);
        }
        if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {
          failValidation("ExclusiveMinimum", ExclusiveMinimum);
        }
        if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {
          failValidation("InclusiveMaximum", InclusiveMaximum);
        }
        if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {
          failValidation("InclusiveMinimum", InclusiveMinimum);
        }
        if (MaxItems !== undefined && value.length > MaxItems) {
          failValidation("MaxItems", MaxItems);
        }
        if (MaxLength !== undefined && value.length > MaxLength) {
          failValidation("MaxLength", MaxLength);
        }
        if (MinItems !== undefined && value.length < MinItems) {
          failValidation("MinItems", MinItems);
        }
        if (MinLength !== undefined && value.length < MinLength) {
          failValidation("MinLength", MinLength);
        }
        if (MultipleOf !== undefined && value % MultipleOf !== 0) {
          failValidation("MultipleOf", MultipleOf);
        }
        if (Pattern) {
          const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
          if (typeof value !== "string" || value.match(pattern) === null) {
            failValidation("Pattern", Pattern);
          }
        }
        if (UniqueItems && value.some((item, i, ar) => ar.indexOf(item) !== i)) {
          failValidation("UniqueItems", UniqueItems);
        }
      }
    }
    serialize(mapper, object, objectName, options = { xml: {} }) {
      var _a, _b, _c;
      const updatedOptions = {
        xml: {
          rootName: (_a = options.xml.rootName) !== null && _a !== undefined ? _a : "",
          includeRoot: (_b = options.xml.includeRoot) !== null && _b !== undefined ? _b : false,
          xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== undefined ? _c : interfaces_js_1.XML_CHARKEY
        }
      };
      let payload = {};
      const mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Sequence$/i) !== null) {
        payload = [];
      }
      if (mapper.isConstant) {
        object = mapper.defaultValue;
      }
      const { required, nullable } = mapper;
      if (required && nullable && object === undefined) {
        throw new Error(`${objectName} cannot be undefined.`);
      }
      if (required && !nullable && (object === undefined || object === null)) {
        throw new Error(`${objectName} cannot be null or undefined.`);
      }
      if (!required && nullable === false && object === null) {
        throw new Error(`${objectName} cannot be null.`);
      }
      if (object === undefined || object === null) {
        payload = object;
      } else {
        if (mapperType.match(/^any$/i) !== null) {
          payload = object;
        } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
          payload = serializeBasicTypes(mapperType, objectName, object);
        } else if (mapperType.match(/^Enum$/i) !== null) {
          const enumMapper = mapper;
          payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
        } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
          payload = serializeDateTypes(mapperType, object, objectName);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = serializeByteArrayType(objectName, object);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = serializeBase64UrlType(objectName, object);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Composite$/i) !== null) {
          payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        }
      }
      return payload;
    }
    deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
      var _a, _b, _c, _d;
      const updatedOptions = {
        xml: {
          rootName: (_a = options.xml.rootName) !== null && _a !== undefined ? _a : "",
          includeRoot: (_b = options.xml.includeRoot) !== null && _b !== undefined ? _b : false,
          xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== undefined ? _c : interfaces_js_1.XML_CHARKEY
        },
        ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== undefined ? _d : false
      };
      if (responseBody === undefined || responseBody === null) {
        if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
          responseBody = [];
        }
        if (mapper.defaultValue !== undefined) {
          responseBody = mapper.defaultValue;
        }
        return responseBody;
      }
      let payload;
      const mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Composite$/i) !== null) {
        payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
      } else {
        if (this.isXML) {
          const xmlCharKey = updatedOptions.xml.xmlCharKey;
          if (responseBody[interfaces_js_1.XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {
            responseBody = responseBody[xmlCharKey];
          }
        }
        if (mapperType.match(/^Number$/i) !== null) {
          payload = parseFloat(responseBody);
          if (isNaN(payload)) {
            payload = responseBody;
          }
        } else if (mapperType.match(/^Boolean$/i) !== null) {
          if (responseBody === "true") {
            payload = true;
          } else if (responseBody === "false") {
            payload = false;
          } else {
            payload = responseBody;
          }
        } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
          payload = responseBody;
        } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
          payload = new Date(responseBody);
        } else if (mapperType.match(/^UnixTime$/i) !== null) {
          payload = unixTimeToDate(responseBody);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = base64.decodeString(responseBody);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = base64UrlToByteArray(responseBody);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
        }
      }
      if (mapper.isConstant) {
        payload = mapper.defaultValue;
      }
      return payload;
    }
  }
  function createSerializer(modelMappers = {}, isXML = false) {
    return new SerializerImpl(modelMappers, isXML);
  }
  exports.createSerializer = createSerializer;
  function trimEnd(str, ch) {
    let len = str.length;
    while (len - 1 >= 0 && str[len - 1] === ch) {
      --len;
    }
    return str.substr(0, len);
  }
  function bufferToBase64Url(buffer) {
    if (!buffer) {
      return;
    }
    if (!(buffer instanceof Uint8Array)) {
      throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
    }
    const str = base64.encodeByteArray(buffer);
    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function base64UrlToByteArray(str) {
    if (!str) {
      return;
    }
    if (str && typeof str.valueOf() !== "string") {
      throw new Error("Please provide an input of type string for converting to Uint8Array");
    }
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    return base64.decodeString(str);
  }
  function splitSerializeName(prop) {
    const classes = [];
    let partialclass = "";
    if (prop) {
      const subwords = prop.split(".");
      for (const item of subwords) {
        if (item.charAt(item.length - 1) === "\\") {
          partialclass += item.substr(0, item.length - 1) + ".";
        } else {
          partialclass += item;
          classes.push(partialclass);
          partialclass = "";
        }
      }
    }
    return classes;
  }
  function dateToUnixTime(d) {
    if (!d) {
      return;
    }
    if (typeof d.valueOf() === "string") {
      d = new Date(d);
    }
    return Math.floor(d.getTime() / 1000);
  }
  function unixTimeToDate(n) {
    if (!n) {
      return;
    }
    return new Date(n * 1000);
  }
  function serializeBasicTypes(typeName, objectName, value) {
    if (value !== null && value !== undefined) {
      if (typeName.match(/^Number$/i) !== null) {
        if (typeof value !== "number") {
          throw new Error(`${objectName} with value ${value} must be of type number.`);
        }
      } else if (typeName.match(/^String$/i) !== null) {
        if (typeof value.valueOf() !== "string") {
          throw new Error(`${objectName} with value "${value}" must be of type string.`);
        }
      } else if (typeName.match(/^Uuid$/i) !== null) {
        if (!(typeof value.valueOf() === "string" && (0, utils_js_1.isValidUuid)(value))) {
          throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
        }
      } else if (typeName.match(/^Boolean$/i) !== null) {
        if (typeof value !== "boolean") {
          throw new Error(`${objectName} with value ${value} must be of type boolean.`);
        }
      } else if (typeName.match(/^Stream$/i) !== null) {
        const objectType = typeof value;
        if (objectType !== "string" && typeof value.pipe !== "function" && typeof value.tee !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") {
          throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
        }
      }
    }
    return value;
  }
  function serializeEnumType(objectName, allowedValues, value) {
    if (!allowedValues) {
      throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
    }
    const isPresent = allowedValues.some((item) => {
      if (typeof item.valueOf() === "string") {
        return item.toLowerCase() === value.toLowerCase();
      }
      return item === value;
    });
    if (!isPresent) {
      throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
    }
    return value;
  }
  function serializeByteArrayType(objectName, value) {
    if (value !== undefined && value !== null) {
      if (!(value instanceof Uint8Array)) {
        throw new Error(`${objectName} must be of type Uint8Array.`);
      }
      value = base64.encodeByteArray(value);
    }
    return value;
  }
  function serializeBase64UrlType(objectName, value) {
    if (value !== undefined && value !== null) {
      if (!(value instanceof Uint8Array)) {
        throw new Error(`${objectName} must be of type Uint8Array.`);
      }
      value = bufferToBase64Url(value);
    }
    return value;
  }
  function serializeDateTypes(typeName, value, objectName) {
    if (value !== undefined && value !== null) {
      if (typeName.match(/^Date$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        }
        value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
      } else if (typeName.match(/^DateTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        }
        value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
      } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
        }
        value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
      } else if (typeName.match(/^UnixTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` + `for it to be serialized in UnixTime/Epoch format.`);
        }
        value = dateToUnixTime(value);
      } else if (typeName.match(/^TimeSpan$/i) !== null) {
        if (!(0, utils_js_1.isDuration)(value)) {
          throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
        }
      }
    }
    return value;
  }
  function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
    var _a;
    if (!Array.isArray(object)) {
      throw new Error(`${objectName} must be of type Array.`);
    }
    let elementType = mapper.type.element;
    if (!elementType || typeof elementType !== "object") {
      throw new Error(`element" metadata for an Array must be defined in the ` + `mapper and it must of type "object" in ${objectName}.`);
    }
    if (elementType.type.name === "Composite" && elementType.type.className) {
      elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== undefined ? _a : elementType;
    }
    const tempArray = [];
    for (let i = 0;i < object.length; i++) {
      const serializedValue = serializer.serialize(elementType, object[i], objectName, options);
      if (isXml && elementType.xmlNamespace) {
        const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
        if (elementType.type.name === "Composite") {
          tempArray[i] = Object.assign({}, serializedValue);
          tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        } else {
          tempArray[i] = {};
          tempArray[i][options.xml.xmlCharKey] = serializedValue;
          tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        }
      } else {
        tempArray[i] = serializedValue;
      }
    }
    return tempArray;
  }
  function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
    if (typeof object !== "object") {
      throw new Error(`${objectName} must be of type object.`);
    }
    const valueType = mapper.type.value;
    if (!valueType || typeof valueType !== "object") {
      throw new Error(`"value" metadata for a Dictionary must be defined in the ` + `mapper and it must of type "object" in ${objectName}.`);
    }
    const tempDictionary = {};
    for (const key of Object.keys(object)) {
      const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
      tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
    }
    if (isXml && mapper.xmlNamespace) {
      const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
      const result = tempDictionary;
      result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
      return result;
    }
    return tempDictionary;
  }
  function resolveAdditionalProperties(serializer, mapper, objectName) {
    const additionalProperties = mapper.type.additionalProperties;
    if (!additionalProperties && mapper.type.className) {
      const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
      return modelMapper === null || modelMapper === undefined ? undefined : modelMapper.type.additionalProperties;
    }
    return additionalProperties;
  }
  function resolveReferencedMapper(serializer, mapper, objectName) {
    const className = mapper.type.className;
    if (!className) {
      throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, undefined, 2)}".`);
    }
    return serializer.modelMappers[className];
  }
  function resolveModelProperties(serializer, mapper, objectName) {
    let modelProps = mapper.type.modelProperties;
    if (!modelProps) {
      const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
      if (!modelMapper) {
        throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
      }
      modelProps = modelMapper === null || modelMapper === undefined ? undefined : modelMapper.type.modelProperties;
      if (!modelProps) {
        throw new Error(`modelProperties cannot be null or undefined in the ` + `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
      }
    }
    return modelProps;
  }
  function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
      mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
    }
    if (object !== undefined && object !== null) {
      const payload = {};
      const modelProps = resolveModelProperties(serializer, mapper, objectName);
      for (const key of Object.keys(modelProps)) {
        const propertyMapper = modelProps[key];
        if (propertyMapper.readOnly) {
          continue;
        }
        let propName;
        let parentObject = payload;
        if (serializer.isXML) {
          if (propertyMapper.xmlIsWrapped) {
            propName = propertyMapper.xmlName;
          } else {
            propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
          }
        } else {
          const paths = splitSerializeName(propertyMapper.serializedName);
          propName = paths.pop();
          for (const pathName of paths) {
            const childObject = parentObject[pathName];
            if ((childObject === undefined || childObject === null) && (object[key] !== undefined && object[key] !== null || propertyMapper.defaultValue !== undefined)) {
              parentObject[pathName] = {};
            }
            parentObject = parentObject[pathName];
          }
        }
        if (parentObject !== undefined && parentObject !== null) {
          if (isXml && mapper.xmlNamespace) {
            const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
            parentObject[interfaces_js_1.XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[interfaces_js_1.XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });
          }
          const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
          let toSerialize = object[key];
          const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
          if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === undefined || toSerialize === null)) {
            toSerialize = mapper.serializedName;
          }
          const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
          if (serializedValue !== undefined && propName !== undefined && propName !== null) {
            const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
            if (isXml && propertyMapper.xmlIsAttribute) {
              parentObject[interfaces_js_1.XML_ATTRKEY] = parentObject[interfaces_js_1.XML_ATTRKEY] || {};
              parentObject[interfaces_js_1.XML_ATTRKEY][propName] = serializedValue;
            } else if (isXml && propertyMapper.xmlIsWrapped) {
              parentObject[propName] = { [propertyMapper.xmlElementName]: value };
            } else {
              parentObject[propName] = value;
            }
          }
        }
      }
      const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
      if (additionalPropertiesMapper) {
        const propNames = Object.keys(modelProps);
        for (const clientPropName in object) {
          const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
          if (isAdditionalProperty) {
            payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
          }
        }
      }
      return payload;
    }
    return object;
  }
  function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
    if (!isXml || !propertyMapper.xmlNamespace) {
      return serializedValue;
    }
    const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
    if (["Composite"].includes(propertyMapper.type.name)) {
      if (serializedValue[interfaces_js_1.XML_ATTRKEY]) {
        return serializedValue;
      } else {
        const result2 = Object.assign({}, serializedValue);
        result2[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
        return result2;
      }
    }
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
    return result;
  }
  function isSpecialXmlProperty(propertyName, options) {
    return [interfaces_js_1.XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
  }
  function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
    var _a, _b;
    const xmlCharKey = (_a = options.xml.xmlCharKey) !== null && _a !== undefined ? _a : interfaces_js_1.XML_CHARKEY;
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
      mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
    }
    const modelProps = resolveModelProperties(serializer, mapper, objectName);
    let instance = {};
    const handledPropertyNames = [];
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      const paths = splitSerializeName(modelProps[key].serializedName);
      handledPropertyNames.push(paths[0]);
      const { serializedName, xmlName, xmlElementName } = propertyMapper;
      let propertyObjectName = objectName;
      if (serializedName !== "" && serializedName !== undefined) {
        propertyObjectName = objectName + "." + serializedName;
      }
      const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
      if (headerCollectionPrefix) {
        const dictionary = {};
        for (const headerKey of Object.keys(responseBody)) {
          if (headerKey.startsWith(headerCollectionPrefix)) {
            dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
          }
          handledPropertyNames.push(headerKey);
        }
        instance[key] = dictionary;
      } else if (serializer.isXML) {
        if (propertyMapper.xmlIsAttribute && responseBody[interfaces_js_1.XML_ATTRKEY]) {
          instance[key] = serializer.deserialize(propertyMapper, responseBody[interfaces_js_1.XML_ATTRKEY][xmlName], propertyObjectName, options);
        } else if (propertyMapper.xmlIsMsText) {
          if (responseBody[xmlCharKey] !== undefined) {
            instance[key] = responseBody[xmlCharKey];
          } else if (typeof responseBody === "string") {
            instance[key] = responseBody;
          }
        } else {
          const propertyName = xmlElementName || xmlName || serializedName;
          if (propertyMapper.xmlIsWrapped) {
            const wrapped = responseBody[xmlName];
            const elementList = (_b = wrapped === null || wrapped === undefined ? undefined : wrapped[xmlElementName]) !== null && _b !== undefined ? _b : [];
            instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
            handledPropertyNames.push(xmlName);
          } else {
            const property = responseBody[propertyName];
            instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
            handledPropertyNames.push(propertyName);
          }
        }
      } else {
        let propertyInstance;
        let res = responseBody;
        let steps = 0;
        for (const item of paths) {
          if (!res)
            break;
          steps++;
          res = res[item];
        }
        if (res === null && steps < paths.length) {
          res = undefined;
        }
        propertyInstance = res;
        const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
        if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === undefined || propertyInstance === null)) {
          propertyInstance = mapper.serializedName;
        }
        let serializedValue;
        if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
          propertyInstance = responseBody[key];
          const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
          for (const [k, v] of Object.entries(instance)) {
            if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
              arrayInstance[k] = v;
            }
          }
          instance = arrayInstance;
        } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
          serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
          instance[key] = serializedValue;
        }
      }
    }
    const additionalPropertiesMapper = mapper.type.additionalProperties;
    if (additionalPropertiesMapper) {
      const isAdditionalProperty = (responsePropName) => {
        for (const clientPropName in modelProps) {
          const paths = splitSerializeName(modelProps[clientPropName].serializedName);
          if (paths[0] === responsePropName) {
            return false;
          }
        }
        return true;
      };
      for (const responsePropName in responseBody) {
        if (isAdditionalProperty(responsePropName)) {
          instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
        }
      }
    } else if (responseBody && !options.ignoreUnknownProperties) {
      for (const key of Object.keys(responseBody)) {
        if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {
          instance[key] = responseBody[key];
        }
      }
    }
    return instance;
  }
  function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
    const value = mapper.type.value;
    if (!value || typeof value !== "object") {
      throw new Error(`"value" metadata for a Dictionary must be defined in the ` + `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
      const tempDictionary = {};
      for (const key of Object.keys(responseBody)) {
        tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
      }
      return tempDictionary;
    }
    return responseBody;
  }
  function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
    var _a;
    let element = mapper.type.element;
    if (!element || typeof element !== "object") {
      throw new Error(`element" metadata for an Array must be defined in the ` + `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
      if (!Array.isArray(responseBody)) {
        responseBody = [responseBody];
      }
      if (element.type.name === "Composite" && element.type.className) {
        element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== undefined ? _a : element;
      }
      const tempArray = [];
      for (let i = 0;i < responseBody.length; i++) {
        tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
      }
      return tempArray;
    }
    return responseBody;
  }
  function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
    const typeNamesToCheck = [typeName];
    while (typeNamesToCheck.length) {
      const currentName = typeNamesToCheck.shift();
      const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
      if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
        return discriminators[indexDiscriminator];
      } else {
        for (const [name, mapper] of Object.entries(discriminators)) {
          if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
            typeNamesToCheck.push(mapper.type.className);
          }
        }
      }
    }
    return;
  }
  function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
    var _a;
    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
    if (polymorphicDiscriminator) {
      let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
      if (discriminatorName) {
        if (polymorphicPropertyName === "serializedName") {
          discriminatorName = discriminatorName.replace(/\\/gi, "");
        }
        const discriminatorValue = object[discriminatorName];
        const typeName = (_a = mapper.type.uberParent) !== null && _a !== undefined ? _a : mapper.type.className;
        if (typeof discriminatorValue === "string" && typeName) {
          const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
          if (polymorphicMapper) {
            mapper = polymorphicMapper;
          }
        }
      }
    }
    return mapper;
  }
  function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
    return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
  }
  function getPolymorphicDiscriminatorSafely(serializer, typeName) {
    return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
  }
  exports.MapperTypeNames = {
    Base64Url: "Base64Url",
    Boolean: "Boolean",
    ByteArray: "ByteArray",
    Composite: "Composite",
    Date: "Date",
    DateTime: "DateTime",
    DateTimeRfc1123: "DateTimeRfc1123",
    Dictionary: "Dictionary",
    Enum: "Enum",
    Number: "Number",
    Object: "Object",
    Sequence: "Sequence",
    String: "String",
    Stream: "Stream",
    TimeSpan: "TimeSpan",
    UnixTime: "UnixTime"
  };
});

// node_modules/@azure/core-client/dist/commonjs/state.js
var require_state2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.state = undefined;
  exports.state = {
    operationRequestMap: new WeakMap
  };
});

// node_modules/@azure/core-client/dist/commonjs/operationHelpers.js
var require_operationHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOperationRequestInfo = exports.getOperationArgumentValueFromParameter = undefined;
  var state_js_1 = require_state2();
  function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
    let parameterPath = parameter.parameterPath;
    const parameterMapper = parameter.mapper;
    let value;
    if (typeof parameterPath === "string") {
      parameterPath = [parameterPath];
    }
    if (Array.isArray(parameterPath)) {
      if (parameterPath.length > 0) {
        if (parameterMapper.isConstant) {
          value = parameterMapper.defaultValue;
        } else {
          let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
          if (!propertySearchResult.propertyFound && fallbackObject) {
            propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
          }
          let useDefaultValue = false;
          if (!propertySearchResult.propertyFound) {
            useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
          }
          value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
        }
      }
    } else {
      if (parameterMapper.required) {
        value = {};
      }
      for (const propertyName in parameterPath) {
        const propertyMapper = parameterMapper.type.modelProperties[propertyName];
        const propertyPath = parameterPath[propertyName];
        const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
          parameterPath: propertyPath,
          mapper: propertyMapper
        }, fallbackObject);
        if (propertyValue !== undefined) {
          if (!value) {
            value = {};
          }
          value[propertyName] = propertyValue;
        }
      }
    }
    return value;
  }
  exports.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
  function getPropertyFromParameterPath(parent, parameterPath) {
    const result = { propertyFound: false };
    let i = 0;
    for (;i < parameterPath.length; ++i) {
      const parameterPathPart = parameterPath[i];
      if (parent && parameterPathPart in parent) {
        parent = parent[parameterPathPart];
      } else {
        break;
      }
    }
    if (i === parameterPath.length) {
      result.propertyValue = parent;
      result.propertyFound = true;
    }
    return result;
  }
  var originalRequestSymbol = Symbol.for("@azure/core-client original request");
  function hasOriginalRequest(request) {
    return originalRequestSymbol in request;
  }
  function getOperationRequestInfo(request) {
    if (hasOriginalRequest(request)) {
      return getOperationRequestInfo(request[originalRequestSymbol]);
    }
    let info = state_js_1.state.operationRequestMap.get(request);
    if (!info) {
      info = {};
      state_js_1.state.operationRequestMap.set(request, info);
    }
    return info;
  }
  exports.getOperationRequestInfo = getOperationRequestInfo;
});

// node_modules/@azure/core-client/dist/commonjs/deserializationPolicy.js
var require_deserializationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deserializationPolicy = exports.deserializationPolicyName = undefined;
  var interfaces_js_1 = require_interfaces();
  var core_rest_pipeline_1 = require_commonjs6();
  var serializer_js_1 = require_serializer();
  var operationHelpers_js_1 = require_operationHelpers();
  var defaultJsonContentTypes = ["application/json", "text/json"];
  var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
  exports.deserializationPolicyName = "deserializationPolicy";
  function deserializationPolicy(options = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === undefined ? undefined : _a.json) !== null && _b !== undefined ? _b : defaultJsonContentTypes;
    const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === undefined ? undefined : _c.xml) !== null && _d !== undefined ? _d : defaultXmlContentTypes;
    const parseXML = options.parseXML;
    const serializerOptions = options.serializerOptions;
    const updatedOptions = {
      xml: {
        rootName: (_e = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.rootName) !== null && _e !== undefined ? _e : "",
        includeRoot: (_f = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.includeRoot) !== null && _f !== undefined ? _f : false,
        xmlCharKey: (_g = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.xmlCharKey) !== null && _g !== undefined ? _g : interfaces_js_1.XML_CHARKEY
      }
    };
    return {
      name: exports.deserializationPolicyName,
      async sendRequest(request, next) {
        const response = await next(request);
        return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
      }
    };
  }
  exports.deserializationPolicy = deserializationPolicy;
  function getOperationResponseMap(parsedResponse) {
    let result;
    const request = parsedResponse.request;
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
    const operationSpec = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationSpec;
    if (operationSpec) {
      if (!(operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationResponseGetter)) {
        result = operationSpec.responses[parsedResponse.status];
      } else {
        result = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
      }
    }
    return result;
  }
  function shouldDeserializeResponse(parsedResponse) {
    const request = parsedResponse.request;
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
    const shouldDeserialize = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.shouldDeserialize;
    let result;
    if (shouldDeserialize === undefined) {
      result = true;
    } else if (typeof shouldDeserialize === "boolean") {
      result = shouldDeserialize;
    } else {
      result = shouldDeserialize(parsedResponse);
    }
    return result;
  }
  async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
    if (!shouldDeserializeResponse(parsedResponse)) {
      return parsedResponse;
    }
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(parsedResponse.request);
    const operationSpec = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationSpec;
    if (!operationSpec || !operationSpec.responses) {
      return parsedResponse;
    }
    const responseSpec = getOperationResponseMap(parsedResponse);
    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
    if (error) {
      throw error;
    } else if (shouldReturnResponse) {
      return parsedResponse;
    }
    if (responseSpec) {
      if (responseSpec.bodyMapper) {
        let valueToDeserialize = parsedResponse.parsedBody;
        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
          valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
        }
        try {
          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
        } catch (deserializeError) {
          const restError = new core_rest_pipeline_1.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
            statusCode: parsedResponse.status,
            request: parsedResponse.request,
            response: parsedResponse
          });
          throw restError;
        }
      } else if (operationSpec.httpMethod === "HEAD") {
        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
      }
      if (responseSpec.headersMapper) {
        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
      }
    }
    return parsedResponse;
  }
  function isOperationSpecEmpty(operationSpec) {
    const expectedStatusCodes = Object.keys(operationSpec.responses);
    return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
  }
  function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
    var _a;
    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
    if (isExpectedStatusCode) {
      if (responseSpec) {
        if (!responseSpec.isError) {
          return { error: null, shouldReturnResponse: false };
        }
      } else {
        return { error: null, shouldReturnResponse: false };
      }
    }
    const errorResponseSpec = responseSpec !== null && responseSpec !== undefined ? responseSpec : operationSpec.responses.default;
    const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === undefined ? undefined : _a.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
    const error = new core_rest_pipeline_1.RestError(initialErrorMessage, {
      statusCode: parsedResponse.status,
      request: parsedResponse.request,
      response: parsedResponse
    });
    if (!errorResponseSpec) {
      throw error;
    }
    const defaultBodyMapper = errorResponseSpec.bodyMapper;
    const defaultHeadersMapper = errorResponseSpec.headersMapper;
    try {
      if (parsedResponse.parsedBody) {
        const parsedBody = parsedResponse.parsedBody;
        let deserializedError;
        if (defaultBodyMapper) {
          let valueToDeserialize = parsedBody;
          if (operationSpec.isXML && defaultBodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
            valueToDeserialize = [];
            const elementName = defaultBodyMapper.xmlElementName;
            if (typeof parsedBody === "object" && elementName) {
              valueToDeserialize = parsedBody[elementName];
            }
          }
          deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
        }
        const internalError = parsedBody.error || deserializedError || parsedBody;
        error.code = internalError.code;
        if (internalError.message) {
          error.message = internalError.message;
        }
        if (defaultBodyMapper) {
          error.response.parsedBody = deserializedError;
        }
      }
      if (parsedResponse.headers && defaultHeadersMapper) {
        error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
      }
    } catch (defaultError) {
      error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
    }
    return { error, shouldReturnResponse: false };
  }
  async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
    var _a;
    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === undefined ? undefined : _a.has(operationResponse.status)) && operationResponse.bodyAsText) {
      const text = operationResponse.bodyAsText;
      const contentType = operationResponse.headers.get("Content-Type") || "";
      const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
      try {
        if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
          operationResponse.parsedBody = JSON.parse(text);
          return operationResponse;
        } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
          if (!parseXML) {
            throw new Error("Parsing XML not supported.");
          }
          const body = await parseXML(text, opts.xml);
          operationResponse.parsedBody = body;
          return operationResponse;
        }
      } catch (err) {
        const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
        const errCode = err.code || core_rest_pipeline_1.RestError.PARSE_ERROR;
        const e = new core_rest_pipeline_1.RestError(msg, {
          code: errCode,
          statusCode: operationResponse.status,
          request: operationResponse.request,
          response: operationResponse
        });
        throw e;
      }
    }
    return operationResponse;
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaceHelpers.js
var require_interfaceHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getPathStringFromParameter = exports.getStreamingResponseStatusCodes = undefined;
  var serializer_js_1 = require_serializer();
  function getStreamingResponseStatusCodes(operationSpec) {
    const result = new Set;
    for (const statusCode in operationSpec.responses) {
      const operationResponse = operationSpec.responses[statusCode];
      if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Stream) {
        result.add(Number(statusCode));
      }
    }
    return result;
  }
  exports.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
  function getPathStringFromParameter(parameter) {
    const { parameterPath, mapper } = parameter;
    let result;
    if (typeof parameterPath === "string") {
      result = parameterPath;
    } else if (Array.isArray(parameterPath)) {
      result = parameterPath.join(".");
    } else {
      result = mapper.serializedName;
    }
    return result;
  }
  exports.getPathStringFromParameter = getPathStringFromParameter;
});

// node_modules/@azure/core-client/dist/commonjs/serializationPolicy.js
var require_serializationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serializeRequestBody = exports.serializeHeaders = exports.serializationPolicy = exports.serializationPolicyName = undefined;
  var interfaces_js_1 = require_interfaces();
  var operationHelpers_js_1 = require_operationHelpers();
  var serializer_js_1 = require_serializer();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  exports.serializationPolicyName = "serializationPolicy";
  function serializationPolicy(options = {}) {
    const stringifyXML = options.stringifyXML;
    return {
      name: exports.serializationPolicyName,
      async sendRequest(request, next) {
        const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
        const operationSpec = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationSpec;
        const operationArguments = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationArguments;
        if (operationSpec && operationArguments) {
          serializeHeaders(request, operationArguments, operationSpec);
          serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
        }
        return next(request);
      }
    };
  }
  exports.serializationPolicy = serializationPolicy;
  function serializeHeaders(request, operationArguments, operationSpec) {
    var _a, _b;
    if (operationSpec.headerParameters) {
      for (const headerParameter of operationSpec.headerParameters) {
        let headerValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
        if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {
          headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter));
          const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
          if (headerCollectionPrefix) {
            for (const key of Object.keys(headerValue)) {
              request.headers.set(headerCollectionPrefix + key, headerValue[key]);
            }
          } else {
            request.headers.set(headerParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter), headerValue);
          }
        }
      }
    }
    const customHeaders = (_b = (_a = operationArguments.options) === null || _a === undefined ? undefined : _a.requestOptions) === null || _b === undefined ? undefined : _b.customHeaders;
    if (customHeaders) {
      for (const customHeaderName of Object.keys(customHeaders)) {
        request.headers.set(customHeaderName, customHeaders[customHeaderName]);
      }
    }
  }
  exports.serializeHeaders = serializeHeaders;
  function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function() {
    throw new Error("XML serialization unsupported!");
  }) {
    var _a, _b, _c, _d, _e;
    const serializerOptions = (_a = operationArguments.options) === null || _a === undefined ? undefined : _a.serializerOptions;
    const updatedOptions = {
      xml: {
        rootName: (_b = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.rootName) !== null && _b !== undefined ? _b : "",
        includeRoot: (_c = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.includeRoot) !== null && _c !== undefined ? _c : false,
        xmlCharKey: (_d = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.xmlCharKey) !== null && _d !== undefined ? _d : interfaces_js_1.XML_CHARKEY
      }
    };
    const xmlCharKey = updatedOptions.xml.xmlCharKey;
    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
      request.body = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
      const bodyMapper = operationSpec.requestBody.mapper;
      const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
      const typeName = bodyMapper.type.name;
      try {
        if (request.body !== undefined && request.body !== null || nullable && request.body === null || required) {
          const requestBodyParameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(operationSpec.requestBody);
          request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
          const isStream = typeName === serializer_js_1.MapperTypeNames.Stream;
          if (operationSpec.isXML) {
            const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
            const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
            if (typeName === serializer_js_1.MapperTypeNames.Sequence) {
              request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
            } else if (!isStream) {
              request.body = stringifyXML(value, {
                rootName: xmlName || serializedName,
                xmlCharKey
              });
            }
          } else if (typeName === serializer_js_1.MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === undefined ? undefined : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
            return;
          } else if (!isStream) {
            request.body = JSON.stringify(request.body);
          }
        }
      } catch (error) {
        throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, "  ")}.`);
      }
    } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
      request.formData = {};
      for (const formDataParameter of operationSpec.formDataParameters) {
        const formDataParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
        if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
          const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter);
          request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter), updatedOptions);
        }
      }
    }
  }
  exports.serializeRequestBody = serializeRequestBody;
  function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
    if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
      const result = {};
      result[options.xml.xmlCharKey] = serializedValue;
      result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
      return result;
    }
    return serializedValue;
  }
  function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
    if (!Array.isArray(obj)) {
      obj = [obj];
    }
    if (!xmlNamespaceKey || !xmlNamespace) {
      return { [elementName]: obj };
    }
    const result = { [elementName]: obj };
    result[interfaces_js_1.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
    return result;
  }
});

// node_modules/@azure/core-client/dist/commonjs/pipeline.js
var require_pipeline2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createClientPipeline = undefined;
  var deserializationPolicy_js_1 = require_deserializationPolicy();
  var core_rest_pipeline_1 = require_commonjs6();
  var serializationPolicy_js_1 = require_serializationPolicy();
  function createClientPipeline(options = {}) {
    const pipeline = (0, core_rest_pipeline_1.createPipelineFromOptions)(options !== null && options !== undefined ? options : {});
    if (options.credentialOptions) {
      pipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
        credential: options.credentialOptions.credential,
        scopes: options.credentialOptions.credentialScopes
      }));
    }
    pipeline.addPolicy((0, serializationPolicy_js_1.serializationPolicy)(options.serializationOptions), { phase: "Serialize" });
    pipeline.addPolicy((0, deserializationPolicy_js_1.deserializationPolicy)(options.deserializationOptions), {
      phase: "Deserialize"
    });
    return pipeline;
  }
  exports.createClientPipeline = createClientPipeline;
});

// node_modules/@azure/core-client/dist/commonjs/httpClientCache.js
var require_httpClientCache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCachedDefaultHttpClient = undefined;
  var core_rest_pipeline_1 = require_commonjs6();
  var cachedHttpClient;
  function getCachedDefaultHttpClient() {
    if (!cachedHttpClient) {
      cachedHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
    }
    return cachedHttpClient;
  }
  exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
});

// node_modules/@azure/core-client/dist/commonjs/urlHelpers.js
var require_urlHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.appendQueryParams = exports.getRequestUrl = undefined;
  var operationHelpers_js_1 = require_operationHelpers();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  var CollectionFormatToDelimiterMap = {
    CSV: ",",
    SSV: " ",
    Multi: "Multi",
    TSV: "\t",
    Pipes: "|"
  };
  function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
    let isAbsolutePath = false;
    let requestUrl = replaceAll(baseUri, urlReplacements);
    if (operationSpec.path) {
      let path = replaceAll(operationSpec.path, urlReplacements);
      if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
        path = path.substring(1);
      }
      if (isAbsoluteUrl(path)) {
        requestUrl = path;
        isAbsolutePath = true;
      } else {
        requestUrl = appendPath(requestUrl, path);
      }
    }
    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
    return requestUrl;
  }
  exports.getRequestUrl = getRequestUrl;
  function replaceAll(input, replacements) {
    let result = input;
    for (const [searchValue, replaceValue] of replacements) {
      result = result.split(searchValue).join(replaceValue);
    }
    return result;
  }
  function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
    var _a;
    const result = new Map;
    if ((_a = operationSpec.urlParameters) === null || _a === undefined ? undefined : _a.length) {
      for (const urlParameter of operationSpec.urlParameters) {
        let urlParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
        const parameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(urlParameter);
        urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
        if (!urlParameter.skipEncoding) {
          urlParameterValue = encodeURIComponent(urlParameterValue);
        }
        result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
      }
    }
    return result;
  }
  function isAbsoluteUrl(url) {
    return url.includes("://");
  }
  function appendPath(url, pathToAppend) {
    if (!pathToAppend) {
      return url;
    }
    const parsedUrl = new URL(url);
    let newPath = parsedUrl.pathname;
    if (!newPath.endsWith("/")) {
      newPath = `${newPath}/`;
    }
    if (pathToAppend.startsWith("/")) {
      pathToAppend = pathToAppend.substring(1);
    }
    const searchStart = pathToAppend.indexOf("?");
    if (searchStart !== -1) {
      const path = pathToAppend.substring(0, searchStart);
      const search = pathToAppend.substring(searchStart + 1);
      newPath = newPath + path;
      if (search) {
        parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
      }
    } else {
      newPath = newPath + pathToAppend;
    }
    parsedUrl.pathname = newPath;
    return parsedUrl.toString();
  }
  function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
    var _a;
    const result = new Map;
    const sequenceParams = new Set;
    if ((_a = operationSpec.queryParameters) === null || _a === undefined ? undefined : _a.length) {
      for (const queryParameter of operationSpec.queryParameters) {
        if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
          sequenceParams.add(queryParameter.mapper.serializedName);
        }
        let queryParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
        if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {
          queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter));
          const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              if (item === null || item === undefined) {
                return "";
              }
              return item;
            });
          }
          if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
            continue;
          } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          if (!queryParameter.skipEncoding) {
            if (Array.isArray(queryParameterValue)) {
              queryParameterValue = queryParameterValue.map((item) => {
                return encodeURIComponent(item);
              });
            } else {
              queryParameterValue = encodeURIComponent(queryParameterValue);
            }
          }
          if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          result.set(queryParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter), queryParameterValue);
        }
      }
    }
    return {
      queryParams: result,
      sequenceParams
    };
  }
  function simpleParseQueryParams(queryString) {
    const result = new Map;
    if (!queryString || queryString[0] !== "?") {
      return result;
    }
    queryString = queryString.slice(1);
    const pairs = queryString.split("&");
    for (const pair of pairs) {
      const [name, value] = pair.split("=", 2);
      const existingValue = result.get(name);
      if (existingValue) {
        if (Array.isArray(existingValue)) {
          existingValue.push(value);
        } else {
          result.set(name, [existingValue, value]);
        }
      } else {
        result.set(name, value);
      }
    }
    return result;
  }
  function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
    if (queryParams.size === 0) {
      return url;
    }
    const parsedUrl = new URL(url);
    const combinedParams = simpleParseQueryParams(parsedUrl.search);
    for (const [name, value] of queryParams) {
      const existingValue = combinedParams.get(name);
      if (Array.isArray(existingValue)) {
        if (Array.isArray(value)) {
          existingValue.push(...value);
          const valueSet = new Set(existingValue);
          combinedParams.set(name, Array.from(valueSet));
        } else {
          existingValue.push(value);
        }
      } else if (existingValue) {
        if (Array.isArray(value)) {
          value.unshift(existingValue);
        } else if (sequenceParams.has(name)) {
          combinedParams.set(name, [existingValue, value]);
        }
        if (!noOverwrite) {
          combinedParams.set(name, value);
        }
      } else {
        combinedParams.set(name, value);
      }
    }
    const searchPieces = [];
    for (const [name, value] of combinedParams) {
      if (typeof value === "string") {
        searchPieces.push(`${name}=${value}`);
      } else if (Array.isArray(value)) {
        for (const subValue of value) {
          searchPieces.push(`${name}=${subValue}`);
        }
      } else {
        searchPieces.push(`${name}=${value}`);
      }
    }
    parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return parsedUrl.toString();
  }
  exports.appendQueryParams = appendQueryParams;
});

// node_modules/@azure/core-client/dist/commonjs/log.js
var require_log3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs();
  exports.logger = (0, logger_1.createClientLogger)("core-client");
});

// node_modules/@azure/core-client/dist/commonjs/serviceClient.js
var require_serviceClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServiceClient = undefined;
  var core_rest_pipeline_1 = require_commonjs6();
  var pipeline_js_1 = require_pipeline2();
  var utils_js_1 = require_utils();
  var httpClientCache_js_1 = require_httpClientCache();
  var operationHelpers_js_1 = require_operationHelpers();
  var urlHelpers_js_1 = require_urlHelpers();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  var log_js_1 = require_log3();

  class ServiceClient {
    constructor(options = {}) {
      var _a, _b;
      this._requestContentType = options.requestContentType;
      this._endpoint = (_a = options.endpoint) !== null && _a !== undefined ? _a : options.baseUri;
      if (options.baseUri) {
        log_js_1.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
      }
      this._allowInsecureConnection = options.allowInsecureConnection;
      this._httpClient = options.httpClient || (0, httpClientCache_js_1.getCachedDefaultHttpClient)();
      this.pipeline = options.pipeline || createDefaultPipeline(options);
      if ((_b = options.additionalPolicies) === null || _b === undefined ? undefined : _b.length) {
        for (const { policy, position } of options.additionalPolicies) {
          const afterPhase = position === "perRetry" ? "Sign" : undefined;
          this.pipeline.addPolicy(policy, {
            afterPhase
          });
        }
      }
    }
    async sendRequest(request) {
      return this.pipeline.sendRequest(this._httpClient, request);
    }
    async sendOperationRequest(operationArguments, operationSpec) {
      const endpoint = operationSpec.baseUrl || this._endpoint;
      if (!endpoint) {
        throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
      }
      const url = (0, urlHelpers_js_1.getRequestUrl)(endpoint, operationSpec, operationArguments, this);
      const request = (0, core_rest_pipeline_1.createPipelineRequest)({
        url
      });
      request.method = operationSpec.httpMethod;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
      operationInfo.operationSpec = operationSpec;
      operationInfo.operationArguments = operationArguments;
      const contentType = operationSpec.contentType || this._requestContentType;
      if (contentType && operationSpec.requestBody) {
        request.headers.set("Content-Type", contentType);
      }
      const options = operationArguments.options;
      if (options) {
        const requestOptions = options.requestOptions;
        if (requestOptions) {
          if (requestOptions.timeout) {
            request.timeout = requestOptions.timeout;
          }
          if (requestOptions.onUploadProgress) {
            request.onUploadProgress = requestOptions.onUploadProgress;
          }
          if (requestOptions.onDownloadProgress) {
            request.onDownloadProgress = requestOptions.onDownloadProgress;
          }
          if (requestOptions.shouldDeserialize !== undefined) {
            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
          }
          if (requestOptions.allowInsecureConnection) {
            request.allowInsecureConnection = true;
          }
        }
        if (options.abortSignal) {
          request.abortSignal = options.abortSignal;
        }
        if (options.tracingOptions) {
          request.tracingOptions = options.tracingOptions;
        }
      }
      if (this._allowInsecureConnection) {
        request.allowInsecureConnection = true;
      }
      if (request.streamResponseStatusCodes === undefined) {
        request.streamResponseStatusCodes = (0, interfaceHelpers_js_1.getStreamingResponseStatusCodes)(operationSpec);
      }
      try {
        const rawResponse = await this.sendRequest(request);
        const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
        if (options === null || options === undefined ? undefined : options.onResponse) {
          options.onResponse(rawResponse, flatResponse);
        }
        return flatResponse;
      } catch (error) {
        if (typeof error === "object" && (error === null || error === undefined ? undefined : error.response)) {
          const rawResponse = error.response;
          const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
          error.details = flatResponse;
          if (options === null || options === undefined ? undefined : options.onResponse) {
            options.onResponse(rawResponse, flatResponse, error);
          }
        }
        throw error;
      }
    }
  }
  exports.ServiceClient = ServiceClient;
  function createDefaultPipeline(options) {
    const credentialScopes = getCredentialScopes(options);
    const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : undefined;
    return (0, pipeline_js_1.createClientPipeline)(Object.assign(Object.assign({}, options), { credentialOptions }));
  }
  function getCredentialScopes(options) {
    if (options.credentialScopes) {
      return options.credentialScopes;
    }
    if (options.endpoint) {
      return `${options.endpoint}/.default`;
    }
    if (options.baseUri) {
      return `${options.baseUri}/.default`;
    }
    if (options.credential && !options.credentialScopes) {
      throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
    }
    return;
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnClaimChallenge.js
var require_authorizeRequestOnClaimChallenge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.authorizeRequestOnClaimChallenge = exports.parseCAEChallenge = undefined;
  var log_js_1 = require_log3();
  var base64_js_1 = require_base64();
  function parseCAEChallenge(challenges) {
    const bearerChallenges = `, ${challenges.trim()}`.split(", Bearer ").filter((x) => x);
    return bearerChallenges.map((challenge) => {
      const challengeParts = `${challenge.trim()}, `.split('", ').filter((x) => x);
      const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('="')));
      return keyValuePairs.reduce((a, b) => Object.assign(Object.assign({}, a), b), {});
    });
  }
  exports.parseCAEChallenge = parseCAEChallenge;
  async function authorizeRequestOnClaimChallenge(onChallengeOptions) {
    const { scopes, response } = onChallengeOptions;
    const logger = onChallengeOptions.logger || log_js_1.logger;
    const challenge = response.headers.get("WWW-Authenticate");
    if (!challenge) {
      logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);
      return false;
    }
    const challenges = parseCAEChallenge(challenge) || [];
    const parsedChallenge = challenges.find((x) => x.claims);
    if (!parsedChallenge) {
      logger.info(`The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.`);
      return false;
    }
    const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
      claims: (0, base64_js_1.decodeStringToString)(parsedChallenge.claims)
    });
    if (!accessToken) {
      return false;
    }
    onChallengeOptions.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
    return true;
  }
  exports.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge;
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnTenantChallenge.js
var require_authorizeRequestOnTenantChallenge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.authorizeRequestOnTenantChallenge = undefined;
  var Constants = {
    DefaultScope: "/.default",
    HeaderConstants: {
      AUTHORIZATION: "authorization"
    }
  };
  function isUuid(text) {
    return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(text);
  }
  var authorizeRequestOnTenantChallenge = async (challengeOptions) => {
    const requestOptions = requestToOptions(challengeOptions.request);
    const challenge = getChallenge(challengeOptions.response);
    if (challenge) {
      const challengeInfo = parseChallenge(challenge);
      const challengeScopes = buildScopes(challengeOptions, challengeInfo);
      const tenantId = extractTenantId(challengeInfo);
      if (!tenantId) {
        return false;
      }
      const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), { tenantId }));
      if (!accessToken) {
        return false;
      }
      challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);
      return true;
    }
    return false;
  };
  exports.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge;
  function extractTenantId(challengeInfo) {
    const parsedAuthUri = new URL(challengeInfo.authorization_uri);
    const pathSegments = parsedAuthUri.pathname.split("/");
    const tenantId = pathSegments[1];
    if (tenantId && isUuid(tenantId)) {
      return tenantId;
    }
    return;
  }
  function buildScopes(challengeOptions, challengeInfo) {
    if (!challengeInfo.resource_id) {
      return challengeOptions.scopes;
    }
    const challengeScopes = new URL(challengeInfo.resource_id);
    challengeScopes.pathname = Constants.DefaultScope;
    let scope = challengeScopes.toString();
    if (scope === "https://disk.azure.com/.default") {
      scope = "https://disk.azure.com//.default";
    }
    return [scope];
  }
  function getChallenge(response) {
    const challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) {
      return challenge;
    }
    return;
  }
  function parseChallenge(challenge) {
    const bearerChallenge = challenge.slice("Bearer ".length);
    const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x) => x);
    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("=")));
    return keyValuePairs.reduce((a, b) => Object.assign(Object.assign({}, a), b), {});
  }
  function requestToOptions(request) {
    return {
      abortSignal: request.abortSignal,
      requestOptions: {
        timeout: request.timeout
      },
      tracingOptions: request.tracingOptions
    };
  }
});

// node_modules/@azure/core-client/dist/commonjs/index.js
var require_commonjs8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.authorizeRequestOnTenantChallenge = exports.authorizeRequestOnClaimChallenge = exports.serializationPolicyName = exports.serializationPolicy = exports.deserializationPolicyName = exports.deserializationPolicy = exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.createClientPipeline = exports.ServiceClient = exports.MapperTypeNames = exports.createSerializer = undefined;
  var serializer_js_1 = require_serializer();
  Object.defineProperty(exports, "createSerializer", { enumerable: true, get: function() {
    return serializer_js_1.createSerializer;
  } });
  Object.defineProperty(exports, "MapperTypeNames", { enumerable: true, get: function() {
    return serializer_js_1.MapperTypeNames;
  } });
  var serviceClient_js_1 = require_serviceClient();
  Object.defineProperty(exports, "ServiceClient", { enumerable: true, get: function() {
    return serviceClient_js_1.ServiceClient;
  } });
  var pipeline_js_1 = require_pipeline2();
  Object.defineProperty(exports, "createClientPipeline", { enumerable: true, get: function() {
    return pipeline_js_1.createClientPipeline;
  } });
  var interfaces_js_1 = require_interfaces();
  Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
    return interfaces_js_1.XML_ATTRKEY;
  } });
  Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
    return interfaces_js_1.XML_CHARKEY;
  } });
  var deserializationPolicy_js_1 = require_deserializationPolicy();
  Object.defineProperty(exports, "deserializationPolicy", { enumerable: true, get: function() {
    return deserializationPolicy_js_1.deserializationPolicy;
  } });
  Object.defineProperty(exports, "deserializationPolicyName", { enumerable: true, get: function() {
    return deserializationPolicy_js_1.deserializationPolicyName;
  } });
  var serializationPolicy_js_1 = require_serializationPolicy();
  Object.defineProperty(exports, "serializationPolicy", { enumerable: true, get: function() {
    return serializationPolicy_js_1.serializationPolicy;
  } });
  Object.defineProperty(exports, "serializationPolicyName", { enumerable: true, get: function() {
    return serializationPolicy_js_1.serializationPolicyName;
  } });
  var authorizeRequestOnClaimChallenge_js_1 = require_authorizeRequestOnClaimChallenge();
  Object.defineProperty(exports, "authorizeRequestOnClaimChallenge", { enumerable: true, get: function() {
    return authorizeRequestOnClaimChallenge_js_1.authorizeRequestOnClaimChallenge;
  } });
  var authorizeRequestOnTenantChallenge_js_1 = require_authorizeRequestOnTenantChallenge();
  Object.defineProperty(exports, "authorizeRequestOnTenantChallenge", { enumerable: true, get: function() {
    return authorizeRequestOnTenantChallenge_js_1.authorizeRequestOnTenantChallenge;
  } });
});

// node_modules/@azure/core-http-compat/dist/commonjs/util.js
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpHeaders = exports.toHttpHeadersLike = exports.toWebResourceLike = exports.toPipelineRequest = undefined;
  var core_rest_pipeline_1 = require_commonjs6();
  var originalRequestSymbol = Symbol("Original PipelineRequest");
  var originalClientRequestSymbol = Symbol.for("@azure/core-client original request");
  function toPipelineRequest(webResource, options = {}) {
    const compatWebResource = webResource;
    const request = compatWebResource[originalRequestSymbol];
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)(webResource.headers.toJson({ preserveCase: true }));
    if (request) {
      request.headers = headers;
      return request;
    } else {
      const newRequest = (0, core_rest_pipeline_1.createPipelineRequest)({
        url: webResource.url,
        method: webResource.method,
        headers,
        withCredentials: webResource.withCredentials,
        timeout: webResource.timeout,
        requestId: webResource.requestId,
        abortSignal: webResource.abortSignal,
        body: webResource.body,
        formData: webResource.formData,
        disableKeepAlive: !!webResource.keepAlive,
        onDownloadProgress: webResource.onDownloadProgress,
        onUploadProgress: webResource.onUploadProgress,
        proxySettings: webResource.proxySettings,
        streamResponseStatusCodes: webResource.streamResponseStatusCodes
      });
      if (options.originalRequest) {
        newRequest[originalClientRequestSymbol] = options.originalRequest;
      }
      return newRequest;
    }
  }
  exports.toPipelineRequest = toPipelineRequest;
  function toWebResourceLike(request, options) {
    var _a;
    const originalRequest = (_a = options === null || options === undefined ? undefined : options.originalRequest) !== null && _a !== undefined ? _a : request;
    const webResource = {
      url: request.url,
      method: request.method,
      headers: toHttpHeadersLike(request.headers),
      withCredentials: request.withCredentials,
      timeout: request.timeout,
      requestId: request.headers.get("x-ms-client-request-id") || request.requestId,
      abortSignal: request.abortSignal,
      body: request.body,
      formData: request.formData,
      keepAlive: !!request.disableKeepAlive,
      onDownloadProgress: request.onDownloadProgress,
      onUploadProgress: request.onUploadProgress,
      proxySettings: request.proxySettings,
      streamResponseStatusCodes: request.streamResponseStatusCodes,
      clone() {
        throw new Error("Cannot clone a non-proxied WebResourceLike");
      },
      prepare() {
        throw new Error("WebResourceLike.prepare() is not supported by @azure/core-http-compat");
      },
      validateRequestProperties() {
      }
    };
    if (options === null || options === undefined ? undefined : options.createProxy) {
      return new Proxy(webResource, {
        get(target, prop, receiver) {
          if (prop === originalRequestSymbol) {
            return request;
          } else if (prop === "clone") {
            return () => {
              return toWebResourceLike(toPipelineRequest(webResource, { originalRequest }), {
                createProxy: true,
                originalRequest
              });
            };
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (prop === "keepAlive") {
            request.disableKeepAlive = !value;
          }
          const passThroughProps = [
            "url",
            "method",
            "withCredentials",
            "timeout",
            "requestId",
            "abortSignal",
            "body",
            "formData",
            "onDownloadProgress",
            "onUploadProgress",
            "proxySettings",
            "streamResponseStatusCodes"
          ];
          if (typeof prop === "string" && passThroughProps.includes(prop)) {
            request[prop] = value;
          }
          return Reflect.set(target, prop, value, receiver);
        }
      });
    } else {
      return webResource;
    }
  }
  exports.toWebResourceLike = toWebResourceLike;
  function toHttpHeadersLike(headers) {
    return new HttpHeaders(headers.toJSON({ preserveCase: true }));
  }
  exports.toHttpHeadersLike = toHttpHeadersLike;
  function getHeaderKey(headerName) {
    return headerName.toLowerCase();
  }

  class HttpHeaders {
    constructor(rawHeaders) {
      this._headersMap = {};
      if (rawHeaders) {
        for (const headerName in rawHeaders) {
          this.set(headerName, rawHeaders[headerName]);
        }
      }
    }
    set(headerName, headerValue) {
      this._headersMap[getHeaderKey(headerName)] = {
        name: headerName,
        value: headerValue.toString()
      };
    }
    get(headerName) {
      const header = this._headersMap[getHeaderKey(headerName)];
      return !header ? undefined : header.value;
    }
    contains(headerName) {
      return !!this._headersMap[getHeaderKey(headerName)];
    }
    remove(headerName) {
      const result = this.contains(headerName);
      delete this._headersMap[getHeaderKey(headerName)];
      return result;
    }
    rawHeaders() {
      return this.toJson({ preserveCase: true });
    }
    headersArray() {
      const headers = [];
      for (const headerKey in this._headersMap) {
        headers.push(this._headersMap[headerKey]);
      }
      return headers;
    }
    headerNames() {
      const headerNames = [];
      const headers = this.headersArray();
      for (let i = 0;i < headers.length; ++i) {
        headerNames.push(headers[i].name);
      }
      return headerNames;
    }
    headerValues() {
      const headerValues = [];
      const headers = this.headersArray();
      for (let i = 0;i < headers.length; ++i) {
        headerValues.push(headers[i].value);
      }
      return headerValues;
    }
    toJson(options = {}) {
      const result = {};
      if (options.preserveCase) {
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          result[header.name] = header.value;
        }
      } else {
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          result[getHeaderKey(header.name)] = header.value;
        }
      }
      return result;
    }
    toString() {
      return JSON.stringify(this.toJson({ preserveCase: true }));
    }
    clone() {
      const resultPreservingCasing = {};
      for (const headerKey in this._headersMap) {
        const header = this._headersMap[headerKey];
        resultPreservingCasing[header.name] = header.value;
      }
      return new HttpHeaders(resultPreservingCasing);
    }
  }
  exports.HttpHeaders = HttpHeaders;
});

// node_modules/@azure/core-http-compat/dist/commonjs/response.js
var require_response = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toPipelineResponse = exports.toCompatResponse = undefined;
  var core_rest_pipeline_1 = require_commonjs6();
  var util_js_1 = require_util();
  var originalResponse = Symbol("Original FullOperationResponse");
  function toCompatResponse(response, options) {
    let request = (0, util_js_1.toWebResourceLike)(response.request);
    let headers = (0, util_js_1.toHttpHeadersLike)(response.headers);
    if (options === null || options === undefined ? undefined : options.createProxy) {
      return new Proxy(response, {
        get(target, prop, receiver) {
          if (prop === "headers") {
            return headers;
          } else if (prop === "request") {
            return request;
          } else if (prop === originalResponse) {
            return response;
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (prop === "headers") {
            headers = value;
          } else if (prop === "request") {
            request = value;
          }
          return Reflect.set(target, prop, value, receiver);
        }
      });
    } else {
      return Object.assign(Object.assign({}, response), {
        request,
        headers
      });
    }
  }
  exports.toCompatResponse = toCompatResponse;
  function toPipelineResponse(compatResponse) {
    const extendedCompatResponse = compatResponse;
    const response = extendedCompatResponse[originalResponse];
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)(compatResponse.headers.toJson({ preserveCase: true }));
    if (response) {
      response.headers = headers;
      return response;
    } else {
      return Object.assign(Object.assign({}, compatResponse), { headers, request: (0, util_js_1.toPipelineRequest)(compatResponse.request) });
    }
  }
  exports.toPipelineResponse = toPipelineResponse;
});

// node_modules/@azure/core-http-compat/dist/commonjs/extendedClient.js
var require_extendedClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendedServiceClient = undefined;
  var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
  var core_rest_pipeline_1 = require_commonjs6();
  var core_client_1 = require_commonjs8();
  var response_js_1 = require_response();

  class ExtendedServiceClient extends core_client_1.ServiceClient {
    constructor(options) {
      var _a, _b;
      super(options);
      if (((_a = options.keepAliveOptions) === null || _a === undefined ? undefined : _a.enable) === false && !(0, disableKeepAlivePolicy_js_1.pipelineContainsDisableKeepAlivePolicy)(this.pipeline)) {
        this.pipeline.addPolicy((0, disableKeepAlivePolicy_js_1.createDisableKeepAlivePolicy)());
      }
      if (((_b = options.redirectOptions) === null || _b === undefined ? undefined : _b.handleRedirects) === false) {
        this.pipeline.removePolicy({
          name: core_rest_pipeline_1.redirectPolicyName
        });
      }
    }
    async sendOperationRequest(operationArguments, operationSpec) {
      var _a;
      const userProvidedCallBack = (_a = operationArguments === null || operationArguments === undefined ? undefined : operationArguments.options) === null || _a === undefined ? undefined : _a.onResponse;
      let lastResponse;
      function onResponse(rawResponse, flatResponse, error) {
        lastResponse = rawResponse;
        if (userProvidedCallBack) {
          userProvidedCallBack(rawResponse, flatResponse, error);
        }
      }
      operationArguments.options = Object.assign(Object.assign({}, operationArguments.options), { onResponse });
      const result = await super.sendOperationRequest(operationArguments, operationSpec);
      if (lastResponse) {
        Object.defineProperty(result, "_response", {
          value: (0, response_js_1.toCompatResponse)(lastResponse)
        });
      }
      return result;
    }
  }
  exports.ExtendedServiceClient = ExtendedServiceClient;
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/requestPolicyFactoryPolicy.js
var require_requestPolicyFactoryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createRequestPolicyFactoryPolicy = exports.requestPolicyFactoryPolicyName = exports.HttpPipelineLogLevel = undefined;
  var util_js_1 = require_util();
  var response_js_1 = require_response();
  var HttpPipelineLogLevel;
  (function(HttpPipelineLogLevel2) {
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["ERROR"] = 1] = "ERROR";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["INFO"] = 3] = "INFO";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["OFF"] = 0] = "OFF";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["WARNING"] = 2] = "WARNING";
  })(HttpPipelineLogLevel || (exports.HttpPipelineLogLevel = HttpPipelineLogLevel = {}));
  var mockRequestPolicyOptions = {
    log(_logLevel, _message) {
    },
    shouldLog(_logLevel) {
      return false;
    }
  };
  exports.requestPolicyFactoryPolicyName = "RequestPolicyFactoryPolicy";
  function createRequestPolicyFactoryPolicy(factories) {
    const orderedFactories = factories.slice().reverse();
    return {
      name: exports.requestPolicyFactoryPolicyName,
      async sendRequest(request, next) {
        let httpPipeline = {
          async sendRequest(httpRequest) {
            const response2 = await next((0, util_js_1.toPipelineRequest)(httpRequest));
            return (0, response_js_1.toCompatResponse)(response2, { createProxy: true });
          }
        };
        for (const factory of orderedFactories) {
          httpPipeline = factory.create(httpPipeline, mockRequestPolicyOptions);
        }
        const webResourceLike = (0, util_js_1.toWebResourceLike)(request, { createProxy: true });
        const response = await httpPipeline.sendRequest(webResourceLike);
        return (0, response_js_1.toPipelineResponse)(response);
      }
    };
  }
  exports.createRequestPolicyFactoryPolicy = createRequestPolicyFactoryPolicy;
});

// node_modules/@azure/core-http-compat/dist/commonjs/httpClientAdapter.js
var require_httpClientAdapter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertHttpClient = undefined;
  var response_js_1 = require_response();
  var util_js_1 = require_util();
  function convertHttpClient(requestPolicyClient) {
    return {
      sendRequest: async (request) => {
        const response = await requestPolicyClient.sendRequest((0, util_js_1.toWebResourceLike)(request, { createProxy: true }));
        return (0, response_js_1.toPipelineResponse)(response);
      }
    };
  }
  exports.convertHttpClient = convertHttpClient;
});

// node_modules/@azure/core-http-compat/dist/commonjs/index.js
var require_commonjs9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toHttpHeadersLike = exports.convertHttpClient = exports.disableKeepAlivePolicyName = exports.HttpPipelineLogLevel = exports.createRequestPolicyFactoryPolicy = exports.requestPolicyFactoryPolicyName = exports.ExtendedServiceClient = undefined;
  var extendedClient_js_1 = require_extendedClient();
  Object.defineProperty(exports, "ExtendedServiceClient", { enumerable: true, get: function() {
    return extendedClient_js_1.ExtendedServiceClient;
  } });
  var requestPolicyFactoryPolicy_js_1 = require_requestPolicyFactoryPolicy();
  Object.defineProperty(exports, "requestPolicyFactoryPolicyName", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.requestPolicyFactoryPolicyName;
  } });
  Object.defineProperty(exports, "createRequestPolicyFactoryPolicy", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.createRequestPolicyFactoryPolicy;
  } });
  Object.defineProperty(exports, "HttpPipelineLogLevel", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.HttpPipelineLogLevel;
  } });
  var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
  Object.defineProperty(exports, "disableKeepAlivePolicyName", { enumerable: true, get: function() {
    return disableKeepAlivePolicy_js_1.disableKeepAlivePolicyName;
  } });
  var httpClientAdapter_js_1 = require_httpClientAdapter();
  Object.defineProperty(exports, "convertHttpClient", { enumerable: true, get: function() {
    return httpClientAdapter_js_1.convertHttpClient;
  } });
  var util_js_1 = require_util();
  Object.defineProperty(exports, "toHttpHeadersLike", { enumerable: true, get: function() {
    return util_js_1.toHttpHeadersLike;
  } });
});

// node_modules/fast-xml-parser/src/util.js
var require_util2 = __commonJS((exports) => {
  var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
  var regexName = new RegExp("^" + nameRegexp + "$");
  var getAllMatches = function(string, regex) {
    const matches = [];
    let match = regex.exec(string);
    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      const len = match.length;
      for (let index = 0;index < len; index++) {
        allmatches.push(match[index]);
      }
      matches.push(allmatches);
      match = regex.exec(string);
    }
    return matches;
  };
  var isName = function(string) {
    const match = regexName.exec(string);
    return !(match === null || typeof match === "undefined");
  };
  exports.isExist = function(v) {
    return typeof v !== "undefined";
  };
  exports.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };
  exports.merge = function(target, a, arrayMode) {
    if (a) {
      const keys = Object.keys(a);
      const len = keys.length;
      for (let i = 0;i < len; i++) {
        if (arrayMode === "strict") {
          target[keys[i]] = [a[keys[i]]];
        } else {
          target[keys[i]] = a[keys[i]];
        }
      }
    }
  };
  exports.getValue = function(v) {
    if (exports.isExist(v)) {
      return v;
    } else {
      return "";
    }
  };
  exports.isName = isName;
  exports.getAllMatches = getAllMatches;
  exports.nameRegexp = nameRegexp;
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS((exports) => {
  var util = require_util2();
  var defaultOptions = {
    allowBooleanAttributes: false,
    unpairedTags: []
  };
  exports.validate = function(xmlData, options) {
    options = Object.assign({}, defaultOptions, options);
    const tags = [];
    let tagFound = false;
    let reachedRoot = false;
    if (xmlData[0] === "\uFEFF") {
      xmlData = xmlData.substr(1);
    }
    for (let i = 0;i < xmlData.length; i++) {
      if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
        i += 2;
        i = readPI(xmlData, i);
        if (i.err)
          return i;
      } else if (xmlData[i] === "<") {
        let tagStartPos = i;
        i++;
        if (xmlData[i] === "!") {
          i = readCommentAndCDATA(xmlData, i);
          continue;
        } else {
          let closingTag = false;
          if (xmlData[i] === "/") {
            closingTag = true;
            i++;
          }
          let tagName = "";
          for (;i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "\t" && xmlData[i] !== `
` && xmlData[i] !== "\r"; i++) {
            tagName += xmlData[i];
          }
          tagName = tagName.trim();
          if (tagName[tagName.length - 1] === "/") {
            tagName = tagName.substring(0, tagName.length - 1);
            i--;
          }
          if (!validateTagName(tagName)) {
            let msg;
            if (tagName.trim().length === 0) {
              msg = "Invalid space after '<'.";
            } else {
              msg = "Tag '" + tagName + "' is an invalid name.";
            }
            return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
          }
          const result = readAttributeStr(xmlData, i);
          if (result === false) {
            return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
          }
          let attrStr = result.value;
          i = result.index;
          if (attrStr[attrStr.length - 1] === "/") {
            const attrStrStart = i - attrStr.length;
            attrStr = attrStr.substring(0, attrStr.length - 1);
            const isValid = validateAttributeString(attrStr, options);
            if (isValid === true) {
              tagFound = true;
            } else {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
            }
          } else if (closingTag) {
            if (!result.tagClosed) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
            } else if (attrStr.trim().length > 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
            } else if (tags.length === 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
            } else {
              const otg = tags.pop();
              if (tagName !== otg.tagName) {
                let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
              }
              if (tags.length == 0) {
                reachedRoot = true;
              }
            }
          } else {
            const isValid = validateAttributeString(attrStr, options);
            if (isValid !== true) {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
            }
            if (reachedRoot === true) {
              return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
            } else if (options.unpairedTags.indexOf(tagName) !== -1) {
            } else {
              tags.push({ tagName, tagStartPos });
            }
            tagFound = true;
          }
          for (i++;i < xmlData.length; i++) {
            if (xmlData[i] === "<") {
              if (xmlData[i + 1] === "!") {
                i++;
                i = readCommentAndCDATA(xmlData, i);
                continue;
              } else if (xmlData[i + 1] === "?") {
                i = readPI(xmlData, ++i);
                if (i.err)
                  return i;
              } else {
                break;
              }
            } else if (xmlData[i] === "&") {
              const afterAmp = validateAmpersand(xmlData, i);
              if (afterAmp == -1)
                return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
              i = afterAmp;
            } else {
              if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
              }
            }
          }
          if (xmlData[i] === "<") {
            i--;
          }
        }
      } else {
        if (isWhiteSpace(xmlData[i])) {
          continue;
        }
        return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
      }
    }
    if (!tagFound) {
      return getErrorObject("InvalidXml", "Start tag expected.", 1);
    } else if (tags.length == 1) {
      return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    } else if (tags.length > 0) {
      return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
    }
    return true;
  };
  function isWhiteSpace(char) {
    return char === " " || char === "\t" || char === `
` || char === "\r";
  }
  function readPI(xmlData, i) {
    const start = i;
    for (;i < xmlData.length; i++) {
      if (xmlData[i] == "?" || xmlData[i] == " ") {
        const tagname = xmlData.substr(start, i - start);
        if (i > 5 && tagname === "xml") {
          return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
        } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
          i++;
          break;
        } else {
          continue;
        }
      }
    }
    return i;
  }
  function readCommentAndCDATA(xmlData, i) {
    if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
      for (i += 3;i < xmlData.length; i++) {
        if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
          i += 2;
          break;
        }
      }
    } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
      let angleBracketsCount = 1;
      for (i += 8;i < xmlData.length; i++) {
        if (xmlData[i] === "<") {
          angleBracketsCount++;
        } else if (xmlData[i] === ">") {
          angleBracketsCount--;
          if (angleBracketsCount === 0) {
            break;
          }
        }
      }
    } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
      for (i += 8;i < xmlData.length; i++) {
        if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
          i += 2;
          break;
        }
      }
    }
    return i;
  }
  var doubleQuote = '"';
  var singleQuote = "'";
  function readAttributeStr(xmlData, i) {
    let attrStr = "";
    let startChar = "";
    let tagClosed = false;
    for (;i < xmlData.length; i++) {
      if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
        if (startChar === "") {
          startChar = xmlData[i];
        } else if (startChar !== xmlData[i]) {
        } else {
          startChar = "";
        }
      } else if (xmlData[i] === ">") {
        if (startChar === "") {
          tagClosed = true;
          break;
        }
      }
      attrStr += xmlData[i];
    }
    if (startChar !== "") {
      return false;
    }
    return {
      value: attrStr,
      index: i,
      tagClosed
    };
  }
  var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
  function validateAttributeString(attrStr, options) {
    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
    const attrNames = {};
    for (let i = 0;i < matches.length; i++) {
      if (matches[i][1].length === 0) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
      } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
      } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
        return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
      }
      const attrName = matches[i][2];
      if (!validateAttrName(attrName)) {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
      }
      if (!attrNames.hasOwnProperty(attrName)) {
        attrNames[attrName] = 1;
      } else {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
      }
    }
    return true;
  }
  function validateNumberAmpersand(xmlData, i) {
    let re = /\d/;
    if (xmlData[i] === "x") {
      i++;
      re = /[\da-fA-F]/;
    }
    for (;i < xmlData.length; i++) {
      if (xmlData[i] === ";")
        return i;
      if (!xmlData[i].match(re))
        break;
    }
    return -1;
  }
  function validateAmpersand(xmlData, i) {
    i++;
    if (xmlData[i] === ";")
      return -1;
    if (xmlData[i] === "#") {
      i++;
      return validateNumberAmpersand(xmlData, i);
    }
    let count = 0;
    for (;i < xmlData.length; i++, count++) {
      if (xmlData[i].match(/\w/) && count < 20)
        continue;
      if (xmlData[i] === ";")
        break;
      return -1;
    }
    return i;
  }
  function getErrorObject(code, message, lineNumber) {
    return {
      err: {
        code,
        msg: message,
        line: lineNumber.line || lineNumber,
        col: lineNumber.col
      }
    };
  }
  function validateAttrName(attrName) {
    return util.isName(attrName);
  }
  function validateTagName(tagname) {
    return util.isName(tagname);
  }
  function getLineNumberForPosition(xmlData, index) {
    const lines = xmlData.substring(0, index).split(/\r?\n/);
    return {
      line: lines.length,
      col: lines[lines.length - 1].length + 1
    };
  }
  function getPositionFromMatch(match) {
    return match.startIndex + match[1].length;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS((exports) => {
  var defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    removeNSPrefix: false,
    allowBooleanAttributes: false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true,
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [],
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs) {
      return tagName;
    }
  };
  var buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
  };
  exports.buildOptions = buildOptions;
  exports.defaultOptions = defaultOptions;
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS((exports, module) => {
  class XmlNode {
    constructor(tagname) {
      this.tagname = tagname;
      this.child = [];
      this[":@"] = {};
    }
    add(key, val) {
      if (key === "__proto__")
        key = "#__proto__";
      this.child.push({ [key]: val });
    }
    addChild(node) {
      if (node.tagname === "__proto__")
        node.tagname = "#__proto__";
      if (node[":@"] && Object.keys(node[":@"]).length > 0) {
        this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
      } else {
        this.child.push({ [node.tagname]: node.child });
      }
    }
  }
  module.exports = XmlNode;
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS((exports, module) => {
  var util = require_util2();
  function readDocType(xmlData, i) {
    const entities = {};
    if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
      i = i + 9;
      let angleBracketsCount = 1;
      let hasBody = false, comment = false;
      let exp = "";
      for (;i < xmlData.length; i++) {
        if (xmlData[i] === "<" && !comment) {
          if (hasBody && isEntity(xmlData, i)) {
            i += 7;
            let entityName, val;
            [entityName, val, i] = readEntityExp(xmlData, i + 1);
            if (val.indexOf("&") === -1)
              entities[validateEntityName(entityName)] = {
                regx: RegExp(`&${entityName};`, "g"),
                val
              };
          } else if (hasBody && isElement(xmlData, i))
            i += 8;
          else if (hasBody && isAttlist(xmlData, i))
            i += 8;
          else if (hasBody && isNotation(xmlData, i))
            i += 9;
          else if (isComment)
            comment = true;
          else
            throw new Error("Invalid DOCTYPE");
          angleBracketsCount++;
          exp = "";
        } else if (xmlData[i] === ">") {
          if (comment) {
            if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
              comment = false;
              angleBracketsCount--;
            }
          } else {
            angleBracketsCount--;
          }
          if (angleBracketsCount === 0) {
            break;
          }
        } else if (xmlData[i] === "[") {
          hasBody = true;
        } else {
          exp += xmlData[i];
        }
      }
      if (angleBracketsCount !== 0) {
        throw new Error(`Unclosed DOCTYPE`);
      }
    } else {
      throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return { entities, i };
  }
  function readEntityExp(xmlData, i) {
    let entityName = "";
    for (;i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"'); i++) {
      entityName += xmlData[i];
    }
    entityName = entityName.trim();
    if (entityName.indexOf(" ") !== -1)
      throw new Error("External entites are not supported");
    const startChar = xmlData[i++];
    let val = "";
    for (;i < xmlData.length && xmlData[i] !== startChar; i++) {
      val += xmlData[i];
    }
    return [entityName, val, i];
  }
  function isComment(xmlData, i) {
    if (xmlData[i + 1] === "!" && xmlData[i + 2] === "-" && xmlData[i + 3] === "-")
      return true;
    return false;
  }
  function isEntity(xmlData, i) {
    if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y")
      return true;
    return false;
  }
  function isElement(xmlData, i) {
    if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T")
      return true;
    return false;
  }
  function isAttlist(xmlData, i) {
    if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T")
      return true;
    return false;
  }
  function isNotation(xmlData, i) {
    if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N")
      return true;
    return false;
  }
  function validateEntityName(name) {
    if (util.isName(name))
      return name;
    else
      throw new Error(`Invalid entity name ${name}`);
  }
  module.exports = readDocType;
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS((exports, module) => {
  var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
  var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
  if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
  }
  if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
  }
  var consider = {
    hex: true,
    leadingZeros: true,
    decimalPoint: ".",
    eNotation: true
  };
  function toNumber(str, options = {}) {
    options = Object.assign({}, consider, options);
    if (!str || typeof str !== "string")
      return str;
    let trimmedStr = str.trim();
    if (options.skipLike !== undefined && options.skipLike.test(trimmedStr))
      return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
      return Number.parseInt(trimmedStr, 16);
    } else {
      const match = numRegex.exec(trimmedStr);
      if (match) {
        const sign = match[1];
        const leadingZeros = match[2];
        let numTrimmedByZeros = trimZeros(match[3]);
        const eNotation = match[4] || match[6];
        if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
          return str;
        else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
          return str;
        else {
          const num = Number(trimmedStr);
          const numStr = "" + num;
          if (numStr.search(/[eE]/) !== -1) {
            if (options.eNotation)
              return num;
            else
              return str;
          } else if (eNotation) {
            if (options.eNotation)
              return num;
            else
              return str;
          } else if (trimmedStr.indexOf(".") !== -1) {
            if (numStr === "0" && numTrimmedByZeros === "")
              return num;
            else if (numStr === numTrimmedByZeros)
              return num;
            else if (sign && numStr === "-" + numTrimmedByZeros)
              return num;
            else
              return str;
          }
          if (leadingZeros) {
            if (numTrimmedByZeros === numStr)
              return num;
            else if (sign + numTrimmedByZeros === numStr)
              return num;
            else
              return str;
          }
          if (trimmedStr === numStr)
            return num;
          else if (trimmedStr === sign + numStr)
            return num;
          return str;
        }
      } else {
        return str;
      }
    }
  }
  function trimZeros(numStr) {
    if (numStr && numStr.indexOf(".") !== -1) {
      numStr = numStr.replace(/0+$/, "");
      if (numStr === ".")
        numStr = "0";
      else if (numStr[0] === ".")
        numStr = "0" + numStr;
      else if (numStr[numStr.length - 1] === ".")
        numStr = numStr.substr(0, numStr.length - 1);
      return numStr;
    }
    return numStr;
  }
  module.exports = toNumber;
});

// node_modules/fast-xml-parser/src/ignoreAttributes.js
var require_ignoreAttributes = __commonJS((exports, module) => {
  function getIgnoreAttributesFn(ignoreAttributes) {
    if (typeof ignoreAttributes === "function") {
      return ignoreAttributes;
    }
    if (Array.isArray(ignoreAttributes)) {
      return (attrName) => {
        for (const pattern of ignoreAttributes) {
          if (typeof pattern === "string" && attrName === pattern) {
            return true;
          }
          if (pattern instanceof RegExp && pattern.test(attrName)) {
            return true;
          }
        }
      };
    }
    return () => false;
  }
  module.exports = getIgnoreAttributesFn;
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS((exports, module) => {
  var util = require_util2();
  var xmlNode = require_xmlNode();
  var readDocType = require_DocTypeReader();
  var toNumber = require_strnum();
  var getIgnoreAttributesFn = require_ignoreAttributes();

  class OrderedObjParser {
    constructor(options) {
      this.options = options;
      this.currentNode = null;
      this.tagsNodeStack = [];
      this.docTypeEntities = {};
      this.lastEntities = {
        apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
        gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
        lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
        quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
      };
      this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
      this.htmlEntities = {
        space: { regex: /&(nbsp|#160);/g, val: " " },
        cent: { regex: /&(cent|#162);/g, val: "" },
        pound: { regex: /&(pound|#163);/g, val: "" },
        yen: { regex: /&(yen|#165);/g, val: "" },
        euro: { regex: /&(euro|#8364);/g, val: "" },
        copyright: { regex: /&(copy|#169);/g, val: "" },
        reg: { regex: /&(reg|#174);/g, val: "" },
        inr: { regex: /&(inr|#8377);/g, val: "" },
        num_dec: { regex: /&#([0-9]{1,7});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
        num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 16)) }
      };
      this.addExternalEntities = addExternalEntities;
      this.parseXml = parseXml;
      this.parseTextData = parseTextData;
      this.resolveNameSpace = resolveNameSpace;
      this.buildAttributesMap = buildAttributesMap;
      this.isItStopNode = isItStopNode;
      this.replaceEntitiesValue = replaceEntitiesValue;
      this.readStopNodeData = readStopNodeData;
      this.saveTextToParentTag = saveTextToParentTag;
      this.addChild = addChild;
      this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
    }
  }
  function addExternalEntities(externalEntities) {
    const entKeys = Object.keys(externalEntities);
    for (let i = 0;i < entKeys.length; i++) {
      const ent = entKeys[i];
      this.lastEntities[ent] = {
        regex: new RegExp("&" + ent + ";", "g"),
        val: externalEntities[ent]
      };
    }
  }
  function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
    if (val !== undefined) {
      if (this.options.trimValues && !dontTrim) {
        val = val.trim();
      }
      if (val.length > 0) {
        if (!escapeEntities)
          val = this.replaceEntitiesValue(val);
        const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
        if (newval === null || newval === undefined) {
          return val;
        } else if (typeof newval !== typeof val || newval !== val) {
          return newval;
        } else if (this.options.trimValues) {
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          const trimmedVal = val.trim();
          if (trimmedVal === val) {
            return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            return val;
          }
        }
      }
    }
  }
  function resolveNameSpace(tagname) {
    if (this.options.removeNSPrefix) {
      const tags = tagname.split(":");
      const prefix = tagname.charAt(0) === "/" ? "/" : "";
      if (tags[0] === "xmlns") {
        return "";
      }
      if (tags.length === 2) {
        tagname = prefix + tags[1];
      }
    }
    return tagname;
  }
  var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
  function buildAttributesMap(attrStr, jPath, tagName) {
    if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
      const matches = util.getAllMatches(attrStr, attrsRegx);
      const len = matches.length;
      const attrs = {};
      for (let i = 0;i < len; i++) {
        const attrName = this.resolveNameSpace(matches[i][1]);
        if (this.ignoreAttributesFn(attrName, jPath)) {
          continue;
        }
        let oldVal = matches[i][4];
        let aName = this.options.attributeNamePrefix + attrName;
        if (attrName.length) {
          if (this.options.transformAttributeName) {
            aName = this.options.transformAttributeName(aName);
          }
          if (aName === "__proto__")
            aName = "#__proto__";
          if (oldVal !== undefined) {
            if (this.options.trimValues) {
              oldVal = oldVal.trim();
            }
            oldVal = this.replaceEntitiesValue(oldVal);
            const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
            if (newVal === null || newVal === undefined) {
              attrs[aName] = oldVal;
            } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
              attrs[aName] = newVal;
            } else {
              attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
            }
          } else if (this.options.allowBooleanAttributes) {
            attrs[aName] = true;
          }
        }
      }
      if (!Object.keys(attrs).length) {
        return;
      }
      if (this.options.attributesGroupName) {
        const attrCollection = {};
        attrCollection[this.options.attributesGroupName] = attrs;
        return attrCollection;
      }
      return attrs;
    }
  }
  var parseXml = function(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, `
`);
    const xmlObj = new xmlNode("!xml");
    let currentNode = xmlObj;
    let textData = "";
    let jPath = "";
    for (let i = 0;i < xmlData.length; i++) {
      const ch = xmlData[i];
      if (ch === "<") {
        if (xmlData[i + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
          let tagName = xmlData.substring(i + 2, closeIndex).trim();
          if (this.options.removeNSPrefix) {
            const colonIndex = tagName.indexOf(":");
            if (colonIndex !== -1) {
              tagName = tagName.substr(colonIndex + 1);
            }
          }
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode) {
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
          }
          const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
          if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
            throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
          }
          let propIndex = 0;
          if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
            propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
            this.tagsNodeStack.pop();
          } else {
            propIndex = jPath.lastIndexOf(".");
          }
          jPath = jPath.substring(0, propIndex);
          currentNode = this.tagsNodeStack.pop();
          textData = "";
          i = closeIndex;
        } else if (xmlData[i + 1] === "?") {
          let tagData = readTagExp(xmlData, i, false, "?>");
          if (!tagData)
            throw new Error("Pi Tag is not closed.");
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
          } else {
            const childNode = new xmlNode(tagData.tagName);
            childNode.add(this.options.textNodeName, "");
            if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
            }
            this.addChild(currentNode, childNode, jPath);
          }
          i = tagData.closeIndex + 1;
        } else if (xmlData.substr(i + 1, 3) === "!--") {
          const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const comment = xmlData.substring(i + 4, endIndex - 2);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
          }
          i = endIndex;
        } else if (xmlData.substr(i + 1, 2) === "!D") {
          const result = readDocType(xmlData, i);
          this.docTypeEntities = result.entities;
          i = result.i;
        } else if (xmlData.substr(i + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
          const tagExp = xmlData.substring(i + 9, closeIndex);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
          if (val == undefined)
            val = "";
          if (this.options.cdataPropName) {
            currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
          } else {
            currentNode.add(this.options.textNodeName, val);
          }
          i = closeIndex + 2;
        } else {
          let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
          let tagName = result.tagName;
          const rawTagName = result.rawTagName;
          let tagExp = result.tagExp;
          let attrExpPresent = result.attrExpPresent;
          let closeIndex = result.closeIndex;
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode && textData) {
            if (currentNode.tagname !== "!xml") {
              textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
            }
          }
          const lastTag = currentNode;
          if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
            currentNode = this.tagsNodeStack.pop();
            jPath = jPath.substring(0, jPath.lastIndexOf("."));
          }
          if (tagName !== xmlObj.tagname) {
            jPath += jPath ? "." + tagName : tagName;
          }
          if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
            let tagContent = "";
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              i = result.closeIndex;
            } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
              i = result.closeIndex;
            } else {
              const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
              if (!result2)
                throw new Error(`Unexpected end of ${rawTagName}`);
              i = result2.i;
              tagContent = result2.tagContent;
            }
            const childNode = new xmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            if (tagContent) {
              tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            childNode.add(this.options.textNodeName, tagContent);
            this.addChild(currentNode, childNode, jPath);
          } else {
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
            } else {
              const childNode = new xmlNode(tagName);
              this.tagsNodeStack.push(currentNode);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              currentNode = childNode;
            }
            textData = "";
            i = closeIndex;
          }
        }
      } else {
        textData += xmlData[i];
      }
    }
    return xmlObj.child;
  };
  function addChild(currentNode, childNode, jPath) {
    const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
    if (result === false) {
    } else if (typeof result === "string") {
      childNode.tagname = result;
      currentNode.addChild(childNode);
    } else {
      currentNode.addChild(childNode);
    }
  }
  var replaceEntitiesValue = function(val) {
    if (this.options.processEntities) {
      for (let entityName in this.docTypeEntities) {
        const entity = this.docTypeEntities[entityName];
        val = val.replace(entity.regx, entity.val);
      }
      for (let entityName in this.lastEntities) {
        const entity = this.lastEntities[entityName];
        val = val.replace(entity.regex, entity.val);
      }
      if (this.options.htmlEntities) {
        for (let entityName in this.htmlEntities) {
          const entity = this.htmlEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
      }
      val = val.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return val;
  };
  function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
    if (textData) {
      if (isLeafNode === undefined)
        isLeafNode = Object.keys(currentNode.child).length === 0;
      textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
      if (textData !== undefined && textData !== "")
        currentNode.add(this.options.textNodeName, textData);
      textData = "";
    }
    return textData;
  }
  function isItStopNode(stopNodes, jPath, currentTagName) {
    const allNodesExp = "*." + currentTagName;
    for (const stopNodePath in stopNodes) {
      const stopNodeExp = stopNodes[stopNodePath];
      if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
        return true;
    }
    return false;
  }
  function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
    let attrBoundary;
    let tagExp = "";
    for (let index = i;index < xmlData.length; index++) {
      let ch = xmlData[index];
      if (attrBoundary) {
        if (ch === attrBoundary)
          attrBoundary = "";
      } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
      } else if (ch === closingChar[0]) {
        if (closingChar[1]) {
          if (xmlData[index + 1] === closingChar[1]) {
            return {
              data: tagExp,
              index
            };
          }
        } else {
          return {
            data: tagExp,
            index
          };
        }
      } else if (ch === "\t") {
        ch = " ";
      }
      tagExp += ch;
    }
  }
  function findClosingIndex(xmlData, str, i, errMsg) {
    const closingIndex = xmlData.indexOf(str, i);
    if (closingIndex === -1) {
      throw new Error(errMsg);
    } else {
      return closingIndex + str.length - 1;
    }
  }
  function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
    const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
    if (!result)
      return;
    let tagExp = result.data;
    const closeIndex = result.index;
    const separatorIndex = tagExp.search(/\s/);
    let tagName = tagExp;
    let attrExpPresent = true;
    if (separatorIndex !== -1) {
      tagName = tagExp.substring(0, separatorIndex);
      tagExp = tagExp.substring(separatorIndex + 1).trimStart();
    }
    const rawTagName = tagName;
    if (removeNSPrefix) {
      const colonIndex = tagName.indexOf(":");
      if (colonIndex !== -1) {
        tagName = tagName.substr(colonIndex + 1);
        attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
      }
    }
    return {
      tagName,
      tagExp,
      closeIndex,
      attrExpPresent,
      rawTagName
    };
  }
  function readStopNodeData(xmlData, tagName, i) {
    const startIndex = i;
    let openTagCount = 1;
    for (;i < xmlData.length; i++) {
      if (xmlData[i] === "<") {
        if (xmlData[i + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
          if (closeTagName === tagName) {
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i: closeIndex
              };
            }
          }
          i = closeIndex;
        } else if (xmlData[i + 1] === "?") {
          const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
          i = closeIndex;
        } else if (xmlData.substr(i + 1, 3) === "!--") {
          const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
          i = closeIndex;
        } else if (xmlData.substr(i + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i = closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, ">");
          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
              openTagCount++;
            }
            i = tagData.closeIndex;
          }
        }
      }
    }
  }
  function parseValue(val, shouldParse, options) {
    if (shouldParse && typeof val === "string") {
      const newval = val.trim();
      if (newval === "true")
        return true;
      else if (newval === "false")
        return false;
      else
        return toNumber(val, options);
    } else {
      if (util.isExist(val)) {
        return val;
      } else {
        return "";
      }
    }
  }
  module.exports = OrderedObjParser;
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS((exports) => {
  function prettify(node, options) {
    return compress(node, options);
  }
  function compress(arr, options, jPath) {
    let text;
    const compressedObj = {};
    for (let i = 0;i < arr.length; i++) {
      const tagObj = arr[i];
      const property = propName(tagObj);
      let newJpath = "";
      if (jPath === undefined)
        newJpath = property;
      else
        newJpath = jPath + "." + property;
      if (property === options.textNodeName) {
        if (text === undefined)
          text = tagObj[property];
        else
          text += "" + tagObj[property];
      } else if (property === undefined) {
        continue;
      } else if (tagObj[property]) {
        let val = compress(tagObj[property], options, newJpath);
        const isLeaf = isLeafTag(val, options);
        if (tagObj[":@"]) {
          assignAttributes(val, tagObj[":@"], newJpath, options);
        } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {
          val = val[options.textNodeName];
        } else if (Object.keys(val).length === 0) {
          if (options.alwaysCreateTextNode)
            val[options.textNodeName] = "";
          else
            val = "";
        }
        if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
          if (!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [compressedObj[property]];
          }
          compressedObj[property].push(val);
        } else {
          if (options.isArray(property, newJpath, isLeaf)) {
            compressedObj[property] = [val];
          } else {
            compressedObj[property] = val;
          }
        }
      }
    }
    if (typeof text === "string") {
      if (text.length > 0)
        compressedObj[options.textNodeName] = text;
    } else if (text !== undefined)
      compressedObj[options.textNodeName] = text;
    return compressedObj;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0;i < keys.length; i++) {
      const key = keys[i];
      if (key !== ":@")
        return key;
    }
  }
  function assignAttributes(obj, attrMap, jpath, options) {
    if (attrMap) {
      const keys = Object.keys(attrMap);
      const len = keys.length;
      for (let i = 0;i < len; i++) {
        const atrrName = keys[i];
        if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
          obj[atrrName] = [attrMap[atrrName]];
        } else {
          obj[atrrName] = attrMap[atrrName];
        }
      }
    }
  }
  function isLeafTag(obj, options) {
    const { textNodeName } = options;
    const propCount = Object.keys(obj).length;
    if (propCount === 0) {
      return true;
    }
    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
      return true;
    }
    return false;
  }
  exports.prettify = prettify;
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS((exports, module) => {
  var { buildOptions } = require_OptionsBuilder();
  var OrderedObjParser = require_OrderedObjParser();
  var { prettify } = require_node2json();
  var validator = require_validator();

  class XMLParser {
    constructor(options) {
      this.externalEntities = {};
      this.options = buildOptions(options);
    }
    parse(xmlData, validationOption) {
      if (typeof xmlData === "string") {
      } else if (xmlData.toString) {
        xmlData = xmlData.toString();
      } else {
        throw new Error("XML data is accepted in String or Bytes[] form.");
      }
      if (validationOption) {
        if (validationOption === true)
          validationOption = {};
        const result = validator.validate(xmlData, validationOption);
        if (result !== true) {
          throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
        }
      }
      const orderedObjParser = new OrderedObjParser(this.options);
      orderedObjParser.addExternalEntities(this.externalEntities);
      const orderedResult = orderedObjParser.parseXml(xmlData);
      if (this.options.preserveOrder || orderedResult === undefined)
        return orderedResult;
      else
        return prettify(orderedResult, this.options);
    }
    addEntity(key, value) {
      if (value.indexOf("&") !== -1) {
        throw new Error("Entity value can't have '&'");
      } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      } else if (value === "&") {
        throw new Error("An entity with value '&' is not permitted");
      } else {
        this.externalEntities[key] = value;
      }
    }
  }
  module.exports = XMLParser;
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS((exports, module) => {
  var EOL = `
`;
  function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
      indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
  }
  function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;
    for (let i = 0;i < arr.length; i++) {
      const tagObj = arr[i];
      const tagName = propName(tagObj);
      if (tagName === undefined)
        continue;
      let newJPath = "";
      if (jPath.length === 0)
        newJPath = tagName;
      else
        newJPath = `${jPath}.${tagName}`;
      if (tagName === options.textNodeName) {
        let tagText = tagObj[tagName];
        if (!isStopNode(newJPath, options)) {
          tagText = options.tagValueProcessor(tagName, tagText);
          tagText = replaceEntitiesValue(tagText, options);
        }
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += tagText;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options.cdataPropName) {
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options.commentPropName) {
        xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
        isPreviousElementTag = true;
        continue;
      } else if (tagName[0] === "?") {
        const attStr2 = attr_to_str(tagObj[":@"], options);
        const tempInd = tagName === "?xml" ? "" : indentation;
        let piTextNodeName = tagObj[tagName][0][options.textNodeName];
        piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
        xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
        isPreviousElementTag = true;
        continue;
      }
      let newIdentation = indentation;
      if (newIdentation !== "") {
        newIdentation += options.indentBy;
      }
      const attStr = attr_to_str(tagObj[":@"], options);
      const tagStart = indentation + `<${tagName}${attStr}`;
      const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
      if (options.unpairedTags.indexOf(tagName) !== -1) {
        if (options.suppressUnpairedNode)
          xmlStr += tagStart + ">";
        else
          xmlStr += tagStart + "/>";
      } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
        xmlStr += tagStart + "/>";
      } else if (tagValue && tagValue.endsWith(">")) {
        xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
      } else {
        xmlStr += tagStart + ">";
        if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
          xmlStr += indentation + options.indentBy + tagValue + indentation;
        } else {
          xmlStr += tagValue;
        }
        xmlStr += `</${tagName}>`;
      }
      isPreviousElementTag = true;
    }
    return xmlStr;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0;i < keys.length; i++) {
      const key = keys[i];
      if (!obj.hasOwnProperty(key))
        continue;
      if (key !== ":@")
        return key;
    }
  }
  function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
      for (let attr in attrMap) {
        if (!attrMap.hasOwnProperty(attr))
          continue;
        let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
        attrVal = replaceEntitiesValue(attrVal, options);
        if (attrVal === true && options.suppressBooleanAttributes) {
          attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
        } else {
          attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
        }
      }
    }
    return attrStr;
  }
  function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
      if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
        return true;
    }
    return false;
  }
  function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
      for (let i = 0;i < options.entities.length; i++) {
        const entity = options.entities[i];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  }
  module.exports = toXml;
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS((exports, module) => {
  var buildFromOrderedJs = require_orderedJs2Xml();
  var getIgnoreAttributesFn = require_ignoreAttributes();
  var defaultOptions = {
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    cdataPropName: false,
    format: false,
    indentBy: "  ",
    suppressEmptyNode: false,
    suppressUnpairedNode: true,
    suppressBooleanAttributes: true,
    tagValueProcessor: function(key, a) {
      return a;
    },
    attributeValueProcessor: function(attrName, a) {
      return a;
    },
    preserveOrder: false,
    commentPropName: false,
    unpairedTags: [],
    entities: [
      { regex: new RegExp("&", "g"), val: "&amp;" },
      { regex: new RegExp(">", "g"), val: "&gt;" },
      { regex: new RegExp("<", "g"), val: "&lt;" },
      { regex: new RegExp("'", "g"), val: "&apos;" },
      { regex: new RegExp('"', "g"), val: "&quot;" }
    ],
    processEntities: true,
    stopNodes: [],
    oneListGroup: false
  };
  function Builder(options) {
    this.options = Object.assign({}, defaultOptions, options);
    if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
      this.isAttribute = function() {
        return false;
      };
    } else {
      this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
      this.attrPrefixLen = this.options.attributeNamePrefix.length;
      this.isAttribute = isAttribute;
    }
    this.processTextOrObjNode = processTextOrObjNode;
    if (this.options.format) {
      this.indentate = indentate;
      this.tagEndChar = `>
`;
      this.newLine = `
`;
    } else {
      this.indentate = function() {
        return "";
      };
      this.tagEndChar = ">";
      this.newLine = "";
    }
  }
  Builder.prototype.build = function(jObj) {
    if (this.options.preserveOrder) {
      return buildFromOrderedJs(jObj, this.options);
    } else {
      if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
        jObj = {
          [this.options.arrayNodeName]: jObj
        };
      }
      return this.j2x(jObj, 0, []).val;
    }
  };
  Builder.prototype.j2x = function(jObj, level, ajPath) {
    let attrStr = "";
    let val = "";
    const jPath = ajPath.join(".");
    for (let key in jObj) {
      if (!Object.prototype.hasOwnProperty.call(jObj, key))
        continue;
      if (typeof jObj[key] === "undefined") {
        if (this.isAttribute(key)) {
          val += "";
        }
      } else if (jObj[key] === null) {
        if (this.isAttribute(key)) {
          val += "";
        } else if (key[0] === "?") {
          val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
        } else {
          val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        }
      } else if (jObj[key] instanceof Date) {
        val += this.buildTextValNode(jObj[key], key, "", level);
      } else if (typeof jObj[key] !== "object") {
        const attr = this.isAttribute(key);
        if (attr && !this.ignoreAttributesFn(attr, jPath)) {
          attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
        } else if (!attr) {
          if (key === this.options.textNodeName) {
            let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
            val += this.replaceEntitiesValue(newval);
          } else {
            val += this.buildTextValNode(jObj[key], key, "", level);
          }
        }
      } else if (Array.isArray(jObj[key])) {
        const arrLen = jObj[key].length;
        let listTagVal = "";
        let listTagAttr = "";
        for (let j = 0;j < arrLen; j++) {
          const item = jObj[key][j];
          if (typeof item === "undefined") {
          } else if (item === null) {
            if (key[0] === "?")
              val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (typeof item === "object") {
            if (this.options.oneListGroup) {
              const result = this.j2x(item, level + 1, ajPath.concat(key));
              listTagVal += result.val;
              if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                listTagAttr += result.attrStr;
              }
            } else {
              listTagVal += this.processTextOrObjNode(item, key, level, ajPath);
            }
          } else {
            if (this.options.oneListGroup) {
              let textValue = this.options.tagValueProcessor(key, item);
              textValue = this.replaceEntitiesValue(textValue);
              listTagVal += textValue;
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
        }
        if (this.options.oneListGroup) {
          listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
        }
        val += listTagVal;
      } else {
        if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
          const Ks = Object.keys(jObj[key]);
          const L = Ks.length;
          for (let j = 0;j < L; j++) {
            attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
          }
        } else {
          val += this.processTextOrObjNode(jObj[key], key, level, ajPath);
        }
      }
    }
    return { attrStr, val };
  };
  Builder.prototype.buildAttrPairStr = function(attrName, val) {
    val = this.options.attributeValueProcessor(attrName, "" + val);
    val = this.replaceEntitiesValue(val);
    if (this.options.suppressBooleanAttributes && val === "true") {
      return " " + attrName;
    } else
      return " " + attrName + '="' + val + '"';
  };
  function processTextOrObjNode(object, key, level, ajPath) {
    const result = this.j2x(object, level + 1, ajPath.concat(key));
    if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
      return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
    } else {
      return this.buildObjectNode(result.val, key, result.attrStr, level);
    }
  }
  Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
    if (val === "") {
      if (key[0] === "?")
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      else {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      }
    } else {
      let tagEndExp = "</" + key + this.tagEndChar;
      let piClosingChar = "";
      if (key[0] === "?") {
        piClosingChar = "?";
        tagEndExp = "";
      }
      if ((attrStr || attrStr === "") && val.indexOf("<") === -1) {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
      }
    }
  };
  Builder.prototype.closeTag = function(key) {
    let closeTag = "";
    if (this.options.unpairedTags.indexOf(key) !== -1) {
      if (!this.options.suppressUnpairedNode)
        closeTag = "/";
    } else if (this.options.suppressEmptyNode) {
      closeTag = "/";
    } else {
      closeTag = `></${key}`;
    }
    return closeTag;
  };
  Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
    if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
      return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    } else if (key[0] === "?") {
      return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    } else {
      let textValue = this.options.tagValueProcessor(key, val);
      textValue = this.replaceEntitiesValue(textValue);
      if (textValue === "") {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      } else {
        return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
      }
    }
  };
  Builder.prototype.replaceEntitiesValue = function(textValue) {
    if (textValue && textValue.length > 0 && this.options.processEntities) {
      for (let i = 0;i < this.options.entities.length; i++) {
        const entity = this.options.entities[i];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  };
  function indentate(level) {
    return this.options.indentBy.repeat(level);
  }
  function isAttribute(name) {
    if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
      return name.substr(this.attrPrefixLen);
    } else {
      return false;
    }
  }
  module.exports = Builder;
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS((exports, module) => {
  var validator = require_validator();
  var XMLParser = require_XMLParser();
  var XMLBuilder = require_json2xml();
  module.exports = {
    XMLParser,
    XMLValidator: validator,
    XMLBuilder
  };
});

// node_modules/@azure/core-xml/dist/commonjs/xml.common.js
var require_xml_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = undefined;
  exports.XML_ATTRKEY = "$";
  exports.XML_CHARKEY = "_";
});

// node_modules/@azure/core-xml/dist/commonjs/xml.js
var require_xml = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringifyXML = stringifyXML;
  exports.parseXML = parseXML;
  var fast_xml_parser_1 = require_fxp();
  var xml_common_js_1 = require_xml_common();
  function getCommonOptions(options) {
    var _a;
    return {
      attributesGroupName: xml_common_js_1.XML_ATTRKEY,
      textNodeName: (_a = options.xmlCharKey) !== null && _a !== undefined ? _a : xml_common_js_1.XML_CHARKEY,
      ignoreAttributes: false,
      suppressBooleanAttributes: false
    };
  }
  function getSerializerOptions(options = {}) {
    var _a, _b;
    return Object.assign(Object.assign({}, getCommonOptions(options)), { attributeNamePrefix: "@_", format: true, suppressEmptyNode: true, indentBy: "", rootNodeName: (_a = options.rootName) !== null && _a !== undefined ? _a : "root", cdataPropName: (_b = options.cdataPropName) !== null && _b !== undefined ? _b : "__cdata" });
  }
  function getParserOptions(options = {}) {
    return Object.assign(Object.assign({}, getCommonOptions(options)), { parseAttributeValue: false, parseTagValue: false, attributeNamePrefix: "", stopNodes: options.stopNodes, processEntities: true });
  }
  function stringifyXML(obj, opts = {}) {
    const parserOptions = getSerializerOptions(opts);
    const j2x = new fast_xml_parser_1.XMLBuilder(parserOptions);
    const node = { [parserOptions.rootNodeName]: obj };
    const xmlData = j2x.build(node);
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${xmlData}`.replace(/\n/g, "");
  }
  async function parseXML(str, opts = {}) {
    if (!str) {
      throw new Error("Document is empty");
    }
    const validation = fast_xml_parser_1.XMLValidator.validate(str);
    if (validation !== true) {
      throw validation;
    }
    const parser = new fast_xml_parser_1.XMLParser(getParserOptions(opts));
    const parsedXml = parser.parse(str);
    if (parsedXml["?xml"]) {
      delete parsedXml["?xml"];
    }
    if (!opts.includeRoot) {
      for (const key of Object.keys(parsedXml)) {
        const value = parsedXml[key];
        return typeof value === "object" ? Object.assign({}, value) : value;
      }
    }
    return parsedXml;
  }
});

// node_modules/@azure/core-xml/dist/commonjs/index.js
var require_commonjs10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.parseXML = exports.stringifyXML = undefined;
  var xml_js_1 = require_xml();
  Object.defineProperty(exports, "stringifyXML", { enumerable: true, get: function() {
    return xml_js_1.stringifyXML;
  } });
  Object.defineProperty(exports, "parseXML", { enumerable: true, get: function() {
    return xml_js_1.parseXML;
  } });
  var xml_common_js_1 = require_xml_common();
  Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
    return xml_common_js_1.XML_ATTRKEY;
  } });
  Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
    return xml_common_js_1.XML_CHARKEY;
  } });
});

// node_modules/@azure/storage-blob/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;

  class AbortError extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError;
});

// node_modules/@azure/storage-blob/node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;
  var AbortError_js_1 = require_AbortError3();
  Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
    return AbortError_js_1.AbortError;
  } });
});

// node_modules/@azure/core-lro/dist/commonjs/logger.js
var require_logger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs();
  exports.logger = (0, logger_1.createClientLogger)("core-lro");
});

// node_modules/@azure/core-lro/dist/commonjs/poller/constants.js
var require_constants3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.terminalStates = exports.POLL_INTERVAL_IN_MS = undefined;
  exports.POLL_INTERVAL_IN_MS = 2000;
  exports.terminalStates = ["succeeded", "canceled", "failed"];
});

// node_modules/@azure/core-lro/dist/commonjs/poller/operation.js
var require_operation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollOperation = exports.initOperation = exports.deserializeState = undefined;
  var logger_js_1 = require_logger();
  var constants_js_1 = require_constants3();
  function deserializeState(serializedState) {
    try {
      return JSON.parse(serializedState).state;
    } catch (e) {
      throw new Error(`Unable to deserialize input state: ${serializedState}`);
    }
  }
  exports.deserializeState = deserializeState;
  function setStateError(inputs) {
    const { state, stateProxy, isOperationError } = inputs;
    return (error) => {
      if (isOperationError(error)) {
        stateProxy.setError(state, error);
        stateProxy.setFailed(state);
      }
      throw error;
    };
  }
  function appendReadableErrorMessage(currentMessage, innerMessage) {
    let message = currentMessage;
    if (message.slice(-1) !== ".") {
      message = message + ".";
    }
    return message + " " + innerMessage;
  }
  function simplifyError(err) {
    let message = err.message;
    let code = err.code;
    let curErr = err;
    while (curErr.innererror) {
      curErr = curErr.innererror;
      code = curErr.code;
      message = appendReadableErrorMessage(message, curErr.message);
    }
    return {
      code,
      message
    };
  }
  function processOperationStatus(result) {
    const { state, stateProxy, status, isDone, processResult, getError, response, setErrorAsResult } = result;
    switch (status) {
      case "succeeded": {
        stateProxy.setSucceeded(state);
        break;
      }
      case "failed": {
        const err = getError === null || getError === undefined ? undefined : getError(response);
        let postfix = "";
        if (err) {
          const { code, message } = simplifyError(err);
          postfix = `. ${code}. ${message}`;
        }
        const errStr = `The long-running operation has failed${postfix}`;
        stateProxy.setError(state, new Error(errStr));
        stateProxy.setFailed(state);
        logger_js_1.logger.warning(errStr);
        break;
      }
      case "canceled": {
        stateProxy.setCanceled(state);
        break;
      }
    }
    if ((isDone === null || isDone === undefined ? undefined : isDone(response, state)) || isDone === undefined && ["succeeded", "canceled"].concat(setErrorAsResult ? [] : ["failed"]).includes(status)) {
      stateProxy.setResult(state, buildResult({
        response,
        state,
        processResult
      }));
    }
  }
  function buildResult(inputs) {
    const { processResult, response, state } = inputs;
    return processResult ? processResult(response, state) : response;
  }
  async function initOperation(inputs) {
    const { init, stateProxy, processResult, getOperationStatus, withOperationLocation, setErrorAsResult } = inputs;
    const { operationLocation, resourceLocation, metadata, response } = await init();
    if (operationLocation)
      withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(operationLocation, false);
    const config = {
      metadata,
      operationLocation,
      resourceLocation
    };
    logger_js_1.logger.verbose(`LRO: Operation description:`, config);
    const state = stateProxy.initState(config);
    const status = getOperationStatus({ response, state, operationLocation });
    processOperationStatus({ state, status, stateProxy, response, setErrorAsResult, processResult });
    return state;
  }
  exports.initOperation = initOperation;
  async function pollOperationHelper(inputs) {
    const { poll, state, stateProxy, operationLocation, getOperationStatus, getResourceLocation, isOperationError, options } = inputs;
    const response = await poll(operationLocation, options).catch(setStateError({
      state,
      stateProxy,
      isOperationError
    }));
    const status = getOperationStatus(response, state);
    logger_js_1.logger.verbose(`LRO: Status:
\tPolling from: ${state.config.operationLocation}
\tOperation status: ${status}
\tPolling status: ${constants_js_1.terminalStates.includes(status) ? "Stopped" : "Running"}`);
    if (status === "succeeded") {
      const resourceLocation = getResourceLocation(response, state);
      if (resourceLocation !== undefined) {
        return {
          response: await poll(resourceLocation).catch(setStateError({ state, stateProxy, isOperationError })),
          status
        };
      }
    }
    return { response, status };
  }
  async function pollOperation(inputs) {
    const { poll, state, stateProxy, options, getOperationStatus, getResourceLocation, getOperationLocation, isOperationError, withOperationLocation, getPollingInterval, processResult, getError, updateState, setDelay, isDone, setErrorAsResult } = inputs;
    const { operationLocation } = state.config;
    if (operationLocation !== undefined) {
      const { response, status } = await pollOperationHelper({
        poll,
        getOperationStatus,
        state,
        stateProxy,
        operationLocation,
        getResourceLocation,
        isOperationError,
        options
      });
      processOperationStatus({
        status,
        response,
        state,
        stateProxy,
        isDone,
        processResult,
        getError,
        setErrorAsResult
      });
      if (!constants_js_1.terminalStates.includes(status)) {
        const intervalInMs = getPollingInterval === null || getPollingInterval === undefined ? undefined : getPollingInterval(response);
        if (intervalInMs)
          setDelay(intervalInMs);
        const location = getOperationLocation === null || getOperationLocation === undefined ? undefined : getOperationLocation(response, state);
        if (location !== undefined) {
          const isUpdated = operationLocation !== location;
          state.config.operationLocation = location;
          withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(location, isUpdated);
        } else
          withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(operationLocation, false);
      }
      updateState === null || updateState === undefined || updateState(state, response);
    }
  }
  exports.pollOperation = pollOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/http/operation.js
var require_operation2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollHttpOperation = exports.isOperationError = exports.getResourceLocation = exports.getOperationStatus = exports.getOperationLocation = exports.initHttpOperation = exports.getStatusFromInitialResponse = exports.getErrorFromResponse = exports.parseRetryAfter = exports.inferLroMode = undefined;
  var operation_js_1 = require_operation();
  var logger_js_1 = require_logger();
  function getOperationLocationPollingUrl(inputs) {
    const { azureAsyncOperation, operationLocation } = inputs;
    return operationLocation !== null && operationLocation !== undefined ? operationLocation : azureAsyncOperation;
  }
  function getLocationHeader(rawResponse) {
    return rawResponse.headers["location"];
  }
  function getOperationLocationHeader(rawResponse) {
    return rawResponse.headers["operation-location"];
  }
  function getAzureAsyncOperationHeader(rawResponse) {
    return rawResponse.headers["azure-asyncoperation"];
  }
  function findResourceLocation(inputs) {
    var _a;
    const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;
    switch (requestMethod) {
      case "PUT": {
        return requestPath;
      }
      case "DELETE": {
        return;
      }
      case "PATCH": {
        return (_a = getDefault()) !== null && _a !== undefined ? _a : requestPath;
      }
      default: {
        return getDefault();
      }
    }
    function getDefault() {
      switch (resourceLocationConfig) {
        case "azure-async-operation": {
          return;
        }
        case "original-uri": {
          return requestPath;
        }
        case "location":
        default: {
          return location;
        }
      }
    }
  }
  function inferLroMode(inputs) {
    const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;
    const operationLocation = getOperationLocationHeader(rawResponse);
    const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);
    const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });
    const location = getLocationHeader(rawResponse);
    const normalizedRequestMethod = requestMethod === null || requestMethod === undefined ? undefined : requestMethod.toLocaleUpperCase();
    if (pollingUrl !== undefined) {
      return {
        mode: "OperationLocation",
        operationLocation: pollingUrl,
        resourceLocation: findResourceLocation({
          requestMethod: normalizedRequestMethod,
          location,
          requestPath,
          resourceLocationConfig
        })
      };
    } else if (location !== undefined) {
      return {
        mode: "ResourceLocation",
        operationLocation: location
      };
    } else if (normalizedRequestMethod === "PUT" && requestPath) {
      return {
        mode: "Body",
        operationLocation: requestPath
      };
    } else {
      return;
    }
  }
  exports.inferLroMode = inferLroMode;
  function transformStatus(inputs) {
    const { status, statusCode } = inputs;
    if (typeof status !== "string" && status !== undefined) {
      throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);
    }
    switch (status === null || status === undefined ? undefined : status.toLocaleLowerCase()) {
      case undefined:
        return toOperationStatus(statusCode);
      case "succeeded":
        return "succeeded";
      case "failed":
        return "failed";
      case "running":
      case "accepted":
      case "started":
      case "canceling":
      case "cancelling":
        return "running";
      case "canceled":
      case "cancelled":
        return "canceled";
      default: {
        logger_js_1.logger.verbose(`LRO: unrecognized operation status: ${status}`);
        return status;
      }
    }
  }
  function getStatus(rawResponse) {
    var _a;
    const { status } = (_a = rawResponse.body) !== null && _a !== undefined ? _a : {};
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function getProvisioningState(rawResponse) {
    var _a, _b;
    const { properties, provisioningState } = (_a = rawResponse.body) !== null && _a !== undefined ? _a : {};
    const status = (_b = properties === null || properties === undefined ? undefined : properties.provisioningState) !== null && _b !== undefined ? _b : provisioningState;
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function toOperationStatus(statusCode) {
    if (statusCode === 202) {
      return "running";
    } else if (statusCode < 300) {
      return "succeeded";
    } else {
      return "failed";
    }
  }
  function parseRetryAfter({ rawResponse }) {
    const retryAfter = rawResponse.headers["retry-after"];
    if (retryAfter !== undefined) {
      const retryAfterInSeconds = parseInt(retryAfter);
      return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1000;
    }
    return;
  }
  exports.parseRetryAfter = parseRetryAfter;
  function getErrorFromResponse(response) {
    const error = accessBodyProperty(response, "error");
    if (!error) {
      logger_js_1.logger.warning(`The long-running operation failed but there is no error property in the response's body`);
      return;
    }
    if (!error.code || !error.message) {
      logger_js_1.logger.warning(`The long-running operation failed but the error property in the response's body doesn't contain code or message`);
      return;
    }
    return error;
  }
  exports.getErrorFromResponse = getErrorFromResponse;
  function calculatePollingIntervalFromDate(retryAfterDate) {
    const timeNow = Math.floor(new Date().getTime());
    const retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime) {
      return retryAfterTime - timeNow;
    }
    return;
  }
  function getStatusFromInitialResponse(inputs) {
    const { response, state, operationLocation } = inputs;
    function helper() {
      var _a;
      const mode = (_a = state.config.metadata) === null || _a === undefined ? undefined : _a["mode"];
      switch (mode) {
        case undefined:
          return toOperationStatus(response.rawResponse.statusCode);
        case "Body":
          return getOperationStatus(response, state);
        default:
          return "running";
      }
    }
    const status = helper();
    return status === "running" && operationLocation === undefined ? "succeeded" : status;
  }
  exports.getStatusFromInitialResponse = getStatusFromInitialResponse;
  async function initHttpOperation(inputs) {
    const { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;
    return (0, operation_js_1.initOperation)({
      init: async () => {
        const response = await lro.sendInitialRequest();
        const config = inferLroMode({
          rawResponse: response.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response, operationLocation: config === null || config === undefined ? undefined : config.operationLocation, resourceLocation: config === null || config === undefined ? undefined : config.resourceLocation }, (config === null || config === undefined ? undefined : config.mode) ? { metadata: { mode: config.mode } } : {});
      },
      stateProxy,
      processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse,
      getOperationStatus: getStatusFromInitialResponse,
      setErrorAsResult
    });
  }
  exports.initHttpOperation = initHttpOperation;
  function getOperationLocation({ rawResponse }, state) {
    var _a;
    const mode = (_a = state.config.metadata) === null || _a === undefined ? undefined : _a["mode"];
    switch (mode) {
      case "OperationLocation": {
        return getOperationLocationPollingUrl({
          operationLocation: getOperationLocationHeader(rawResponse),
          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
        });
      }
      case "ResourceLocation": {
        return getLocationHeader(rawResponse);
      }
      case "Body":
      default: {
        return;
      }
    }
  }
  exports.getOperationLocation = getOperationLocation;
  function getOperationStatus({ rawResponse }, state) {
    var _a;
    const mode = (_a = state.config.metadata) === null || _a === undefined ? undefined : _a["mode"];
    switch (mode) {
      case "OperationLocation": {
        return getStatus(rawResponse);
      }
      case "ResourceLocation": {
        return toOperationStatus(rawResponse.statusCode);
      }
      case "Body": {
        return getProvisioningState(rawResponse);
      }
      default:
        throw new Error(`Internal error: Unexpected operation mode: ${mode}`);
    }
  }
  exports.getOperationStatus = getOperationStatus;
  function accessBodyProperty({ flatResponse, rawResponse }, prop) {
    var _a, _b;
    return (_a = flatResponse === null || flatResponse === undefined ? undefined : flatResponse[prop]) !== null && _a !== undefined ? _a : (_b = rawResponse.body) === null || _b === undefined ? undefined : _b[prop];
  }
  function getResourceLocation(res, state) {
    const loc = accessBodyProperty(res, "resourceLocation");
    if (loc && typeof loc === "string") {
      state.config.resourceLocation = loc;
    }
    return state.config.resourceLocation;
  }
  exports.getResourceLocation = getResourceLocation;
  function isOperationError(e) {
    return e.name === "RestError";
  }
  exports.isOperationError = isOperationError;
  async function pollHttpOperation(inputs) {
    const { lro, stateProxy, options, processResult, updateState, setDelay, state, setErrorAsResult } = inputs;
    return (0, operation_js_1.pollOperation)({
      state,
      stateProxy,
      setDelay,
      processResult: processResult ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState) : ({ flatResponse }) => flatResponse,
      getError: getErrorFromResponse,
      updateState,
      getPollingInterval: parseRetryAfter,
      getOperationLocation,
      getOperationStatus,
      isOperationError,
      getResourceLocation,
      options,
      poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),
      setErrorAsResult
    });
  }
  exports.pollHttpOperation = pollHttpOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/poller/poller.js
var require_poller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildCreatePoller = undefined;
  var operation_js_1 = require_operation();
  var constants_js_1 = require_constants3();
  var core_util_1 = require_commonjs3();
  var createStateProxy = () => ({
    initState: (config) => ({ status: "running", config }),
    setCanceled: (state) => state.status = "canceled",
    setError: (state, error) => state.error = error,
    setResult: (state, result) => state.result = result,
    setRunning: (state) => state.status = "running",
    setSucceeded: (state) => state.status = "succeeded",
    setFailed: (state) => state.status = "failed",
    getError: (state) => state.error,
    getResult: (state) => state.result,
    isCanceled: (state) => state.status === "canceled",
    isFailed: (state) => state.status === "failed",
    isRunning: (state) => state.status === "running",
    isSucceeded: (state) => state.status === "succeeded"
  });
  function buildCreatePoller(inputs) {
    const { getOperationLocation, getStatusFromInitialResponse, getStatusFromPollResponse, isOperationError, getResourceLocation, getPollingInterval, getError, resolveOnUnsuccessful } = inputs;
    return async ({ init, poll }, options) => {
      const { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, restoreFrom } = options || {};
      const stateProxy = createStateProxy();
      const withOperationLocation = withOperationLocationCallback ? (() => {
        let called = false;
        return (operationLocation, isUpdated) => {
          if (isUpdated)
            withOperationLocationCallback(operationLocation);
          else if (!called)
            withOperationLocationCallback(operationLocation);
          called = true;
        };
      })() : undefined;
      const state = restoreFrom ? (0, operation_js_1.deserializeState)(restoreFrom) : await (0, operation_js_1.initOperation)({
        init,
        stateProxy,
        processResult,
        getOperationStatus: getStatusFromInitialResponse,
        withOperationLocation,
        setErrorAsResult: !resolveOnUnsuccessful
      });
      let resultPromise;
      const abortController = new AbortController;
      const handlers = new Map;
      const handleProgressEvents = async () => handlers.forEach((h) => h(state));
      const cancelErrMsg = "Operation was canceled";
      let currentPollIntervalInMs = intervalInMs;
      const poller = {
        getOperationState: () => state,
        getResult: () => state.result,
        isDone: () => ["succeeded", "failed", "canceled"].includes(state.status),
        isStopped: () => resultPromise === undefined,
        stopPolling: () => {
          abortController.abort();
        },
        toString: () => JSON.stringify({
          state
        }),
        onProgress: (callback) => {
          const s = Symbol();
          handlers.set(s, callback);
          return () => handlers.delete(s);
        },
        pollUntilDone: (pollOptions) => resultPromise !== null && resultPromise !== undefined ? resultPromise : resultPromise = (async () => {
          const { abortSignal: inputAbortSignal } = pollOptions || {};
          function abortListener() {
            abortController.abort();
          }
          const abortSignal = abortController.signal;
          if (inputAbortSignal === null || inputAbortSignal === undefined ? undefined : inputAbortSignal.aborted) {
            abortController.abort();
          } else if (!abortSignal.aborted) {
            inputAbortSignal === null || inputAbortSignal === undefined || inputAbortSignal.addEventListener("abort", abortListener, { once: true });
          }
          try {
            if (!poller.isDone()) {
              await poller.poll({ abortSignal });
              while (!poller.isDone()) {
                await (0, core_util_1.delay)(currentPollIntervalInMs, { abortSignal });
                await poller.poll({ abortSignal });
              }
            }
          } finally {
            inputAbortSignal === null || inputAbortSignal === undefined || inputAbortSignal.removeEventListener("abort", abortListener);
          }
          if (resolveOnUnsuccessful) {
            return poller.getResult();
          } else {
            switch (state.status) {
              case "succeeded":
                return poller.getResult();
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state.error;
              case "notStarted":
              case "running":
                throw new Error(`Polling completed without succeeding or failing`);
            }
          }
        })().finally(() => {
          resultPromise = undefined;
        }),
        async poll(pollOptions) {
          if (resolveOnUnsuccessful) {
            if (poller.isDone())
              return;
          } else {
            switch (state.status) {
              case "succeeded":
                return;
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state.error;
            }
          }
          await (0, operation_js_1.pollOperation)({
            poll,
            state,
            stateProxy,
            getOperationLocation,
            isOperationError,
            withOperationLocation,
            getPollingInterval,
            getOperationStatus: getStatusFromPollResponse,
            getResourceLocation,
            processResult,
            getError,
            updateState,
            options: pollOptions,
            setDelay: (pollIntervalInMs) => {
              currentPollIntervalInMs = pollIntervalInMs;
            },
            setErrorAsResult: !resolveOnUnsuccessful
          });
          await handleProgressEvents();
          if (!resolveOnUnsuccessful) {
            switch (state.status) {
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state.error;
            }
          }
        }
      };
      return poller;
    };
  }
  exports.buildCreatePoller = buildCreatePoller;
});

// node_modules/@azure/core-lro/dist/commonjs/http/poller.js
var require_poller2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpPoller = undefined;
  var operation_js_1 = require_operation2();
  var poller_js_1 = require_poller();
  async function createHttpPoller(lro, options) {
    const { resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, resolveOnUnsuccessful = false } = options || {};
    return (0, poller_js_1.buildCreatePoller)({
      getStatusFromInitialResponse: operation_js_1.getStatusFromInitialResponse,
      getStatusFromPollResponse: operation_js_1.getOperationStatus,
      isOperationError: operation_js_1.isOperationError,
      getOperationLocation: operation_js_1.getOperationLocation,
      getResourceLocation: operation_js_1.getResourceLocation,
      getPollingInterval: operation_js_1.parseRetryAfter,
      getError: operation_js_1.getErrorFromResponse,
      resolveOnUnsuccessful
    })({
      init: async () => {
        const response = await lro.sendInitialRequest();
        const config = (0, operation_js_1.inferLroMode)({
          rawResponse: response.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response, operationLocation: config === null || config === undefined ? undefined : config.operationLocation, resourceLocation: config === null || config === undefined ? undefined : config.resourceLocation }, (config === null || config === undefined ? undefined : config.mode) ? { metadata: { mode: config.mode } } : {});
      },
      poll: lro.sendPollRequest
    }, {
      intervalInMs,
      withOperationLocation,
      restoreFrom,
      updateState,
      processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse
    });
  }
  exports.createHttpPoller = createHttpPoller;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/operation.js
var require_operation3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GenericPollOperation = undefined;
  var operation_js_1 = require_operation2();
  var logger_js_1 = require_logger();
  var createStateProxy = () => ({
    initState: (config) => ({ config, isStarted: true }),
    setCanceled: (state) => state.isCancelled = true,
    setError: (state, error) => state.error = error,
    setResult: (state, result) => state.result = result,
    setRunning: (state) => state.isStarted = true,
    setSucceeded: (state) => state.isCompleted = true,
    setFailed: () => {
    },
    getError: (state) => state.error,
    getResult: (state) => state.result,
    isCanceled: (state) => !!state.isCancelled,
    isFailed: (state) => !!state.error,
    isRunning: (state) => !!state.isStarted,
    isSucceeded: (state) => Boolean(state.isCompleted && !state.isCancelled && !state.error)
  });

  class GenericPollOperation {
    constructor(state, lro, setErrorAsResult, lroResourceLocationConfig, processResult, updateState, isDone) {
      this.state = state;
      this.lro = lro;
      this.setErrorAsResult = setErrorAsResult;
      this.lroResourceLocationConfig = lroResourceLocationConfig;
      this.processResult = processResult;
      this.updateState = updateState;
      this.isDone = isDone;
    }
    setPollerConfig(pollerConfig) {
      this.pollerConfig = pollerConfig;
    }
    async update(options) {
      var _a;
      const stateProxy = createStateProxy();
      if (!this.state.isStarted) {
        this.state = Object.assign(Object.assign({}, this.state), await (0, operation_js_1.initHttpOperation)({
          lro: this.lro,
          stateProxy,
          resourceLocationConfig: this.lroResourceLocationConfig,
          processResult: this.processResult,
          setErrorAsResult: this.setErrorAsResult
        }));
      }
      const updateState = this.updateState;
      const isDone = this.isDone;
      if (!this.state.isCompleted && this.state.error === undefined) {
        await (0, operation_js_1.pollHttpOperation)({
          lro: this.lro,
          state: this.state,
          stateProxy,
          processResult: this.processResult,
          updateState: updateState ? (state, { rawResponse }) => updateState(state, rawResponse) : undefined,
          isDone: isDone ? ({ flatResponse }, state) => isDone(flatResponse, state) : undefined,
          options,
          setDelay: (intervalInMs) => {
            this.pollerConfig.intervalInMs = intervalInMs;
          },
          setErrorAsResult: this.setErrorAsResult
        });
      }
      (_a = options === null || options === undefined ? undefined : options.fireProgress) === null || _a === undefined || _a.call(options, this.state);
      return this;
    }
    async cancel() {
      logger_js_1.logger.error("`cancelOperation` is deprecated because it wasn't implemented");
      return this;
    }
    toString() {
      return JSON.stringify({
        state: this.state
      });
    }
  }
  exports.GenericPollOperation = GenericPollOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/poller.js
var require_poller3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Poller = exports.PollerCancelledError = exports.PollerStoppedError = undefined;

  class PollerStoppedError extends Error {
    constructor(message) {
      super(message);
      this.name = "PollerStoppedError";
      Object.setPrototypeOf(this, PollerStoppedError.prototype);
    }
  }
  exports.PollerStoppedError = PollerStoppedError;

  class PollerCancelledError extends Error {
    constructor(message) {
      super(message);
      this.name = "PollerCancelledError";
      Object.setPrototypeOf(this, PollerCancelledError.prototype);
    }
  }
  exports.PollerCancelledError = PollerCancelledError;

  class Poller {
    constructor(operation) {
      this.resolveOnUnsuccessful = false;
      this.stopped = true;
      this.pollProgressCallbacks = [];
      this.operation = operation;
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
      this.promise.catch(() => {
      });
    }
    async startPolling(pollOptions = {}) {
      if (this.stopped) {
        this.stopped = false;
      }
      while (!this.isStopped() && !this.isDone()) {
        await this.poll(pollOptions);
        await this.delay();
      }
    }
    async pollOnce(options = {}) {
      if (!this.isDone()) {
        this.operation = await this.operation.update({
          abortSignal: options.abortSignal,
          fireProgress: this.fireProgress.bind(this)
        });
      }
      this.processUpdatedState();
    }
    fireProgress(state) {
      for (const callback of this.pollProgressCallbacks) {
        callback(state);
      }
    }
    async cancelOnce(options = {}) {
      this.operation = await this.operation.cancel(options);
    }
    poll(options = {}) {
      if (!this.pollOncePromise) {
        this.pollOncePromise = this.pollOnce(options);
        const clearPollOncePromise = () => {
          this.pollOncePromise = undefined;
        };
        this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
      }
      return this.pollOncePromise;
    }
    processUpdatedState() {
      if (this.operation.state.error) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          this.reject(this.operation.state.error);
          throw this.operation.state.error;
        }
      }
      if (this.operation.state.isCancelled) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          const error = new PollerCancelledError("Operation was canceled");
          this.reject(error);
          throw error;
        }
      }
      if (this.isDone() && this.resolve) {
        this.resolve(this.getResult());
      }
    }
    async pollUntilDone(pollOptions = {}) {
      if (this.stopped) {
        this.startPolling(pollOptions).catch(this.reject);
      }
      this.processUpdatedState();
      return this.promise;
    }
    onProgress(callback) {
      this.pollProgressCallbacks.push(callback);
      return () => {
        this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c) => c !== callback);
      };
    }
    isDone() {
      const state = this.operation.state;
      return Boolean(state.isCompleted || state.isCancelled || state.error);
    }
    stopPolling() {
      if (!this.stopped) {
        this.stopped = true;
        if (this.reject) {
          this.reject(new PollerStoppedError("This poller is already stopped"));
        }
      }
    }
    isStopped() {
      return this.stopped;
    }
    cancelOperation(options = {}) {
      if (!this.cancelPromise) {
        this.cancelPromise = this.cancelOnce(options);
      } else if (options.abortSignal) {
        throw new Error("A cancel request is currently pending");
      }
      return this.cancelPromise;
    }
    getOperationState() {
      return this.operation.state;
    }
    getResult() {
      const state = this.operation.state;
      return state.result;
    }
    toString() {
      return this.operation.toString();
    }
  }
  exports.Poller = Poller;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/lroEngine.js
var require_lroEngine = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LroEngine = undefined;
  var operation_js_1 = require_operation3();
  var constants_js_1 = require_constants3();
  var poller_js_1 = require_poller3();
  var operation_js_2 = require_operation();

  class LroEngine extends poller_js_1.Poller {
    constructor(lro, options) {
      const { intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, resumeFrom, resolveOnUnsuccessful = false, isDone, lroResourceLocationConfig, processResult, updateState } = options || {};
      const state = resumeFrom ? (0, operation_js_2.deserializeState)(resumeFrom) : {};
      const operation = new operation_js_1.GenericPollOperation(state, lro, !resolveOnUnsuccessful, lroResourceLocationConfig, processResult, updateState, isDone);
      super(operation);
      this.resolveOnUnsuccessful = resolveOnUnsuccessful;
      this.config = { intervalInMs };
      operation.setPollerConfig(this.config);
    }
    delay() {
      return new Promise((resolve) => setTimeout(() => resolve(), this.config.intervalInMs));
    }
  }
  exports.LroEngine = LroEngine;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/index.js
var require_lroEngine2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LroEngine = undefined;
  var lroEngine_js_1 = require_lroEngine();
  Object.defineProperty(exports, "LroEngine", { enumerable: true, get: function() {
    return lroEngine_js_1.LroEngine;
  } });
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/pollOperation.js
var require_pollOperation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/core-lro/dist/commonjs/index.js
var require_commonjs12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpPoller = undefined;
  var tslib_1 = require_tslib();
  var poller_js_1 = require_poller2();
  Object.defineProperty(exports, "createHttpPoller", { enumerable: true, get: function() {
    return poller_js_1.createHttpPoller;
  } });
  tslib_1.__exportStar(require_lroEngine2(), exports);
  tslib_1.__exportStar(require_poller3(), exports);
  tslib_1.__exportStar(require_pollOperation(), exports);
});

// node_modules/@azure/storage-blob/dist/index.js
var require_dist4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var coreRestPipeline = require_commonjs6();
  var tslib = require_tslib();
  var coreAuth = require_commonjs7();
  var coreUtil = require_commonjs3();
  var coreHttpCompat = require_commonjs9();
  var coreClient = require_commonjs8();
  var coreXml = require_commonjs10();
  var logger$1 = require_commonjs();
  var abortController = require_commonjs11();
  var crypto = __require("crypto");
  var coreTracing = require_commonjs5();
  var stream = __require("stream");
  var coreLro = require_commonjs12();
  var events = __require("events");
  var fs = __require("fs");
  var util = __require("util");
  var buffer = __require("buffer");
  function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k];
            }
          });
        }
      });
    }
    n.default = e;
    return Object.freeze(n);
  }
  var coreHttpCompat__namespace = /* @__PURE__ */ _interopNamespaceDefault(coreHttpCompat);
  var coreClient__namespace = /* @__PURE__ */ _interopNamespaceDefault(coreClient);
  var fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs);
  var util__namespace = /* @__PURE__ */ _interopNamespaceDefault(util);
  var logger = logger$1.createClientLogger("storage-blob");

  class BaseRequestPolicy {
    constructor(_nextPolicy, _options) {
      this._nextPolicy = _nextPolicy;
      this._options = _options;
    }
    shouldLog(logLevel) {
      return this._options.shouldLog(logLevel);
    }
    log(logLevel, message) {
      this._options.log(logLevel, message);
    }
  }
  var SDK_VERSION = "12.26.0";
  var SERVICE_VERSION = "2025-01-05";
  var BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 256 * 1024 * 1024;
  var BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4000 * 1024 * 1024;
  var BLOCK_BLOB_MAX_BLOCKS = 50000;
  var DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8 * 1024 * 1024;
  var DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4 * 1024 * 1024;
  var DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
  var REQUEST_TIMEOUT = 100 * 1000;
  var StorageOAuthScopes = "https://storage.azure.com/.default";
  var URLConstants = {
    Parameters: {
      FORCE_BROWSER_NO_CACHE: "_",
      SIGNATURE: "sig",
      SNAPSHOT: "snapshot",
      VERSIONID: "versionid",
      TIMEOUT: "timeout"
    }
  };
  var HTTPURLConnection = {
    HTTP_ACCEPTED: 202,
    HTTP_CONFLICT: 409,
    HTTP_NOT_FOUND: 404,
    HTTP_PRECON_FAILED: 412,
    HTTP_RANGE_NOT_SATISFIABLE: 416
  };
  var HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version",
    X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
  };
  var ETagNone = "";
  var ETagAny = "*";
  var SIZE_1_MB = 1 * 1024 * 1024;
  var BATCH_MAX_REQUEST = 256;
  var BATCH_MAX_PAYLOAD_IN_BYTES = 4 * SIZE_1_MB;
  var HTTP_LINE_ENDING = `\r
`;
  var HTTP_VERSION_1_1 = "HTTP/1.1";
  var EncryptionAlgorithmAES25 = "AES256";
  var DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
  var StorageBlobLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "x-ms-access-tier",
    "x-ms-access-tier-change-time",
    "x-ms-access-tier-inferred",
    "x-ms-account-kind",
    "x-ms-archive-status",
    "x-ms-blob-append-offset",
    "x-ms-blob-cache-control",
    "x-ms-blob-committed-block-count",
    "x-ms-blob-condition-appendpos",
    "x-ms-blob-condition-maxsize",
    "x-ms-blob-content-disposition",
    "x-ms-blob-content-encoding",
    "x-ms-blob-content-language",
    "x-ms-blob-content-length",
    "x-ms-blob-content-md5",
    "x-ms-blob-content-type",
    "x-ms-blob-public-access",
    "x-ms-blob-sequence-number",
    "x-ms-blob-type",
    "x-ms-copy-destination-snapshot",
    "x-ms-creation-time",
    "x-ms-default-encryption-scope",
    "x-ms-delete-snapshots",
    "x-ms-delete-type-permanent",
    "x-ms-deny-encryption-scope-override",
    "x-ms-encryption-algorithm",
    "x-ms-if-sequence-number-eq",
    "x-ms-if-sequence-number-le",
    "x-ms-if-sequence-number-lt",
    "x-ms-incremental-copy",
    "x-ms-lease-action",
    "x-ms-lease-break-period",
    "x-ms-lease-duration",
    "x-ms-lease-id",
    "x-ms-lease-time",
    "x-ms-page-write",
    "x-ms-proposed-lease-id",
    "x-ms-range-get-content-md5",
    "x-ms-rehydrate-priority",
    "x-ms-sequence-number-action",
    "x-ms-sku-name",
    "x-ms-source-content-md5",
    "x-ms-source-if-match",
    "x-ms-source-if-modified-since",
    "x-ms-source-if-none-match",
    "x-ms-source-if-unmodified-since",
    "x-ms-tag-count",
    "x-ms-encryption-key-sha256",
    "x-ms-copy-source-error-code",
    "x-ms-copy-source-status-code",
    "x-ms-if-tags",
    "x-ms-source-if-tags"
  ];
  var StorageBlobLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "include",
    "marker",
    "prefix",
    "copyid",
    "restype",
    "blockid",
    "blocklisttype",
    "delimiter",
    "prevsnapshot",
    "ske",
    "skoid",
    "sks",
    "skt",
    "sktid",
    "skv",
    "snapshot"
  ];
  var BlobUsesCustomerSpecifiedEncryptionMsg = "BlobUsesCustomerSpecifiedEncryption";
  var BlobDoesNotUseCustomerSpecifiedEncryption = "BlobDoesNotUseCustomerSpecifiedEncryption";
  var PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104"
  ];
  function escapeURLPath(url2) {
    const urlParsed = new URL(url2);
    let path = urlParsed.pathname;
    path = path || "/";
    path = escape(path);
    urlParsed.pathname = path;
    return urlParsed.toString();
  }
  function getProxyUriFromDevConnString(connectionString) {
    let proxyUri = "";
    if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
      const matchCredentials = connectionString.split(";");
      for (const element of matchCredentials) {
        if (element.trim().startsWith("DevelopmentStorageProxyUri=")) {
          proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
        }
      }
    }
    return proxyUri;
  }
  function getValueInConnString(connectionString, argument) {
    const elements = connectionString.split(";");
    for (const element of elements) {
      if (element.trim().startsWith(argument)) {
        return element.trim().match(argument + "=(.*)")[1];
      }
    }
    return "";
  }
  function extractConnectionStringParts(connectionString) {
    let proxyUri = "";
    if (connectionString.startsWith("UseDevelopmentStorage=true")) {
      proxyUri = getProxyUriFromDevConnString(connectionString);
      connectionString = DevelopmentConnectionString;
    }
    let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
    blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
      let defaultEndpointsProtocol = "";
      let accountName = "";
      let accountKey = Buffer.from("accountKey", "base64");
      let endpointSuffix = "";
      accountName = getValueInConnString(connectionString, "AccountName");
      accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
      if (!blobEndpoint) {
        defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
        const protocol = defaultEndpointsProtocol.toLowerCase();
        if (protocol !== "https" && protocol !== "http") {
          throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
        }
        endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
        if (!endpointSuffix) {
          throw new Error("Invalid EndpointSuffix in the provided Connection String");
        }
        blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
      }
      if (!accountName) {
        throw new Error("Invalid AccountName in the provided Connection String");
      } else if (accountKey.length === 0) {
        throw new Error("Invalid AccountKey in the provided Connection String");
      }
      return {
        kind: "AccountConnString",
        url: blobEndpoint,
        accountName,
        accountKey,
        proxyUri
      };
    } else {
      let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
      let accountName = getValueInConnString(connectionString, "AccountName");
      if (!accountName) {
        accountName = getAccountNameFromUrl(blobEndpoint);
      }
      if (!blobEndpoint) {
        throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
      } else if (!accountSas) {
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
      }
      if (accountSas.startsWith("?")) {
        accountSas = accountSas.substring(1);
      }
      return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
    }
  }
  function escape(text) {
    return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
  }
  function appendToURLPath(url2, name) {
    const urlParsed = new URL(url2);
    let path = urlParsed.pathname;
    path = path ? path.endsWith("/") ? `${path}${name}` : `${path}/${name}` : name;
    urlParsed.pathname = path;
    return urlParsed.toString();
  }
  function setURLParameter(url2, name, value) {
    const urlParsed = new URL(url2);
    const encodedName = encodeURIComponent(name);
    const encodedValue = value ? encodeURIComponent(value) : undefined;
    const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
    const searchPieces = [];
    for (const pair of searchString.slice(1).split("&")) {
      if (pair) {
        const [key] = pair.split("=", 2);
        if (key !== encodedName) {
          searchPieces.push(pair);
        }
      }
    }
    if (encodedValue) {
      searchPieces.push(`${encodedName}=${encodedValue}`);
    }
    urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return urlParsed.toString();
  }
  function getURLParameter(url2, name) {
    var _a;
    const urlParsed = new URL(url2);
    return (_a = urlParsed.searchParams.get(name)) !== null && _a !== undefined ? _a : undefined;
  }
  function setURLHost(url2, host) {
    const urlParsed = new URL(url2);
    urlParsed.hostname = host;
    return urlParsed.toString();
  }
  function getURLPath(url2) {
    try {
      const urlParsed = new URL(url2);
      return urlParsed.pathname;
    } catch (e) {
      return;
    }
  }
  function getURLScheme(url2) {
    try {
      const urlParsed = new URL(url2);
      return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
    } catch (e) {
      return;
    }
  }
  function getURLPathAndQuery(url2) {
    const urlParsed = new URL(url2);
    const pathString = urlParsed.pathname;
    if (!pathString) {
      throw new RangeError("Invalid url without valid path.");
    }
    let queryString = urlParsed.search || "";
    queryString = queryString.trim();
    if (queryString !== "") {
      queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
    }
    return `${pathString}${queryString}`;
  }
  function getURLQueries(url2) {
    let queryString = new URL(url2).search;
    if (!queryString) {
      return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value) => {
      const indexOfEqual = value.indexOf("=");
      const lastIndexOfEqual = value.lastIndexOf("=");
      return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
    });
    const queries = {};
    for (const querySubString of querySubStrings) {
      const splitResults = querySubString.split("=");
      const key = splitResults[0];
      const value = splitResults[1];
      queries[key] = value;
    }
    return queries;
  }
  function appendToURLQuery(url2, queryParts) {
    const urlParsed = new URL(url2);
    let query = urlParsed.search;
    if (query) {
      query += "&" + queryParts;
    } else {
      query = queryParts;
    }
    urlParsed.search = query;
    return urlParsed.toString();
  }
  function truncatedISO8061Date(date, withMilliseconds = true) {
    const dateString = date.toISOString();
    return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000" + "Z" : dateString.substring(0, dateString.length - 5) + "Z";
  }
  function base64encode(content) {
    return !coreUtil.isNode ? btoa(content) : Buffer.from(content).toString("base64");
  }
  function generateBlockID(blockIDPrefix, blockIndex) {
    const maxSourceStringLength = 48;
    const maxBlockIndexLength = 6;
    const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
    if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {
      blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
    }
    const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
    return base64encode(res);
  }
  async function delay(timeInMs, aborter, abortError) {
    return new Promise((resolve, reject) => {
      let timeout;
      const abortHandler = () => {
        if (timeout !== undefined) {
          clearTimeout(timeout);
        }
        reject(abortError);
      };
      const resolveHandler = () => {
        if (aborter !== undefined) {
          aborter.removeEventListener("abort", abortHandler);
        }
        resolve();
      };
      timeout = setTimeout(resolveHandler, timeInMs);
      if (aborter !== undefined) {
        aborter.addEventListener("abort", abortHandler);
      }
    });
  }
  function padStart(currentString, targetLength, padString = " ") {
    if (String.prototype.padStart) {
      return currentString.padStart(targetLength, padString);
    }
    padString = padString || " ";
    if (currentString.length > targetLength) {
      return currentString;
    } else {
      targetLength = targetLength - currentString.length;
      if (targetLength > padString.length) {
        padString += padString.repeat(targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + currentString;
    }
  }
  function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
  }
  function getAccountNameFromUrl(url2) {
    const parsedUrl = new URL(url2);
    let accountName;
    try {
      if (parsedUrl.hostname.split(".")[1] === "blob") {
        accountName = parsedUrl.hostname.split(".")[0];
      } else if (isIpEndpointStyle(parsedUrl)) {
        accountName = parsedUrl.pathname.split("/")[1];
      } else {
        accountName = "";
      }
      return accountName;
    } catch (error) {
      throw new Error("Unable to extract accountName with provided information.");
    }
  }
  function isIpEndpointStyle(parsedUrl) {
    const host = parsedUrl.host;
    return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && PathStylePorts.includes(parsedUrl.port);
  }
  function toBlobTagsString(tags2) {
    if (tags2 === undefined) {
      return;
    }
    const tagPairs = [];
    for (const key in tags2) {
      if (Object.prototype.hasOwnProperty.call(tags2, key)) {
        const value = tags2[key];
        tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
      }
    }
    return tagPairs.join("&");
  }
  function toBlobTags(tags2) {
    if (tags2 === undefined) {
      return;
    }
    const res = {
      blobTagSet: []
    };
    for (const key in tags2) {
      if (Object.prototype.hasOwnProperty.call(tags2, key)) {
        const value = tags2[key];
        res.blobTagSet.push({
          key,
          value
        });
      }
    }
    return res;
  }
  function toTags(tags2) {
    if (tags2 === undefined) {
      return;
    }
    const res = {};
    for (const blobTag of tags2.blobTagSet) {
      res[blobTag.key] = blobTag.value;
    }
    return res;
  }
  function toQuerySerialization(textConfiguration) {
    if (textConfiguration === undefined) {
      return;
    }
    switch (textConfiguration.kind) {
      case "csv":
        return {
          format: {
            type: "delimited",
            delimitedTextConfiguration: {
              columnSeparator: textConfiguration.columnSeparator || ",",
              fieldQuote: textConfiguration.fieldQuote || "",
              recordSeparator: textConfiguration.recordSeparator,
              escapeChar: textConfiguration.escapeCharacter || "",
              headersPresent: textConfiguration.hasHeaders || false
            }
          }
        };
      case "json":
        return {
          format: {
            type: "json",
            jsonTextConfiguration: {
              recordSeparator: textConfiguration.recordSeparator
            }
          }
        };
      case "arrow":
        return {
          format: {
            type: "arrow",
            arrowConfiguration: {
              schema: textConfiguration.schema
            }
          }
        };
      case "parquet":
        return {
          format: {
            type: "parquet"
          }
        };
      default:
        throw Error("Invalid BlobQueryTextConfiguration.");
    }
  }
  function parseObjectReplicationRecord(objectReplicationRecord) {
    if (!objectReplicationRecord) {
      return;
    }
    if ("policy-id" in objectReplicationRecord) {
      return;
    }
    const orProperties = [];
    for (const key in objectReplicationRecord) {
      const ids = key.split("_");
      const policyPrefix = "or-";
      if (ids[0].startsWith(policyPrefix)) {
        ids[0] = ids[0].substring(policyPrefix.length);
      }
      const rule = {
        ruleId: ids[1],
        replicationStatus: objectReplicationRecord[key]
      };
      const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);
      if (policyIndex > -1) {
        orProperties[policyIndex].rules.push(rule);
      } else {
        orProperties.push({
          policyId: ids[0],
          rules: [rule]
        });
      }
    }
    return orProperties;
  }
  function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : undefined;
  }
  function BlobNameToString(name) {
    if (name.encoded) {
      return decodeURIComponent(name.content);
    } else {
      return name.content;
    }
  }
  function ConvertInternalResponseOfListBlobFlat(internalResponse) {
    return Object.assign(Object.assign({}, internalResponse), { segment: {
      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
        const blobItem = Object.assign(Object.assign({}, blobItemInteral), { name: BlobNameToString(blobItemInteral.name) });
        return blobItem;
      })
    } });
  }
  function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {
    var _a;
    return Object.assign(Object.assign({}, internalResponse), { segment: {
      blobPrefixes: (_a = internalResponse.segment.blobPrefixes) === null || _a === undefined ? undefined : _a.map((blobPrefixInternal) => {
        const blobPrefix = Object.assign(Object.assign({}, blobPrefixInternal), { name: BlobNameToString(blobPrefixInternal.name) });
        return blobPrefix;
      }),
      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
        const blobItem = Object.assign(Object.assign({}, blobItemInteral), { name: BlobNameToString(blobItemInteral.name) });
        return blobItem;
      })
    } });
  }
  function* ExtractPageRangeInfoItems(getPageRangesSegment) {
    let pageRange = [];
    let clearRange = [];
    if (getPageRangesSegment.pageRange)
      pageRange = getPageRangesSegment.pageRange;
    if (getPageRangesSegment.clearRange)
      clearRange = getPageRangesSegment.clearRange;
    let pageRangeIndex = 0;
    let clearRangeIndex = 0;
    while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {
      if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {
        yield {
          start: pageRange[pageRangeIndex].start,
          end: pageRange[pageRangeIndex].end,
          isClear: false
        };
        ++pageRangeIndex;
      } else {
        yield {
          start: clearRange[clearRangeIndex].start,
          end: clearRange[clearRangeIndex].end,
          isClear: true
        };
        ++clearRangeIndex;
      }
    }
    for (;pageRangeIndex < pageRange.length; ++pageRangeIndex) {
      yield {
        start: pageRange[pageRangeIndex].start,
        end: pageRange[pageRangeIndex].end,
        isClear: false
      };
    }
    for (;clearRangeIndex < clearRange.length; ++clearRangeIndex) {
      yield {
        start: clearRange[clearRangeIndex].start,
        end: clearRange[clearRangeIndex].end,
        isClear: true
      };
    }
  }
  function EscapePath(blobName) {
    const split = blobName.split("/");
    for (let i = 0;i < split.length; i++) {
      split[i] = encodeURIComponent(split[i]);
    }
    return split.join("/");
  }
  function assertResponse(response) {
    if (`_response` in response) {
      return response;
    }
    throw new TypeError(`Unexpected response object ${response}`);
  }
  exports.StorageRetryPolicyType = undefined;
  (function(StorageRetryPolicyType2) {
    StorageRetryPolicyType2[StorageRetryPolicyType2["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    StorageRetryPolicyType2[StorageRetryPolicyType2["FIXED"] = 1] = "FIXED";
  })(exports.StorageRetryPolicyType || (exports.StorageRetryPolicyType = {}));
  var DEFAULT_RETRY_OPTIONS$1 = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: exports.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined
  };
  var RETRY_ABORT_ERROR$1 = new abortController.AbortError("The operation was aborted.");

  class StorageRetryPolicy extends BaseRequestPolicy {
    constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS$1) {
      super(nextPolicy, options);
      this.retryOptions = {
        retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS$1.retryPolicyType,
        maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS$1.maxTries,
        tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS$1.tryTimeoutInMs,
        retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS$1.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS$1.retryDelayInMs,
        maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS$1.maxRetryDelayInMs,
        secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS$1.secondaryHost
      };
    }
    async sendRequest(request) {
      return this.attemptSendRequest(request, false, 1);
    }
    async attemptSendRequest(request, secondaryHas404, attempt) {
      const newRequest = request.clone();
      const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request.method === "GET" || request.method === "HEAD" || request.method === "OPTIONS") || attempt % 2 === 1;
      if (!isPrimaryRetry) {
        newRequest.url = setURLHost(newRequest.url, this.retryOptions.secondaryHost);
      }
      if (this.retryOptions.tryTimeoutInMs) {
        newRequest.url = setURLParameter(newRequest.url, URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
      }
      let response;
      try {
        logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
        response = await this._nextPolicy.sendRequest(newRequest);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
          return response;
        }
        secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
      } catch (err) {
        logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) {
          throw err;
        }
      }
      await this.delay(isPrimaryRetry, attempt, request.abortSignal);
      return this.attemptSendRequest(request, secondaryHas404, ++attempt);
    }
    shouldRetry(isPrimaryRetry, attempt, response, err) {
      if (attempt >= this.retryOptions.maxTries) {
        logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
        return false;
      }
      const retriableErrors2 = [
        "ETIMEDOUT",
        "ESOCKETTIMEDOUT",
        "ECONNREFUSED",
        "ECONNRESET",
        "ENOENT",
        "ENOTFOUND",
        "TIMEOUT",
        "EPIPE",
        "REQUEST_SEND_ERROR"
      ];
      if (err) {
        for (const retriableError of retriableErrors2) {
          if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
            logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
            return true;
          }
        }
      }
      if (response || err) {
        const statusCode = response ? response.status : err ? err.statusCode : 0;
        if (!isPrimaryRetry && statusCode === 404) {
          logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
          return true;
        }
        if (statusCode === 503 || statusCode === 500) {
          logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
          return true;
        }
      }
      if ((err === null || err === undefined ? undefined : err.code) === "PARSE_ERROR" && (err === null || err === undefined ? undefined : err.message.startsWith(`Error "Error: Unclosed root tag`))) {
        logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
        return true;
      }
      return false;
    }
    async delay(isPrimaryRetry, attempt, abortSignal) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry) {
        switch (this.retryOptions.retryPolicyType) {
          case exports.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
            break;
          case exports.StorageRetryPolicyType.FIXED:
            delayTimeInMs = this.retryOptions.retryDelayInMs;
            break;
        }
      } else {
        delayTimeInMs = Math.random() * 1000;
      }
      logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
      return delay(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR$1);
    }
  }

  class StorageRetryPolicyFactory {
    constructor(retryOptions) {
      this.retryOptions = retryOptions;
    }
    create(nextPolicy, options) {
      return new StorageRetryPolicy(nextPolicy, options, this.retryOptions);
    }
  }

  class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request) {
      return this._nextPolicy.sendRequest(this.signRequest(request));
    }
    signRequest(request) {
      return request;
    }
  }
  var table_lv0 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1820,
    0,
    1823,
    1825,
    1827,
    1829,
    0,
    0,
    0,
    1837,
    2051,
    0,
    0,
    1843,
    0,
    3331,
    3354,
    3356,
    3358,
    3360,
    3362,
    3364,
    3366,
    3368,
    3370,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    0,
    0,
    1859,
    1860,
    1864,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    1868,
    0,
    1872,
    0
  ]);
  var table_lv2 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  var table_lv4 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    32786,
    0,
    0,
    0,
    0,
    0,
    33298,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  function compareHeader(lhs, rhs) {
    if (isLessThan(lhs, rhs))
      return -1;
    return 1;
  }
  function isLessThan(lhs, rhs) {
    const tables = [table_lv0, table_lv2, table_lv4];
    let curr_level = 0;
    let i = 0;
    let j = 0;
    while (curr_level < tables.length) {
      if (curr_level === tables.length - 1 && i !== j) {
        return i > j;
      }
      const weight1 = i < lhs.length ? tables[curr_level][lhs[i].charCodeAt(0)] : 1;
      const weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
      if (weight1 === 1 && weight2 === 1) {
        i = 0;
        j = 0;
        ++curr_level;
      } else if (weight1 === weight2) {
        ++i;
        ++j;
      } else if (weight1 === 0) {
        ++i;
      } else if (weight2 === 0) {
        ++j;
      } else {
        return weight1 < weight2;
      }
    }
    return false;
  }

  class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy, options, factory) {
      super(nextPolicy, options);
      this.factory = factory;
    }
    signRequest(request) {
      request.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString());
      if (request.body && (typeof request.body === "string" || request.body !== undefined) && request.body.length > 0) {
        request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      }
      const stringToSign = [
        request.method.toUpperCase(),
        this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LANGUAGE),
        this.getHeaderValueToSign(request, HeaderConstants.CONTENT_ENCODING),
        this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LENGTH),
        this.getHeaderValueToSign(request, HeaderConstants.CONTENT_MD5),
        this.getHeaderValueToSign(request, HeaderConstants.CONTENT_TYPE),
        this.getHeaderValueToSign(request, HeaderConstants.DATE),
        this.getHeaderValueToSign(request, HeaderConstants.IF_MODIFIED_SINCE),
        this.getHeaderValueToSign(request, HeaderConstants.IF_MATCH),
        this.getHeaderValueToSign(request, HeaderConstants.IF_NONE_MATCH),
        this.getHeaderValueToSign(request, HeaderConstants.IF_UNMODIFIED_SINCE),
        this.getHeaderValueToSign(request, HeaderConstants.RANGE)
      ].join(`
`) + `
` + this.getCanonicalizedHeadersString(request) + this.getCanonicalizedResourceString(request);
      const signature = this.factory.computeHMACSHA256(stringToSign);
      request.headers.set(HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
      return request;
    }
    getHeaderValueToSign(request, headerName) {
      const value = request.headers.get(headerName);
      if (!value) {
        return "";
      }
      if (headerName === HeaderConstants.CONTENT_LENGTH && value === "0") {
        return "";
      }
      return value;
    }
    getCanonicalizedHeadersString(request) {
      let headersArray = request.headers.headersArray().filter((value) => {
        return value.name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE);
      });
      headersArray.sort((a, b) => {
        return compareHeader(a.name.toLowerCase(), b.name.toLowerCase());
      });
      headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
          return false;
        }
        return true;
      });
      let canonicalizedHeadersStringToSign = "";
      headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      });
      return canonicalizedHeadersStringToSign;
    }
    getCanonicalizedResourceString(request) {
      const path = getURLPath(request.url) || "/";
      let canonicalizedResourceString = "";
      canonicalizedResourceString += `/${this.factory.accountName}${path}`;
      const queries = getURLQueries(request.url);
      const lowercaseQueries = {};
      if (queries) {
        const queryKeys = [];
        for (const key in queries) {
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            const lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key];
            queryKeys.push(lowercaseKey);
          }
        }
        queryKeys.sort();
        for (const key of queryKeys) {
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
        }
      }
      return canonicalizedResourceString;
    }
  }

  class Credential {
    create(_nextPolicy, _options) {
      throw new Error("Method should be implemented in children classes.");
    }
  }

  class StorageSharedKeyCredential extends Credential {
    constructor(accountName, accountKey) {
      super();
      this.accountName = accountName;
      this.accountKey = Buffer.from(accountKey, "base64");
    }
    create(nextPolicy, options) {
      return new StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
    }
    computeHMACSHA256(stringToSign) {
      return crypto.createHmac("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
    }
  }

  class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
  }

  class AnonymousCredential extends Credential {
    create(nextPolicy, options) {
      return new AnonymousCredentialPolicy(nextPolicy, options);
    }
  }
  var _defaultHttpClient;
  function getCachedDefaultHttpClient() {
    if (!_defaultHttpClient) {
      _defaultHttpClient = coreRestPipeline.createDefaultHttpClient();
    }
    return _defaultHttpClient;
  }
  var storageBrowserPolicyName = "storageBrowserPolicy";
  function storageBrowserPolicy() {
    return {
      name: storageBrowserPolicyName,
      async sendRequest(request, next) {
        if (coreUtil.isNode) {
          return next(request);
        }
        if (request.method === "GET" || request.method === "HEAD") {
          request.url = setURLParameter(request.url, URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
        }
        request.headers.delete(HeaderConstants.COOKIE);
        request.headers.delete(HeaderConstants.CONTENT_LENGTH);
        return next(request);
      }
    };
  }
  var storageRetryPolicyName = "storageRetryPolicy";
  var StorageRetryPolicyType;
  (function(StorageRetryPolicyType2) {
    StorageRetryPolicyType2[StorageRetryPolicyType2["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    StorageRetryPolicyType2[StorageRetryPolicyType2["FIXED"] = 1] = "FIXED";
  })(StorageRetryPolicyType || (StorageRetryPolicyType = {}));
  var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined
  };
  var retriableErrors = [
    "ETIMEDOUT",
    "ESOCKETTIMEDOUT",
    "ECONNREFUSED",
    "ECONNRESET",
    "ENOENT",
    "ENOTFOUND",
    "TIMEOUT",
    "EPIPE",
    "REQUEST_SEND_ERROR"
  ];
  var RETRY_ABORT_ERROR = new abortController.AbortError("The operation was aborted.");
  function storageRetryPolicy(options = {}) {
    var _a, _b, _c, _d, _e, _f;
    const retryPolicyType = (_a = options.retryPolicyType) !== null && _a !== undefined ? _a : DEFAULT_RETRY_OPTIONS.retryPolicyType;
    const maxTries = (_b = options.maxTries) !== null && _b !== undefined ? _b : DEFAULT_RETRY_OPTIONS.maxTries;
    const retryDelayInMs = (_c = options.retryDelayInMs) !== null && _c !== undefined ? _c : DEFAULT_RETRY_OPTIONS.retryDelayInMs;
    const maxRetryDelayInMs = (_d = options.maxRetryDelayInMs) !== null && _d !== undefined ? _d : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
    const secondaryHost = (_e = options.secondaryHost) !== null && _e !== undefined ? _e : DEFAULT_RETRY_OPTIONS.secondaryHost;
    const tryTimeoutInMs = (_f = options.tryTimeoutInMs) !== null && _f !== undefined ? _f : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
    function shouldRetry({ isPrimaryRetry, attempt, response, error }) {
      var _a2, _b2;
      if (attempt >= maxTries) {
        logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
        return false;
      }
      if (error) {
        for (const retriableError of retriableErrors) {
          if (error.name.toUpperCase().includes(retriableError) || error.message.toUpperCase().includes(retriableError) || error.code && error.code.toString().toUpperCase() === retriableError) {
            logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
            return true;
          }
        }
        if ((error === null || error === undefined ? undefined : error.code) === "PARSE_ERROR" && (error === null || error === undefined ? undefined : error.message.startsWith(`Error "Error: Unclosed root tag`))) {
          logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
          return true;
        }
      }
      if (response || error) {
        const statusCode = (_b2 = (_a2 = response === null || response === undefined ? undefined : response.status) !== null && _a2 !== undefined ? _a2 : error === null || error === undefined ? undefined : error.statusCode) !== null && _b2 !== undefined ? _b2 : 0;
        if (!isPrimaryRetry && statusCode === 404) {
          logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
          return true;
        }
        if (statusCode === 503 || statusCode === 500) {
          logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
          return true;
        }
      }
      return false;
    }
    function calculateDelay(isPrimaryRetry, attempt) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry) {
        switch (retryPolicyType) {
          case StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
            break;
          case StorageRetryPolicyType.FIXED:
            delayTimeInMs = retryDelayInMs;
            break;
        }
      } else {
        delayTimeInMs = Math.random() * 1000;
      }
      logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
      return delayTimeInMs;
    }
    return {
      name: storageRetryPolicyName,
      async sendRequest(request, next) {
        if (tryTimeoutInMs) {
          request.url = setURLParameter(request.url, URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1000)));
        }
        const primaryUrl = request.url;
        const secondaryUrl = secondaryHost ? setURLHost(request.url, secondaryHost) : undefined;
        let secondaryHas404 = false;
        let attempt = 1;
        let retryAgain = true;
        let response;
        let error;
        while (retryAgain) {
          const isPrimaryRetry = secondaryHas404 || !secondaryUrl || !["GET", "HEAD", "OPTIONS"].includes(request.method) || attempt % 2 === 1;
          request.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
          response = undefined;
          error = undefined;
          try {
            logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
            response = await next(request);
            secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
          } catch (e) {
            if (coreRestPipeline.isRestError(e)) {
              logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);
              error = e;
            } else {
              logger.error(`RetryPolicy: Caught error, message: ${coreUtil.getErrorMessage(e)}`);
              throw e;
            }
          }
          retryAgain = shouldRetry({ isPrimaryRetry, attempt, response, error });
          if (retryAgain) {
            await delay(calculateDelay(isPrimaryRetry, attempt), request.abortSignal, RETRY_ABORT_ERROR);
          }
          attempt++;
        }
        if (response) {
          return response;
        }
        throw error !== null && error !== undefined ? error : new coreRestPipeline.RestError("RetryPolicy failed without known error.");
      }
    };
  }
  var storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
  function storageSharedKeyCredentialPolicy(options) {
    function signRequest(request) {
      request.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString());
      if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
        request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      }
      const stringToSign = [
        request.method.toUpperCase(),
        getHeaderValueToSign(request, HeaderConstants.CONTENT_LANGUAGE),
        getHeaderValueToSign(request, HeaderConstants.CONTENT_ENCODING),
        getHeaderValueToSign(request, HeaderConstants.CONTENT_LENGTH),
        getHeaderValueToSign(request, HeaderConstants.CONTENT_MD5),
        getHeaderValueToSign(request, HeaderConstants.CONTENT_TYPE),
        getHeaderValueToSign(request, HeaderConstants.DATE),
        getHeaderValueToSign(request, HeaderConstants.IF_MODIFIED_SINCE),
        getHeaderValueToSign(request, HeaderConstants.IF_MATCH),
        getHeaderValueToSign(request, HeaderConstants.IF_NONE_MATCH),
        getHeaderValueToSign(request, HeaderConstants.IF_UNMODIFIED_SINCE),
        getHeaderValueToSign(request, HeaderConstants.RANGE)
      ].join(`
`) + `
` + getCanonicalizedHeadersString(request) + getCanonicalizedResourceString(request);
      const signature = crypto.createHmac("sha256", options.accountKey).update(stringToSign, "utf8").digest("base64");
      request.headers.set(HeaderConstants.AUTHORIZATION, `SharedKey ${options.accountName}:${signature}`);
    }
    function getHeaderValueToSign(request, headerName) {
      const value = request.headers.get(headerName);
      if (!value) {
        return "";
      }
      if (headerName === HeaderConstants.CONTENT_LENGTH && value === "0") {
        return "";
      }
      return value;
    }
    function getCanonicalizedHeadersString(request) {
      let headersArray = [];
      for (const [name, value] of request.headers) {
        if (name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE)) {
          headersArray.push({ name, value });
        }
      }
      headersArray.sort((a, b) => {
        return compareHeader(a.name.toLowerCase(), b.name.toLowerCase());
      });
      headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
          return false;
        }
        return true;
      });
      let canonicalizedHeadersStringToSign = "";
      headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      });
      return canonicalizedHeadersStringToSign;
    }
    function getCanonicalizedResourceString(request) {
      const path = getURLPath(request.url) || "/";
      let canonicalizedResourceString = "";
      canonicalizedResourceString += `/${options.accountName}${path}`;
      const queries = getURLQueries(request.url);
      const lowercaseQueries = {};
      if (queries) {
        const queryKeys = [];
        for (const key in queries) {
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            const lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key];
            queryKeys.push(lowercaseKey);
          }
        }
        queryKeys.sort();
        for (const key of queryKeys) {
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
        }
      }
      return canonicalizedResourceString;
    }
    return {
      name: storageSharedKeyCredentialPolicyName,
      async sendRequest(request, next) {
        signRequest(request);
        return next(request);
      }
    };
  }

  class StorageBrowserPolicy extends BaseRequestPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
    async sendRequest(request) {
      if (coreUtil.isNode) {
        return this._nextPolicy.sendRequest(request);
      }
      if (request.method.toUpperCase() === "GET" || request.method.toUpperCase() === "HEAD") {
        request.url = setURLParameter(request.url, URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
      }
      request.headers.remove(HeaderConstants.COOKIE);
      request.headers.remove(HeaderConstants.CONTENT_LENGTH);
      return this._nextPolicy.sendRequest(request);
    }
  }

  class StorageBrowserPolicyFactory {
    create(nextPolicy, options) {
      return new StorageBrowserPolicy(nextPolicy, options);
    }
  }
  var storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
  function storageCorrectContentLengthPolicy() {
    function correctContentLength(request) {
      if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
        request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      }
    }
    return {
      name: storageCorrectContentLengthPolicyName,
      async sendRequest(request, next) {
        correctContentLength(request);
        return next(request);
      }
    };
  }
  function isPipelineLike(pipeline) {
    if (!pipeline || typeof pipeline !== "object") {
      return false;
    }
    const castPipeline = pipeline;
    return Array.isArray(castPipeline.factories) && typeof castPipeline.options === "object" && typeof castPipeline.toServiceClientOptions === "function";
  }

  class Pipeline {
    constructor(factories, options = {}) {
      this.factories = factories;
      this.options = options;
    }
    toServiceClientOptions() {
      return {
        httpClient: this.options.httpClient,
        requestPolicyFactories: this.factories
      };
    }
  }
  function newPipeline(credential, pipelineOptions = {}) {
    if (!credential) {
      credential = new AnonymousCredential;
    }
    const pipeline = new Pipeline([], pipelineOptions);
    pipeline._credential = credential;
    return pipeline;
  }
  function processDownlevelPipeline(pipeline) {
    const knownFactoryFunctions = [
      isAnonymousCredential,
      isStorageSharedKeyCredential,
      isCoreHttpBearerTokenFactory,
      isStorageBrowserPolicyFactory,
      isStorageRetryPolicyFactory,
      isStorageTelemetryPolicyFactory,
      isCoreHttpPolicyFactory
    ];
    if (pipeline.factories.length) {
      const novelFactories = pipeline.factories.filter((factory) => {
        return !knownFactoryFunctions.some((knownFactory) => knownFactory(factory));
      });
      if (novelFactories.length) {
        const hasInjector = novelFactories.some((factory) => isInjectorPolicyFactory(factory));
        return {
          wrappedPolicies: coreHttpCompat.createRequestPolicyFactoryPolicy(novelFactories),
          afterRetry: hasInjector
        };
      }
    }
    return;
  }
  function getCoreClientOptions(pipeline) {
    var _a;
    const _b = pipeline.options, { httpClient: v1Client } = _b, restOptions = tslib.__rest(_b, ["httpClient"]);
    let httpClient = pipeline._coreHttpClient;
    if (!httpClient) {
      httpClient = v1Client ? coreHttpCompat.convertHttpClient(v1Client) : getCachedDefaultHttpClient();
      pipeline._coreHttpClient = httpClient;
    }
    let corePipeline = pipeline._corePipeline;
    if (!corePipeline) {
      const packageDetails = `azsdk-js-azure-storage-blob/${SDK_VERSION}`;
      const userAgentPrefix = restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
      corePipeline = coreClient.createClientPipeline(Object.assign(Object.assign({}, restOptions), { loggingOptions: {
        additionalAllowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,
        additionalAllowedQueryParameters: StorageBlobLoggingAllowedQueryParameters,
        logger: logger.info
      }, userAgentOptions: {
        userAgentPrefix
      }, serializationOptions: {
        stringifyXML: coreXml.stringifyXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      }, deserializationOptions: {
        parseXML: coreXml.parseXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      } }));
      corePipeline.removePolicy({ phase: "Retry" });
      corePipeline.removePolicy({ name: coreRestPipeline.decompressResponsePolicyName });
      corePipeline.addPolicy(storageCorrectContentLengthPolicy());
      corePipeline.addPolicy(storageRetryPolicy(restOptions.retryOptions), { phase: "Retry" });
      corePipeline.addPolicy(storageBrowserPolicy());
      const downlevelResults = processDownlevelPipeline(pipeline);
      if (downlevelResults) {
        corePipeline.addPolicy(downlevelResults.wrappedPolicies, downlevelResults.afterRetry ? { afterPhase: "Retry" } : undefined);
      }
      const credential = getCredentialFromPipeline(pipeline);
      if (coreAuth.isTokenCredential(credential)) {
        corePipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
          credential,
          scopes: (_a = restOptions.audience) !== null && _a !== undefined ? _a : StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: coreClient.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      } else if (credential instanceof StorageSharedKeyCredential) {
        corePipeline.addPolicy(storageSharedKeyCredentialPolicy({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      }
      pipeline._corePipeline = corePipeline;
    }
    return Object.assign(Object.assign({}, restOptions), { allowInsecureConnection: true, httpClient, pipeline: corePipeline });
  }
  function getCredentialFromPipeline(pipeline) {
    if (pipeline._credential) {
      return pipeline._credential;
    }
    let credential = new AnonymousCredential;
    for (const factory of pipeline.factories) {
      if (coreAuth.isTokenCredential(factory.credential)) {
        credential = factory.credential;
      } else if (isStorageSharedKeyCredential(factory)) {
        return factory;
      }
    }
    return credential;
  }
  function isStorageSharedKeyCredential(factory) {
    if (factory instanceof StorageSharedKeyCredential) {
      return true;
    }
    return factory.constructor.name === "StorageSharedKeyCredential";
  }
  function isAnonymousCredential(factory) {
    if (factory instanceof AnonymousCredential) {
      return true;
    }
    return factory.constructor.name === "AnonymousCredential";
  }
  function isCoreHttpBearerTokenFactory(factory) {
    return coreAuth.isTokenCredential(factory.credential);
  }
  function isStorageBrowserPolicyFactory(factory) {
    if (factory instanceof StorageBrowserPolicyFactory) {
      return true;
    }
    return factory.constructor.name === "StorageBrowserPolicyFactory";
  }
  function isStorageRetryPolicyFactory(factory) {
    if (factory instanceof StorageRetryPolicyFactory) {
      return true;
    }
    return factory.constructor.name === "StorageRetryPolicyFactory";
  }
  function isStorageTelemetryPolicyFactory(factory) {
    return factory.constructor.name === "TelemetryPolicyFactory";
  }
  function isInjectorPolicyFactory(factory) {
    return factory.constructor.name === "InjectorPolicyFactory";
  }
  function isCoreHttpPolicyFactory(factory) {
    const knownPolicies = [
      "GenerateClientRequestIdPolicy",
      "TracingPolicy",
      "LogPolicy",
      "ProxyPolicy",
      "DisableResponseDecompressionPolicy",
      "KeepAlivePolicy",
      "DeserializationPolicy"
    ];
    const mockHttpClient = {
      sendRequest: async (request) => {
        return {
          request,
          headers: request.headers.clone(),
          status: 500
        };
      }
    };
    const mockRequestPolicyOptions = {
      log(_logLevel, _message) {
      },
      shouldLog(_logLevel) {
        return false;
      }
    };
    const policyInstance = factory.create(mockHttpClient, mockRequestPolicyOptions);
    const policyName = policyInstance.constructor.name;
    return knownPolicies.some((knownPolicyName) => {
      return policyName.startsWith(knownPolicyName);
    });
  }
  var BlobServiceProperties = {
    serializedName: "BlobServiceProperties",
    xmlName: "StorageServiceProperties",
    type: {
      name: "Composite",
      className: "BlobServiceProperties",
      modelProperties: {
        blobAnalyticsLogging: {
          serializedName: "Logging",
          xmlName: "Logging",
          type: {
            name: "Composite",
            className: "Logging"
          }
        },
        hourMetrics: {
          serializedName: "HourMetrics",
          xmlName: "HourMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        minuteMetrics: {
          serializedName: "MinuteMetrics",
          xmlName: "MinuteMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        cors: {
          serializedName: "Cors",
          xmlName: "Cors",
          xmlIsWrapped: true,
          xmlElementName: "CorsRule",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "CorsRule"
              }
            }
          }
        },
        defaultServiceVersion: {
          serializedName: "DefaultServiceVersion",
          xmlName: "DefaultServiceVersion",
          type: {
            name: "String"
          }
        },
        deleteRetentionPolicy: {
          serializedName: "DeleteRetentionPolicy",
          xmlName: "DeleteRetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        },
        staticWebsite: {
          serializedName: "StaticWebsite",
          xmlName: "StaticWebsite",
          type: {
            name: "Composite",
            className: "StaticWebsite"
          }
        }
      }
    }
  };
  var Logging = {
    serializedName: "Logging",
    type: {
      name: "Composite",
      className: "Logging",
      modelProperties: {
        version: {
          serializedName: "Version",
          required: true,
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        deleteProperty: {
          serializedName: "Delete",
          required: true,
          xmlName: "Delete",
          type: {
            name: "Boolean"
          }
        },
        read: {
          serializedName: "Read",
          required: true,
          xmlName: "Read",
          type: {
            name: "Boolean"
          }
        },
        write: {
          serializedName: "Write",
          required: true,
          xmlName: "Write",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  var RetentionPolicy = {
    serializedName: "RetentionPolicy",
    type: {
      name: "Composite",
      className: "RetentionPolicy",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        days: {
          constraints: {
            InclusiveMinimum: 1
          },
          serializedName: "Days",
          xmlName: "Days",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var Metrics = {
    serializedName: "Metrics",
    type: {
      name: "Composite",
      className: "Metrics",
      modelProperties: {
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        includeAPIs: {
          serializedName: "IncludeAPIs",
          xmlName: "IncludeAPIs",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  var CorsRule = {
    serializedName: "CorsRule",
    type: {
      name: "Composite",
      className: "CorsRule",
      modelProperties: {
        allowedOrigins: {
          serializedName: "AllowedOrigins",
          required: true,
          xmlName: "AllowedOrigins",
          type: {
            name: "String"
          }
        },
        allowedMethods: {
          serializedName: "AllowedMethods",
          required: true,
          xmlName: "AllowedMethods",
          type: {
            name: "String"
          }
        },
        allowedHeaders: {
          serializedName: "AllowedHeaders",
          required: true,
          xmlName: "AllowedHeaders",
          type: {
            name: "String"
          }
        },
        exposedHeaders: {
          serializedName: "ExposedHeaders",
          required: true,
          xmlName: "ExposedHeaders",
          type: {
            name: "String"
          }
        },
        maxAgeInSeconds: {
          constraints: {
            InclusiveMinimum: 0
          },
          serializedName: "MaxAgeInSeconds",
          required: true,
          xmlName: "MaxAgeInSeconds",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var StaticWebsite = {
    serializedName: "StaticWebsite",
    type: {
      name: "Composite",
      className: "StaticWebsite",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        indexDocument: {
          serializedName: "IndexDocument",
          xmlName: "IndexDocument",
          type: {
            name: "String"
          }
        },
        errorDocument404Path: {
          serializedName: "ErrorDocument404Path",
          xmlName: "ErrorDocument404Path",
          type: {
            name: "String"
          }
        },
        defaultIndexDocumentPath: {
          serializedName: "DefaultIndexDocumentPath",
          xmlName: "DefaultIndexDocumentPath",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var StorageError = {
    serializedName: "StorageError",
    type: {
      name: "Composite",
      className: "StorageError",
      modelProperties: {
        message: {
          serializedName: "Message",
          xmlName: "Message",
          type: {
            name: "String"
          }
        },
        code: {
          serializedName: "Code",
          xmlName: "Code",
          type: {
            name: "String"
          }
        },
        authenticationErrorDetail: {
          serializedName: "AuthenticationErrorDetail",
          xmlName: "AuthenticationErrorDetail",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobServiceStatistics = {
    serializedName: "BlobServiceStatistics",
    xmlName: "StorageServiceStats",
    type: {
      name: "Composite",
      className: "BlobServiceStatistics",
      modelProperties: {
        geoReplication: {
          serializedName: "GeoReplication",
          xmlName: "GeoReplication",
          type: {
            name: "Composite",
            className: "GeoReplication"
          }
        }
      }
    }
  };
  var GeoReplication = {
    serializedName: "GeoReplication",
    type: {
      name: "Composite",
      className: "GeoReplication",
      modelProperties: {
        status: {
          serializedName: "Status",
          required: true,
          xmlName: "Status",
          type: {
            name: "Enum",
            allowedValues: ["live", "bootstrap", "unavailable"]
          }
        },
        lastSyncOn: {
          serializedName: "LastSyncTime",
          required: true,
          xmlName: "LastSyncTime",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ListContainersSegmentResponse = {
    serializedName: "ListContainersSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListContainersSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        containerItems: {
          serializedName: "ContainerItems",
          required: true,
          xmlName: "Containers",
          xmlIsWrapped: true,
          xmlElementName: "Container",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ContainerItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerItem = {
    serializedName: "ContainerItem",
    xmlName: "Container",
    type: {
      name: "Composite",
      className: "ContainerItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        deleted: {
          serializedName: "Deleted",
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "ContainerProperties"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        }
      }
    }
  };
  var ContainerProperties = {
    serializedName: "ContainerProperties",
    type: {
      name: "Composite",
      className: "ContainerProperties",
      modelProperties: {
        lastModified: {
          serializedName: "Last-Modified",
          required: true,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: true,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        publicAccess: {
          serializedName: "PublicAccess",
          xmlName: "PublicAccess",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "HasImmutabilityPolicy",
          xmlName: "HasImmutabilityPolicy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "HasLegalHold",
          xmlName: "HasLegalHold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "DefaultEncryptionScope",
          xmlName: "DefaultEncryptionScope",
          type: {
            name: "String"
          }
        },
        preventEncryptionScopeOverride: {
          serializedName: "DenyEncryptionScopeOverride",
          xmlName: "DenyEncryptionScopeOverride",
          type: {
            name: "Boolean"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "ImmutableStorageWithVersioningEnabled",
          xmlName: "ImmutableStorageWithVersioningEnabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var KeyInfo = {
    serializedName: "KeyInfo",
    type: {
      name: "Composite",
      className: "KeyInfo",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          required: true,
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var UserDelegationKey = {
    serializedName: "UserDelegationKey",
    type: {
      name: "Composite",
      className: "UserDelegationKey",
      modelProperties: {
        signedObjectId: {
          serializedName: "SignedOid",
          required: true,
          xmlName: "SignedOid",
          type: {
            name: "String"
          }
        },
        signedTenantId: {
          serializedName: "SignedTid",
          required: true,
          xmlName: "SignedTid",
          type: {
            name: "String"
          }
        },
        signedStartsOn: {
          serializedName: "SignedStart",
          required: true,
          xmlName: "SignedStart",
          type: {
            name: "String"
          }
        },
        signedExpiresOn: {
          serializedName: "SignedExpiry",
          required: true,
          xmlName: "SignedExpiry",
          type: {
            name: "String"
          }
        },
        signedService: {
          serializedName: "SignedService",
          required: true,
          xmlName: "SignedService",
          type: {
            name: "String"
          }
        },
        signedVersion: {
          serializedName: "SignedVersion",
          required: true,
          xmlName: "SignedVersion",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: true,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var FilterBlobSegment = {
    serializedName: "FilterBlobSegment",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "FilterBlobSegment",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        where: {
          serializedName: "Where",
          required: true,
          xmlName: "Where",
          type: {
            name: "String"
          }
        },
        blobs: {
          serializedName: "Blobs",
          required: true,
          xmlName: "Blobs",
          xmlIsWrapped: true,
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "FilterBlobItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var FilterBlobItem = {
    serializedName: "FilterBlobItem",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "FilterBlobItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          type: {
            name: "String"
          }
        },
        tags: {
          serializedName: "Tags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        }
      }
    }
  };
  var BlobTags = {
    serializedName: "BlobTags",
    xmlName: "Tags",
    type: {
      name: "Composite",
      className: "BlobTags",
      modelProperties: {
        blobTagSet: {
          serializedName: "BlobTagSet",
          required: true,
          xmlName: "TagSet",
          xmlIsWrapped: true,
          xmlElementName: "Tag",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobTag"
              }
            }
          }
        }
      }
    }
  };
  var BlobTag = {
    serializedName: "BlobTag",
    xmlName: "Tag",
    type: {
      name: "Composite",
      className: "BlobTag",
      modelProperties: {
        key: {
          serializedName: "Key",
          required: true,
          xmlName: "Key",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: true,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var SignedIdentifier = {
    serializedName: "SignedIdentifier",
    xmlName: "SignedIdentifier",
    type: {
      name: "Composite",
      className: "SignedIdentifier",
      modelProperties: {
        id: {
          serializedName: "Id",
          required: true,
          xmlName: "Id",
          type: {
            name: "String"
          }
        },
        accessPolicy: {
          serializedName: "AccessPolicy",
          xmlName: "AccessPolicy",
          type: {
            name: "Composite",
            className: "AccessPolicy"
          }
        }
      }
    }
  };
  var AccessPolicy = {
    serializedName: "AccessPolicy",
    type: {
      name: "Composite",
      className: "AccessPolicy",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        },
        permissions: {
          serializedName: "Permission",
          xmlName: "Permission",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ListBlobsFlatSegmentResponse = {
    serializedName: "ListBlobsFlatSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsFlatSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobFlatListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobFlatListSegment = {
    serializedName: "BlobFlatListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobFlatListSegment",
      modelProperties: {
        blobItems: {
          serializedName: "BlobItems",
          required: true,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  var BlobItemInternal = {
    serializedName: "BlobItemInternal",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "BlobItemInternal",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        },
        deleted: {
          serializedName: "Deleted",
          required: true,
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        snapshot: {
          serializedName: "Snapshot",
          required: true,
          xmlName: "Snapshot",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "VersionId",
          xmlName: "VersionId",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "IsCurrentVersion",
          xmlName: "IsCurrentVersion",
          type: {
            name: "Boolean"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "BlobPropertiesInternal"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobTags: {
          serializedName: "BlobTags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        },
        objectReplicationMetadata: {
          serializedName: "ObjectReplicationMetadata",
          xmlName: "OrMetadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        hasVersionsOnly: {
          serializedName: "HasVersionsOnly",
          xmlName: "HasVersionsOnly",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var BlobName = {
    serializedName: "BlobName",
    type: {
      name: "Composite",
      className: "BlobName",
      modelProperties: {
        encoded: {
          serializedName: "Encoded",
          xmlName: "Encoded",
          xmlIsAttribute: true,
          type: {
            name: "Boolean"
          }
        },
        content: {
          serializedName: "content",
          xmlName: "content",
          xmlIsMsText: true,
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobPropertiesInternal = {
    serializedName: "BlobPropertiesInternal",
    xmlName: "Properties",
    type: {
      name: "Composite",
      className: "BlobPropertiesInternal",
      modelProperties: {
        createdOn: {
          serializedName: "Creation-Time",
          xmlName: "Creation-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        lastModified: {
          serializedName: "Last-Modified",
          required: true,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: true,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        contentLength: {
          serializedName: "Content-Length",
          xmlName: "Content-Length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "Content-Type",
          xmlName: "Content-Type",
          type: {
            name: "String"
          }
        },
        contentEncoding: {
          serializedName: "Content-Encoding",
          xmlName: "Content-Encoding",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "Content-Language",
          xmlName: "Content-Language",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "Content-MD5",
          xmlName: "Content-MD5",
          type: {
            name: "ByteArray"
          }
        },
        contentDisposition: {
          serializedName: "Content-Disposition",
          xmlName: "Content-Disposition",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "Cache-Control",
          xmlName: "Cache-Control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "BlobType",
          xmlName: "BlobType",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        copyId: {
          serializedName: "CopyId",
          xmlName: "CopyId",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "CopyStatus",
          xmlName: "CopyStatus",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        copySource: {
          serializedName: "CopySource",
          xmlName: "CopySource",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "CopyProgress",
          xmlName: "CopyProgress",
          type: {
            name: "String"
          }
        },
        copyCompletedOn: {
          serializedName: "CopyCompletionTime",
          xmlName: "CopyCompletionTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "CopyStatusDescription",
          xmlName: "CopyStatusDescription",
          type: {
            name: "String"
          }
        },
        serverEncrypted: {
          serializedName: "ServerEncrypted",
          xmlName: "ServerEncrypted",
          type: {
            name: "Boolean"
          }
        },
        incrementalCopy: {
          serializedName: "IncrementalCopy",
          xmlName: "IncrementalCopy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "DestinationSnapshot",
          xmlName: "DestinationSnapshot",
          type: {
            name: "String"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        accessTier: {
          serializedName: "AccessTier",
          xmlName: "AccessTier",
          type: {
            name: "Enum",
            allowedValues: [
              "P4",
              "P6",
              "P10",
              "P15",
              "P20",
              "P30",
              "P40",
              "P50",
              "P60",
              "P70",
              "P80",
              "Hot",
              "Cool",
              "Archive",
              "Cold"
            ]
          }
        },
        accessTierInferred: {
          serializedName: "AccessTierInferred",
          xmlName: "AccessTierInferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "ArchiveStatus",
          xmlName: "ArchiveStatus",
          type: {
            name: "Enum",
            allowedValues: [
              "rehydrate-pending-to-hot",
              "rehydrate-pending-to-cool",
              "rehydrate-pending-to-cold"
            ]
          }
        },
        customerProvidedKeySha256: {
          serializedName: "CustomerProvidedKeySha256",
          xmlName: "CustomerProvidedKeySha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "EncryptionScope",
          xmlName: "EncryptionScope",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "AccessTierChangeTime",
          xmlName: "AccessTierChangeTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        tagCount: {
          serializedName: "TagCount",
          xmlName: "TagCount",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "Expiry-Time",
          xmlName: "Expiry-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "Sealed",
          xmlName: "Sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "RehydratePriority",
          xmlName: "RehydratePriority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessedOn: {
          serializedName: "LastAccessTime",
          xmlName: "LastAccessTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "ImmutabilityPolicyUntilDate",
          xmlName: "ImmutabilityPolicyUntilDate",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "ImmutabilityPolicyMode",
          xmlName: "ImmutabilityPolicyMode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "LegalHold",
          xmlName: "LegalHold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var ListBlobsHierarchySegmentResponse = {
    serializedName: "ListBlobsHierarchySegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsHierarchySegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        delimiter: {
          serializedName: "Delimiter",
          xmlName: "Delimiter",
          type: {
            name: "String"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobHierarchyListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobHierarchyListSegment = {
    serializedName: "BlobHierarchyListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobHierarchyListSegment",
      modelProperties: {
        blobPrefixes: {
          serializedName: "BlobPrefixes",
          xmlName: "BlobPrefixes",
          xmlElementName: "BlobPrefix",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobPrefix"
              }
            }
          }
        },
        blobItems: {
          serializedName: "BlobItems",
          required: true,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  var BlobPrefix = {
    serializedName: "BlobPrefix",
    type: {
      name: "Composite",
      className: "BlobPrefix",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        }
      }
    }
  };
  var BlockLookupList = {
    serializedName: "BlockLookupList",
    xmlName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockLookupList",
      modelProperties: {
        committed: {
          serializedName: "Committed",
          xmlName: "Committed",
          xmlElementName: "Committed",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        uncommitted: {
          serializedName: "Uncommitted",
          xmlName: "Uncommitted",
          xmlElementName: "Uncommitted",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        latest: {
          serializedName: "Latest",
          xmlName: "Latest",
          xmlElementName: "Latest",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        }
      }
    }
  };
  var BlockList = {
    serializedName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockList",
      modelProperties: {
        committedBlocks: {
          serializedName: "CommittedBlocks",
          xmlName: "CommittedBlocks",
          xmlIsWrapped: true,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        },
        uncommittedBlocks: {
          serializedName: "UncommittedBlocks",
          xmlName: "UncommittedBlocks",
          xmlIsWrapped: true,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        }
      }
    }
  };
  var Block = {
    serializedName: "Block",
    type: {
      name: "Composite",
      className: "Block",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        size: {
          serializedName: "Size",
          required: true,
          xmlName: "Size",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var PageList = {
    serializedName: "PageList",
    type: {
      name: "Composite",
      className: "PageList",
      modelProperties: {
        pageRange: {
          serializedName: "PageRange",
          xmlName: "PageRange",
          xmlElementName: "PageRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "PageRange"
              }
            }
          }
        },
        clearRange: {
          serializedName: "ClearRange",
          xmlName: "ClearRange",
          xmlElementName: "ClearRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ClearRange"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageRange = {
    serializedName: "PageRange",
    xmlName: "PageRange",
    type: {
      name: "Composite",
      className: "PageRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: true,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var ClearRange = {
    serializedName: "ClearRange",
    xmlName: "ClearRange",
    type: {
      name: "Composite",
      className: "ClearRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: true,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var QueryRequest = {
    serializedName: "QueryRequest",
    xmlName: "QueryRequest",
    type: {
      name: "Composite",
      className: "QueryRequest",
      modelProperties: {
        queryType: {
          serializedName: "QueryType",
          required: true,
          xmlName: "QueryType",
          type: {
            name: "String"
          }
        },
        expression: {
          serializedName: "Expression",
          required: true,
          xmlName: "Expression",
          type: {
            name: "String"
          }
        },
        inputSerialization: {
          serializedName: "InputSerialization",
          xmlName: "InputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        },
        outputSerialization: {
          serializedName: "OutputSerialization",
          xmlName: "OutputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        }
      }
    }
  };
  var QuerySerialization = {
    serializedName: "QuerySerialization",
    type: {
      name: "Composite",
      className: "QuerySerialization",
      modelProperties: {
        format: {
          serializedName: "Format",
          xmlName: "Format",
          type: {
            name: "Composite",
            className: "QueryFormat"
          }
        }
      }
    }
  };
  var QueryFormat = {
    serializedName: "QueryFormat",
    type: {
      name: "Composite",
      className: "QueryFormat",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: true,
          xmlName: "Type",
          type: {
            name: "Enum",
            allowedValues: ["delimited", "json", "arrow", "parquet"]
          }
        },
        delimitedTextConfiguration: {
          serializedName: "DelimitedTextConfiguration",
          xmlName: "DelimitedTextConfiguration",
          type: {
            name: "Composite",
            className: "DelimitedTextConfiguration"
          }
        },
        jsonTextConfiguration: {
          serializedName: "JsonTextConfiguration",
          xmlName: "JsonTextConfiguration",
          type: {
            name: "Composite",
            className: "JsonTextConfiguration"
          }
        },
        arrowConfiguration: {
          serializedName: "ArrowConfiguration",
          xmlName: "ArrowConfiguration",
          type: {
            name: "Composite",
            className: "ArrowConfiguration"
          }
        },
        parquetTextConfiguration: {
          serializedName: "ParquetTextConfiguration",
          xmlName: "ParquetTextConfiguration",
          type: {
            name: "Dictionary",
            value: { type: { name: "any" } }
          }
        }
      }
    }
  };
  var DelimitedTextConfiguration = {
    serializedName: "DelimitedTextConfiguration",
    xmlName: "DelimitedTextConfiguration",
    type: {
      name: "Composite",
      className: "DelimitedTextConfiguration",
      modelProperties: {
        columnSeparator: {
          serializedName: "ColumnSeparator",
          xmlName: "ColumnSeparator",
          type: {
            name: "String"
          }
        },
        fieldQuote: {
          serializedName: "FieldQuote",
          xmlName: "FieldQuote",
          type: {
            name: "String"
          }
        },
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        },
        escapeChar: {
          serializedName: "EscapeChar",
          xmlName: "EscapeChar",
          type: {
            name: "String"
          }
        },
        headersPresent: {
          serializedName: "HeadersPresent",
          xmlName: "HasHeaders",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var JsonTextConfiguration = {
    serializedName: "JsonTextConfiguration",
    xmlName: "JsonTextConfiguration",
    type: {
      name: "Composite",
      className: "JsonTextConfiguration",
      modelProperties: {
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ArrowConfiguration = {
    serializedName: "ArrowConfiguration",
    xmlName: "ArrowConfiguration",
    type: {
      name: "Composite",
      className: "ArrowConfiguration",
      modelProperties: {
        schema: {
          serializedName: "Schema",
          required: true,
          xmlName: "Schema",
          xmlIsWrapped: true,
          xmlElementName: "Field",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ArrowField"
              }
            }
          }
        }
      }
    }
  };
  var ArrowField = {
    serializedName: "ArrowField",
    xmlName: "Field",
    type: {
      name: "Composite",
      className: "ArrowField",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: true,
          xmlName: "Type",
          type: {
            name: "String"
          }
        },
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        precision: {
          serializedName: "Precision",
          xmlName: "Precision",
          type: {
            name: "Number"
          }
        },
        scale: {
          serializedName: "Scale",
          xmlName: "Scale",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var ServiceSetPropertiesHeaders = {
    serializedName: "Service_setPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceSetPropertiesExceptionHeaders = {
    serializedName: "Service_setPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetPropertiesHeaders = {
    serializedName: "Service_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetPropertiesExceptionHeaders = {
    serializedName: "Service_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetStatisticsHeaders = {
    serializedName: "Service_getStatisticsHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetStatisticsExceptionHeaders = {
    serializedName: "Service_getStatisticsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceListContainersSegmentHeaders = {
    serializedName: "Service_listContainersSegmentHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceListContainersSegmentExceptionHeaders = {
    serializedName: "Service_listContainersSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetUserDelegationKeyHeaders = {
    serializedName: "Service_getUserDelegationKeyHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetUserDelegationKeyExceptionHeaders = {
    serializedName: "Service_getUserDelegationKeyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetAccountInfoHeaders = {
    serializedName: "Service_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetAccountInfoExceptionHeaders = {
    serializedName: "Service_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceSubmitBatchHeaders = {
    serializedName: "Service_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceSubmitBatchExceptionHeaders = {
    serializedName: "Service_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceFilterBlobsHeaders = {
    serializedName: "Service_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceFilterBlobsExceptionHeaders = {
    serializedName: "Service_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerCreateHeaders = {
    serializedName: "Container_createHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerCreateExceptionHeaders = {
    serializedName: "Container_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetPropertiesHeaders = {
    serializedName: "Container_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesHeaders",
      modelProperties: {
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "x-ms-has-immutability-policy",
          xmlName: "x-ms-has-immutability-policy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "x-ms-has-legal-hold",
          xmlName: "x-ms-has-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "x-ms-default-encryption-scope",
          xmlName: "x-ms-default-encryption-scope",
          type: {
            name: "String"
          }
        },
        denyEncryptionScopeOverride: {
          serializedName: "x-ms-deny-encryption-scope-override",
          xmlName: "x-ms-deny-encryption-scope-override",
          type: {
            name: "Boolean"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "x-ms-immutable-storage-with-versioning-enabled",
          xmlName: "x-ms-immutable-storage-with-versioning-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetPropertiesExceptionHeaders = {
    serializedName: "Container_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerDeleteHeaders = {
    serializedName: "Container_deleteHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerDeleteExceptionHeaders = {
    serializedName: "Container_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetMetadataHeaders = {
    serializedName: "Container_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetMetadataExceptionHeaders = {
    serializedName: "Container_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetAccessPolicyHeaders = {
    serializedName: "Container_getAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyHeaders",
      modelProperties: {
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetAccessPolicyExceptionHeaders = {
    serializedName: "Container_getAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetAccessPolicyHeaders = {
    serializedName: "Container_setAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetAccessPolicyExceptionHeaders = {
    serializedName: "Container_setAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRestoreHeaders = {
    serializedName: "Container_restoreHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRestoreExceptionHeaders = {
    serializedName: "Container_restoreExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRenameHeaders = {
    serializedName: "Container_renameHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRenameExceptionHeaders = {
    serializedName: "Container_renameExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSubmitBatchHeaders = {
    serializedName: "Container_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSubmitBatchExceptionHeaders = {
    serializedName: "Container_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerFilterBlobsHeaders = {
    serializedName: "Container_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerFilterBlobsExceptionHeaders = {
    serializedName: "Container_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerAcquireLeaseHeaders = {
    serializedName: "Container_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerAcquireLeaseExceptionHeaders = {
    serializedName: "Container_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerReleaseLeaseHeaders = {
    serializedName: "Container_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerReleaseLeaseExceptionHeaders = {
    serializedName: "Container_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRenewLeaseHeaders = {
    serializedName: "Container_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerRenewLeaseExceptionHeaders = {
    serializedName: "Container_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerBreakLeaseHeaders = {
    serializedName: "Container_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerBreakLeaseExceptionHeaders = {
    serializedName: "Container_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerChangeLeaseHeaders = {
    serializedName: "Container_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerChangeLeaseExceptionHeaders = {
    serializedName: "Container_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobFlatSegmentHeaders = {
    serializedName: "Container_listBlobFlatSegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobFlatSegmentExceptionHeaders = {
    serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobHierarchySegmentHeaders = {
    serializedName: "Container_listBlobHierarchySegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobHierarchySegmentExceptionHeaders = {
    serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetAccountInfoHeaders = {
    serializedName: "Container_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var ContainerGetAccountInfoExceptionHeaders = {
    serializedName: "Container_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDownloadHeaders = {
    serializedName: "Blob_downloadHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  var BlobDownloadExceptionHeaders = {
    serializedName: "Blob_downloadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetPropertiesHeaders = {
    serializedName: "Blob_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        isIncrementalCopy: {
          serializedName: "x-ms-incremental-copy",
          xmlName: "x-ms-incremental-copy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "x-ms-copy-destination-snapshot",
          xmlName: "x-ms-copy-destination-snapshot",
          type: {
            name: "String"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        accessTier: {
          serializedName: "x-ms-access-tier",
          xmlName: "x-ms-access-tier",
          type: {
            name: "String"
          }
        },
        accessTierInferred: {
          serializedName: "x-ms-access-tier-inferred",
          xmlName: "x-ms-access-tier-inferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "x-ms-archive-status",
          xmlName: "x-ms-archive-status",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "x-ms-access-tier-change-time",
          xmlName: "x-ms-access-tier-change-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "x-ms-expiry-time",
          xmlName: "x-ms-expiry-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "x-ms-rehydrate-priority",
          xmlName: "x-ms-rehydrate-priority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetPropertiesExceptionHeaders = {
    serializedName: "Blob_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDeleteHeaders = {
    serializedName: "Blob_deleteHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDeleteExceptionHeaders = {
    serializedName: "Blob_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobUndeleteHeaders = {
    serializedName: "Blob_undeleteHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobUndeleteExceptionHeaders = {
    serializedName: "Blob_undeleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetExpiryHeaders = {
    serializedName: "Blob_setExpiryHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobSetExpiryExceptionHeaders = {
    serializedName: "Blob_setExpiryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetHttpHeadersHeaders = {
    serializedName: "Blob_setHttpHeadersHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetHttpHeadersExceptionHeaders = {
    serializedName: "Blob_setHttpHeadersExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetImmutabilityPolicyHeaders = {
    serializedName: "Blob_setImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiry: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        }
      }
    }
  };
  var BlobSetImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDeleteImmutabilityPolicyHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobDeleteImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetLegalHoldHeaders = {
    serializedName: "Blob_setLegalHoldHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var BlobSetLegalHoldExceptionHeaders = {
    serializedName: "Blob_setLegalHoldExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetMetadataHeaders = {
    serializedName: "Blob_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetMetadataExceptionHeaders = {
    serializedName: "Blob_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobAcquireLeaseHeaders = {
    serializedName: "Blob_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobAcquireLeaseExceptionHeaders = {
    serializedName: "Blob_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobReleaseLeaseHeaders = {
    serializedName: "Blob_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobReleaseLeaseExceptionHeaders = {
    serializedName: "Blob_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobRenewLeaseHeaders = {
    serializedName: "Blob_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobRenewLeaseExceptionHeaders = {
    serializedName: "Blob_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobChangeLeaseHeaders = {
    serializedName: "Blob_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobChangeLeaseExceptionHeaders = {
    serializedName: "Blob_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobBreakLeaseHeaders = {
    serializedName: "Blob_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobBreakLeaseExceptionHeaders = {
    serializedName: "Blob_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCreateSnapshotHeaders = {
    serializedName: "Blob_createSnapshotHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotHeaders",
      modelProperties: {
        snapshot: {
          serializedName: "x-ms-snapshot",
          xmlName: "x-ms-snapshot",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCreateSnapshotExceptionHeaders = {
    serializedName: "Blob_createSnapshotExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobStartCopyFromURLHeaders = {
    serializedName: "Blob_startCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobStartCopyFromURLExceptionHeaders = {
    serializedName: "Blob_startCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCopyFromURLHeaders = {
    serializedName: "Blob_copyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          defaultValue: "success",
          isConstant: true,
          serializedName: "x-ms-copy-status",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCopyFromURLExceptionHeaders = {
    serializedName: "Blob_copyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobAbortCopyFromURLHeaders = {
    serializedName: "Blob_abortCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobAbortCopyFromURLExceptionHeaders = {
    serializedName: "Blob_abortCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTierHeaders = {
    serializedName: "Blob_setTierHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTierExceptionHeaders = {
    serializedName: "Blob_setTierExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetAccountInfoHeaders = {
    serializedName: "Blob_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var BlobGetAccountInfoExceptionHeaders = {
    serializedName: "Blob_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobQueryHeaders = {
    serializedName: "Blob_queryHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletionTime: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  var BlobQueryExceptionHeaders = {
    serializedName: "Blob_queryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetTagsHeaders = {
    serializedName: "Blob_getTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetTagsExceptionHeaders = {
    serializedName: "Blob_getTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTagsHeaders = {
    serializedName: "Blob_setTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTagsExceptionHeaders = {
    serializedName: "Blob_setTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCreateHeaders = {
    serializedName: "PageBlob_createHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCreateExceptionHeaders = {
    serializedName: "PageBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesHeaders = {
    serializedName: "PageBlob_uploadPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobClearPagesHeaders = {
    serializedName: "PageBlob_clearPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobClearPagesExceptionHeaders = {
    serializedName: "PageBlob_clearPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesFromURLHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesFromURLExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesHeaders = {
    serializedName: "PageBlob_getPageRangesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesDiffHeaders = {
    serializedName: "PageBlob_getPageRangesDiffHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesDiffExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobResizeHeaders = {
    serializedName: "PageBlob_resizeHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobResizeExceptionHeaders = {
    serializedName: "PageBlob_resizeExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUpdateSequenceNumberHeaders = {
    serializedName: "PageBlob_updateSequenceNumberHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUpdateSequenceNumberExceptionHeaders = {
    serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCopyIncrementalHeaders = {
    serializedName: "PageBlob_copyIncrementalHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCopyIncrementalExceptionHeaders = {
    serializedName: "PageBlob_copyIncrementalExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobCreateHeaders = {
    serializedName: "AppendBlob_createHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobCreateExceptionHeaders = {
    serializedName: "AppendBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockHeaders = {
    serializedName: "AppendBlob_appendBlockHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockFromUrlHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockFromUrlExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobSealHeaders = {
    serializedName: "AppendBlob_sealHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var AppendBlobSealExceptionHeaders = {
    serializedName: "AppendBlob_sealExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobUploadHeaders = {
    serializedName: "BlockBlob_uploadHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobUploadExceptionHeaders = {
    serializedName: "BlockBlob_uploadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobPutBlobFromUrlHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobPutBlobFromUrlExceptionHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockHeaders = {
    serializedName: "BlockBlob_stageBlockHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockFromURLHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockFromURLExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobCommitBlockListHeaders = {
    serializedName: "BlockBlob_commitBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobCommitBlockListExceptionHeaders = {
    serializedName: "BlockBlob_commitBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobGetBlockListHeaders = {
    serializedName: "BlockBlob_getBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobGetBlockListExceptionHeaders = {
    serializedName: "BlockBlob_getBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var Mappers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    AccessPolicy,
    AppendBlobAppendBlockExceptionHeaders,
    AppendBlobAppendBlockFromUrlExceptionHeaders,
    AppendBlobAppendBlockFromUrlHeaders,
    AppendBlobAppendBlockHeaders,
    AppendBlobCreateExceptionHeaders,
    AppendBlobCreateHeaders,
    AppendBlobSealExceptionHeaders,
    AppendBlobSealHeaders,
    ArrowConfiguration,
    ArrowField,
    BlobAbortCopyFromURLExceptionHeaders,
    BlobAbortCopyFromURLHeaders,
    BlobAcquireLeaseExceptionHeaders,
    BlobAcquireLeaseHeaders,
    BlobBreakLeaseExceptionHeaders,
    BlobBreakLeaseHeaders,
    BlobChangeLeaseExceptionHeaders,
    BlobChangeLeaseHeaders,
    BlobCopyFromURLExceptionHeaders,
    BlobCopyFromURLHeaders,
    BlobCreateSnapshotExceptionHeaders,
    BlobCreateSnapshotHeaders,
    BlobDeleteExceptionHeaders,
    BlobDeleteHeaders,
    BlobDeleteImmutabilityPolicyExceptionHeaders,
    BlobDeleteImmutabilityPolicyHeaders,
    BlobDownloadExceptionHeaders,
    BlobDownloadHeaders,
    BlobFlatListSegment,
    BlobGetAccountInfoExceptionHeaders,
    BlobGetAccountInfoHeaders,
    BlobGetPropertiesExceptionHeaders,
    BlobGetPropertiesHeaders,
    BlobGetTagsExceptionHeaders,
    BlobGetTagsHeaders,
    BlobHierarchyListSegment,
    BlobItemInternal,
    BlobName,
    BlobPrefix,
    BlobPropertiesInternal,
    BlobQueryExceptionHeaders,
    BlobQueryHeaders,
    BlobReleaseLeaseExceptionHeaders,
    BlobReleaseLeaseHeaders,
    BlobRenewLeaseExceptionHeaders,
    BlobRenewLeaseHeaders,
    BlobServiceProperties,
    BlobServiceStatistics,
    BlobSetExpiryExceptionHeaders,
    BlobSetExpiryHeaders,
    BlobSetHttpHeadersExceptionHeaders,
    BlobSetHttpHeadersHeaders,
    BlobSetImmutabilityPolicyExceptionHeaders,
    BlobSetImmutabilityPolicyHeaders,
    BlobSetLegalHoldExceptionHeaders,
    BlobSetLegalHoldHeaders,
    BlobSetMetadataExceptionHeaders,
    BlobSetMetadataHeaders,
    BlobSetTagsExceptionHeaders,
    BlobSetTagsHeaders,
    BlobSetTierExceptionHeaders,
    BlobSetTierHeaders,
    BlobStartCopyFromURLExceptionHeaders,
    BlobStartCopyFromURLHeaders,
    BlobTag,
    BlobTags,
    BlobUndeleteExceptionHeaders,
    BlobUndeleteHeaders,
    Block,
    BlockBlobCommitBlockListExceptionHeaders,
    BlockBlobCommitBlockListHeaders,
    BlockBlobGetBlockListExceptionHeaders,
    BlockBlobGetBlockListHeaders,
    BlockBlobPutBlobFromUrlExceptionHeaders,
    BlockBlobPutBlobFromUrlHeaders,
    BlockBlobStageBlockExceptionHeaders,
    BlockBlobStageBlockFromURLExceptionHeaders,
    BlockBlobStageBlockFromURLHeaders,
    BlockBlobStageBlockHeaders,
    BlockBlobUploadExceptionHeaders,
    BlockBlobUploadHeaders,
    BlockList,
    BlockLookupList,
    ClearRange,
    ContainerAcquireLeaseExceptionHeaders,
    ContainerAcquireLeaseHeaders,
    ContainerBreakLeaseExceptionHeaders,
    ContainerBreakLeaseHeaders,
    ContainerChangeLeaseExceptionHeaders,
    ContainerChangeLeaseHeaders,
    ContainerCreateExceptionHeaders,
    ContainerCreateHeaders,
    ContainerDeleteExceptionHeaders,
    ContainerDeleteHeaders,
    ContainerFilterBlobsExceptionHeaders,
    ContainerFilterBlobsHeaders,
    ContainerGetAccessPolicyExceptionHeaders,
    ContainerGetAccessPolicyHeaders,
    ContainerGetAccountInfoExceptionHeaders,
    ContainerGetAccountInfoHeaders,
    ContainerGetPropertiesExceptionHeaders,
    ContainerGetPropertiesHeaders,
    ContainerItem,
    ContainerListBlobFlatSegmentExceptionHeaders,
    ContainerListBlobFlatSegmentHeaders,
    ContainerListBlobHierarchySegmentExceptionHeaders,
    ContainerListBlobHierarchySegmentHeaders,
    ContainerProperties,
    ContainerReleaseLeaseExceptionHeaders,
    ContainerReleaseLeaseHeaders,
    ContainerRenameExceptionHeaders,
    ContainerRenameHeaders,
    ContainerRenewLeaseExceptionHeaders,
    ContainerRenewLeaseHeaders,
    ContainerRestoreExceptionHeaders,
    ContainerRestoreHeaders,
    ContainerSetAccessPolicyExceptionHeaders,
    ContainerSetAccessPolicyHeaders,
    ContainerSetMetadataExceptionHeaders,
    ContainerSetMetadataHeaders,
    ContainerSubmitBatchExceptionHeaders,
    ContainerSubmitBatchHeaders,
    CorsRule,
    DelimitedTextConfiguration,
    FilterBlobItem,
    FilterBlobSegment,
    GeoReplication,
    JsonTextConfiguration,
    KeyInfo,
    ListBlobsFlatSegmentResponse,
    ListBlobsHierarchySegmentResponse,
    ListContainersSegmentResponse,
    Logging,
    Metrics,
    PageBlobClearPagesExceptionHeaders,
    PageBlobClearPagesHeaders,
    PageBlobCopyIncrementalExceptionHeaders,
    PageBlobCopyIncrementalHeaders,
    PageBlobCreateExceptionHeaders,
    PageBlobCreateHeaders,
    PageBlobGetPageRangesDiffExceptionHeaders,
    PageBlobGetPageRangesDiffHeaders,
    PageBlobGetPageRangesExceptionHeaders,
    PageBlobGetPageRangesHeaders,
    PageBlobResizeExceptionHeaders,
    PageBlobResizeHeaders,
    PageBlobUpdateSequenceNumberExceptionHeaders,
    PageBlobUpdateSequenceNumberHeaders,
    PageBlobUploadPagesExceptionHeaders,
    PageBlobUploadPagesFromURLExceptionHeaders,
    PageBlobUploadPagesFromURLHeaders,
    PageBlobUploadPagesHeaders,
    PageList,
    PageRange,
    QueryFormat,
    QueryRequest,
    QuerySerialization,
    RetentionPolicy,
    ServiceFilterBlobsExceptionHeaders,
    ServiceFilterBlobsHeaders,
    ServiceGetAccountInfoExceptionHeaders,
    ServiceGetAccountInfoHeaders,
    ServiceGetPropertiesExceptionHeaders,
    ServiceGetPropertiesHeaders,
    ServiceGetStatisticsExceptionHeaders,
    ServiceGetStatisticsHeaders,
    ServiceGetUserDelegationKeyExceptionHeaders,
    ServiceGetUserDelegationKeyHeaders,
    ServiceListContainersSegmentExceptionHeaders,
    ServiceListContainersSegmentHeaders,
    ServiceSetPropertiesExceptionHeaders,
    ServiceSetPropertiesHeaders,
    ServiceSubmitBatchExceptionHeaders,
    ServiceSubmitBatchHeaders,
    SignedIdentifier,
    StaticWebsite,
    StorageError,
    UserDelegationKey
  });
  var contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  var blobServiceProperties = {
    parameterPath: "blobServiceProperties",
    mapper: BlobServiceProperties
  };
  var accept = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  var url = {
    parameterPath: "url",
    mapper: {
      serializedName: "url",
      required: true,
      xmlName: "url",
      type: {
        name: "String"
      }
    },
    skipEncoding: true
  };
  var restype = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "service",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  var comp = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "properties",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var timeoutInSeconds = {
    parameterPath: ["options", "timeoutInSeconds"],
    mapper: {
      constraints: {
        InclusiveMinimum: 0
      },
      serializedName: "timeout",
      xmlName: "timeout",
      type: {
        name: "Number"
      }
    }
  };
  var version = {
    parameterPath: "version",
    mapper: {
      defaultValue: "2025-01-05",
      isConstant: true,
      serializedName: "x-ms-version",
      type: {
        name: "String"
      }
    }
  };
  var requestId = {
    parameterPath: ["options", "requestId"],
    mapper: {
      serializedName: "x-ms-client-request-id",
      xmlName: "x-ms-client-request-id",
      type: {
        name: "String"
      }
    }
  };
  var accept1 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  var comp1 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "stats",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var comp2 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "list",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var prefix = {
    parameterPath: ["options", "prefix"],
    mapper: {
      serializedName: "prefix",
      xmlName: "prefix",
      type: {
        name: "String"
      }
    }
  };
  var marker = {
    parameterPath: ["options", "marker"],
    mapper: {
      serializedName: "marker",
      xmlName: "marker",
      type: {
        name: "String"
      }
    }
  };
  var maxPageSize = {
    parameterPath: ["options", "maxPageSize"],
    mapper: {
      constraints: {
        InclusiveMinimum: 1
      },
      serializedName: "maxresults",
      xmlName: "maxresults",
      type: {
        name: "Number"
      }
    }
  };
  var include = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListContainersIncludeType",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: ["metadata", "deleted", "system"]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  var keyInfo = {
    parameterPath: "keyInfo",
    mapper: KeyInfo
  };
  var comp3 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "userdelegationkey",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var restype1 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "account",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  var body = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: true,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  var comp4 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "batch",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var contentLength = {
    parameterPath: "contentLength",
    mapper: {
      serializedName: "Content-Length",
      required: true,
      xmlName: "Content-Length",
      type: {
        name: "Number"
      }
    }
  };
  var multipartContentType = {
    parameterPath: "multipartContentType",
    mapper: {
      serializedName: "Content-Type",
      required: true,
      xmlName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  var comp5 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blobs",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var where = {
    parameterPath: ["options", "where"],
    mapper: {
      serializedName: "where",
      xmlName: "where",
      type: {
        name: "String"
      }
    }
  };
  var restype2 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "container",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  var metadata = {
    parameterPath: ["options", "metadata"],
    mapper: {
      serializedName: "x-ms-meta",
      xmlName: "x-ms-meta",
      headerCollectionPrefix: "x-ms-meta-",
      type: {
        name: "Dictionary",
        value: { type: { name: "String" } }
      }
    }
  };
  var access = {
    parameterPath: ["options", "access"],
    mapper: {
      serializedName: "x-ms-blob-public-access",
      xmlName: "x-ms-blob-public-access",
      type: {
        name: "Enum",
        allowedValues: ["container", "blob"]
      }
    }
  };
  var defaultEncryptionScope = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "defaultEncryptionScope"
    ],
    mapper: {
      serializedName: "x-ms-default-encryption-scope",
      xmlName: "x-ms-default-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  var preventEncryptionScopeOverride = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "preventEncryptionScopeOverride"
    ],
    mapper: {
      serializedName: "x-ms-deny-encryption-scope-override",
      xmlName: "x-ms-deny-encryption-scope-override",
      type: {
        name: "Boolean"
      }
    }
  };
  var leaseId = {
    parameterPath: ["options", "leaseAccessConditions", "leaseId"],
    mapper: {
      serializedName: "x-ms-lease-id",
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var ifModifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
    mapper: {
      serializedName: "If-Modified-Since",
      xmlName: "If-Modified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var ifUnmodifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
    mapper: {
      serializedName: "If-Unmodified-Since",
      xmlName: "If-Unmodified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var comp6 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "metadata",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var comp7 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "acl",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var containerAcl = {
    parameterPath: ["options", "containerAcl"],
    mapper: {
      serializedName: "containerAcl",
      xmlName: "SignedIdentifiers",
      xmlIsWrapped: true,
      xmlElementName: "SignedIdentifier",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "SignedIdentifier"
          }
        }
      }
    }
  };
  var comp8 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "undelete",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var deletedContainerName = {
    parameterPath: ["options", "deletedContainerName"],
    mapper: {
      serializedName: "x-ms-deleted-container-name",
      xmlName: "x-ms-deleted-container-name",
      type: {
        name: "String"
      }
    }
  };
  var deletedContainerVersion = {
    parameterPath: ["options", "deletedContainerVersion"],
    mapper: {
      serializedName: "x-ms-deleted-container-version",
      xmlName: "x-ms-deleted-container-version",
      type: {
        name: "String"
      }
    }
  };
  var comp9 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "rename",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var sourceContainerName = {
    parameterPath: "sourceContainerName",
    mapper: {
      serializedName: "x-ms-source-container-name",
      required: true,
      xmlName: "x-ms-source-container-name",
      type: {
        name: "String"
      }
    }
  };
  var sourceLeaseId = {
    parameterPath: ["options", "sourceLeaseId"],
    mapper: {
      serializedName: "x-ms-source-lease-id",
      xmlName: "x-ms-source-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var comp10 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "lease",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var action = {
    parameterPath: "action",
    mapper: {
      defaultValue: "acquire",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var duration = {
    parameterPath: ["options", "duration"],
    mapper: {
      serializedName: "x-ms-lease-duration",
      xmlName: "x-ms-lease-duration",
      type: {
        name: "Number"
      }
    }
  };
  var proposedLeaseId = {
    parameterPath: ["options", "proposedLeaseId"],
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var action1 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "release",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var leaseId1 = {
    parameterPath: "leaseId",
    mapper: {
      serializedName: "x-ms-lease-id",
      required: true,
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var action2 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "renew",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var action3 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "break",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var breakPeriod = {
    parameterPath: ["options", "breakPeriod"],
    mapper: {
      serializedName: "x-ms-lease-break-period",
      xmlName: "x-ms-lease-break-period",
      type: {
        name: "Number"
      }
    }
  };
  var action4 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "change",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var proposedLeaseId1 = {
    parameterPath: "proposedLeaseId",
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      required: true,
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var include1 = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListBlobsIncludeItem",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: [
              "copy",
              "deleted",
              "metadata",
              "snapshots",
              "uncommittedblobs",
              "versions",
              "tags",
              "immutabilitypolicy",
              "legalhold",
              "deletedwithversions"
            ]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  var delimiter = {
    parameterPath: "delimiter",
    mapper: {
      serializedName: "delimiter",
      required: true,
      xmlName: "delimiter",
      type: {
        name: "String"
      }
    }
  };
  var snapshot = {
    parameterPath: ["options", "snapshot"],
    mapper: {
      serializedName: "snapshot",
      xmlName: "snapshot",
      type: {
        name: "String"
      }
    }
  };
  var versionId = {
    parameterPath: ["options", "versionId"],
    mapper: {
      serializedName: "versionid",
      xmlName: "versionid",
      type: {
        name: "String"
      }
    }
  };
  var range = {
    parameterPath: ["options", "range"],
    mapper: {
      serializedName: "x-ms-range",
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  var rangeGetContentMD5 = {
    parameterPath: ["options", "rangeGetContentMD5"],
    mapper: {
      serializedName: "x-ms-range-get-content-md5",
      xmlName: "x-ms-range-get-content-md5",
      type: {
        name: "Boolean"
      }
    }
  };
  var rangeGetContentCRC64 = {
    parameterPath: ["options", "rangeGetContentCRC64"],
    mapper: {
      serializedName: "x-ms-range-get-content-crc64",
      xmlName: "x-ms-range-get-content-crc64",
      type: {
        name: "Boolean"
      }
    }
  };
  var encryptionKey = {
    parameterPath: ["options", "cpkInfo", "encryptionKey"],
    mapper: {
      serializedName: "x-ms-encryption-key",
      xmlName: "x-ms-encryption-key",
      type: {
        name: "String"
      }
    }
  };
  var encryptionKeySha256 = {
    parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
    mapper: {
      serializedName: "x-ms-encryption-key-sha256",
      xmlName: "x-ms-encryption-key-sha256",
      type: {
        name: "String"
      }
    }
  };
  var encryptionAlgorithm = {
    parameterPath: ["options", "cpkInfo", "encryptionAlgorithm"],
    mapper: {
      serializedName: "x-ms-encryption-algorithm",
      xmlName: "x-ms-encryption-algorithm",
      type: {
        name: "String"
      }
    }
  };
  var ifMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
    mapper: {
      serializedName: "If-Match",
      xmlName: "If-Match",
      type: {
        name: "String"
      }
    }
  };
  var ifNoneMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
    mapper: {
      serializedName: "If-None-Match",
      xmlName: "If-None-Match",
      type: {
        name: "String"
      }
    }
  };
  var ifTags = {
    parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
    mapper: {
      serializedName: "x-ms-if-tags",
      xmlName: "x-ms-if-tags",
      type: {
        name: "String"
      }
    }
  };
  var deleteSnapshots = {
    parameterPath: ["options", "deleteSnapshots"],
    mapper: {
      serializedName: "x-ms-delete-snapshots",
      xmlName: "x-ms-delete-snapshots",
      type: {
        name: "Enum",
        allowedValues: ["include", "only"]
      }
    }
  };
  var blobDeleteType = {
    parameterPath: ["options", "blobDeleteType"],
    mapper: {
      serializedName: "deletetype",
      xmlName: "deletetype",
      type: {
        name: "String"
      }
    }
  };
  var comp11 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "expiry",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var expiryOptions = {
    parameterPath: "expiryOptions",
    mapper: {
      serializedName: "x-ms-expiry-option",
      required: true,
      xmlName: "x-ms-expiry-option",
      type: {
        name: "String"
      }
    }
  };
  var expiresOn = {
    parameterPath: ["options", "expiresOn"],
    mapper: {
      serializedName: "x-ms-expiry-time",
      xmlName: "x-ms-expiry-time",
      type: {
        name: "String"
      }
    }
  };
  var blobCacheControl = {
    parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
    mapper: {
      serializedName: "x-ms-blob-cache-control",
      xmlName: "x-ms-blob-cache-control",
      type: {
        name: "String"
      }
    }
  };
  var blobContentType = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
    mapper: {
      serializedName: "x-ms-blob-content-type",
      xmlName: "x-ms-blob-content-type",
      type: {
        name: "String"
      }
    }
  };
  var blobContentMD5 = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
    mapper: {
      serializedName: "x-ms-blob-content-md5",
      xmlName: "x-ms-blob-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  var blobContentEncoding = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
    mapper: {
      serializedName: "x-ms-blob-content-encoding",
      xmlName: "x-ms-blob-content-encoding",
      type: {
        name: "String"
      }
    }
  };
  var blobContentLanguage = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
    mapper: {
      serializedName: "x-ms-blob-content-language",
      xmlName: "x-ms-blob-content-language",
      type: {
        name: "String"
      }
    }
  };
  var blobContentDisposition = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
    mapper: {
      serializedName: "x-ms-blob-content-disposition",
      xmlName: "x-ms-blob-content-disposition",
      type: {
        name: "String"
      }
    }
  };
  var comp12 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "immutabilityPolicies",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var immutabilityPolicyExpiry = {
    parameterPath: ["options", "immutabilityPolicyExpiry"],
    mapper: {
      serializedName: "x-ms-immutability-policy-until-date",
      xmlName: "x-ms-immutability-policy-until-date",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var immutabilityPolicyMode = {
    parameterPath: ["options", "immutabilityPolicyMode"],
    mapper: {
      serializedName: "x-ms-immutability-policy-mode",
      xmlName: "x-ms-immutability-policy-mode",
      type: {
        name: "Enum",
        allowedValues: ["Mutable", "Unlocked", "Locked"]
      }
    }
  };
  var comp13 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "legalhold",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var legalHold = {
    parameterPath: "legalHold",
    mapper: {
      serializedName: "x-ms-legal-hold",
      required: true,
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  var encryptionScope = {
    parameterPath: ["options", "encryptionScope"],
    mapper: {
      serializedName: "x-ms-encryption-scope",
      xmlName: "x-ms-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  var comp14 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "snapshot",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var tier = {
    parameterPath: ["options", "tier"],
    mapper: {
      serializedName: "x-ms-access-tier",
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  var rehydratePriority = {
    parameterPath: ["options", "rehydratePriority"],
    mapper: {
      serializedName: "x-ms-rehydrate-priority",
      xmlName: "x-ms-rehydrate-priority",
      type: {
        name: "Enum",
        allowedValues: ["High", "Standard"]
      }
    }
  };
  var sourceIfModifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfModifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-modified-since",
      xmlName: "x-ms-source-if-modified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var sourceIfUnmodifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfUnmodifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-unmodified-since",
      xmlName: "x-ms-source-if-unmodified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var sourceIfMatch = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfMatch"],
    mapper: {
      serializedName: "x-ms-source-if-match",
      xmlName: "x-ms-source-if-match",
      type: {
        name: "String"
      }
    }
  };
  var sourceIfNoneMatch = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfNoneMatch"
    ],
    mapper: {
      serializedName: "x-ms-source-if-none-match",
      xmlName: "x-ms-source-if-none-match",
      type: {
        name: "String"
      }
    }
  };
  var sourceIfTags = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfTags"],
    mapper: {
      serializedName: "x-ms-source-if-tags",
      xmlName: "x-ms-source-if-tags",
      type: {
        name: "String"
      }
    }
  };
  var copySource = {
    parameterPath: "copySource",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: true,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  var blobTagsString = {
    parameterPath: ["options", "blobTagsString"],
    mapper: {
      serializedName: "x-ms-tags",
      xmlName: "x-ms-tags",
      type: {
        name: "String"
      }
    }
  };
  var sealBlob = {
    parameterPath: ["options", "sealBlob"],
    mapper: {
      serializedName: "x-ms-seal-blob",
      xmlName: "x-ms-seal-blob",
      type: {
        name: "Boolean"
      }
    }
  };
  var legalHold1 = {
    parameterPath: ["options", "legalHold"],
    mapper: {
      serializedName: "x-ms-legal-hold",
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  var xMsRequiresSync = {
    parameterPath: "xMsRequiresSync",
    mapper: {
      defaultValue: "true",
      isConstant: true,
      serializedName: "x-ms-requires-sync",
      type: {
        name: "String"
      }
    }
  };
  var sourceContentMD5 = {
    parameterPath: ["options", "sourceContentMD5"],
    mapper: {
      serializedName: "x-ms-source-content-md5",
      xmlName: "x-ms-source-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  var copySourceAuthorization = {
    parameterPath: ["options", "copySourceAuthorization"],
    mapper: {
      serializedName: "x-ms-copy-source-authorization",
      xmlName: "x-ms-copy-source-authorization",
      type: {
        name: "String"
      }
    }
  };
  var copySourceTags = {
    parameterPath: ["options", "copySourceTags"],
    mapper: {
      serializedName: "x-ms-copy-source-tag-option",
      xmlName: "x-ms-copy-source-tag-option",
      type: {
        name: "Enum",
        allowedValues: ["REPLACE", "COPY"]
      }
    }
  };
  var comp15 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "copy",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var copyActionAbortConstant = {
    parameterPath: "copyActionAbortConstant",
    mapper: {
      defaultValue: "abort",
      isConstant: true,
      serializedName: "x-ms-copy-action",
      type: {
        name: "String"
      }
    }
  };
  var copyId = {
    parameterPath: "copyId",
    mapper: {
      serializedName: "copyid",
      required: true,
      xmlName: "copyid",
      type: {
        name: "String"
      }
    }
  };
  var comp16 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tier",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var tier1 = {
    parameterPath: "tier",
    mapper: {
      serializedName: "x-ms-access-tier",
      required: true,
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  var queryRequest = {
    parameterPath: ["options", "queryRequest"],
    mapper: QueryRequest
  };
  var comp17 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "query",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var comp18 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tags",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var tags = {
    parameterPath: ["options", "tags"],
    mapper: BlobTags
  };
  var transactionalContentMD5 = {
    parameterPath: ["options", "transactionalContentMD5"],
    mapper: {
      serializedName: "Content-MD5",
      xmlName: "Content-MD5",
      type: {
        name: "ByteArray"
      }
    }
  };
  var transactionalContentCrc64 = {
    parameterPath: ["options", "transactionalContentCrc64"],
    mapper: {
      serializedName: "x-ms-content-crc64",
      xmlName: "x-ms-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  var blobType = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "PageBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  var blobContentLength = {
    parameterPath: "blobContentLength",
    mapper: {
      serializedName: "x-ms-blob-content-length",
      required: true,
      xmlName: "x-ms-blob-content-length",
      type: {
        name: "Number"
      }
    }
  };
  var blobSequenceNumber = {
    parameterPath: ["options", "blobSequenceNumber"],
    mapper: {
      defaultValue: 0,
      serializedName: "x-ms-blob-sequence-number",
      xmlName: "x-ms-blob-sequence-number",
      type: {
        name: "Number"
      }
    }
  };
  var contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/octet-stream",
      isConstant: true,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  var body1 = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: true,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  var accept2 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  var comp19 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "page",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var pageWrite = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "update",
      isConstant: true,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  var ifSequenceNumberLessThanOrEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThanOrEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-le",
      xmlName: "x-ms-if-sequence-number-le",
      type: {
        name: "Number"
      }
    }
  };
  var ifSequenceNumberLessThan = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThan"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-lt",
      xmlName: "x-ms-if-sequence-number-lt",
      type: {
        name: "Number"
      }
    }
  };
  var ifSequenceNumberEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-eq",
      xmlName: "x-ms-if-sequence-number-eq",
      type: {
        name: "Number"
      }
    }
  };
  var pageWrite1 = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "clear",
      isConstant: true,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  var sourceUrl = {
    parameterPath: "sourceUrl",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: true,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  var sourceRange = {
    parameterPath: "sourceRange",
    mapper: {
      serializedName: "x-ms-source-range",
      required: true,
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  var sourceContentCrc64 = {
    parameterPath: ["options", "sourceContentCrc64"],
    mapper: {
      serializedName: "x-ms-source-content-crc64",
      xmlName: "x-ms-source-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  var range1 = {
    parameterPath: "range",
    mapper: {
      serializedName: "x-ms-range",
      required: true,
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  var comp20 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "pagelist",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var prevsnapshot = {
    parameterPath: ["options", "prevsnapshot"],
    mapper: {
      serializedName: "prevsnapshot",
      xmlName: "prevsnapshot",
      type: {
        name: "String"
      }
    }
  };
  var prevSnapshotUrl = {
    parameterPath: ["options", "prevSnapshotUrl"],
    mapper: {
      serializedName: "x-ms-previous-snapshot-url",
      xmlName: "x-ms-previous-snapshot-url",
      type: {
        name: "String"
      }
    }
  };
  var sequenceNumberAction = {
    parameterPath: "sequenceNumberAction",
    mapper: {
      serializedName: "x-ms-sequence-number-action",
      required: true,
      xmlName: "x-ms-sequence-number-action",
      type: {
        name: "Enum",
        allowedValues: ["max", "update", "increment"]
      }
    }
  };
  var comp21 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "incrementalcopy",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var blobType1 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "AppendBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  var comp22 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "appendblock",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var maxSize = {
    parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
    mapper: {
      serializedName: "x-ms-blob-condition-maxsize",
      xmlName: "x-ms-blob-condition-maxsize",
      type: {
        name: "Number"
      }
    }
  };
  var appendPosition = {
    parameterPath: [
      "options",
      "appendPositionAccessConditions",
      "appendPosition"
    ],
    mapper: {
      serializedName: "x-ms-blob-condition-appendpos",
      xmlName: "x-ms-blob-condition-appendpos",
      type: {
        name: "Number"
      }
    }
  };
  var sourceRange1 = {
    parameterPath: ["options", "sourceRange"],
    mapper: {
      serializedName: "x-ms-source-range",
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  var comp23 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "seal",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var blobType2 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "BlockBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  var copySourceBlobProperties = {
    parameterPath: ["options", "copySourceBlobProperties"],
    mapper: {
      serializedName: "x-ms-copy-source-blob-properties",
      xmlName: "x-ms-copy-source-blob-properties",
      type: {
        name: "Boolean"
      }
    }
  };
  var comp24 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "block",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var blockId = {
    parameterPath: "blockId",
    mapper: {
      serializedName: "blockid",
      required: true,
      xmlName: "blockid",
      type: {
        name: "String"
      }
    }
  };
  var blocks = {
    parameterPath: "blocks",
    mapper: BlockLookupList
  };
  var comp25 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blocklist",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var listType = {
    parameterPath: "listType",
    mapper: {
      defaultValue: "committed",
      serializedName: "blocklisttype",
      required: true,
      xmlName: "blocklisttype",
      type: {
        name: "Enum",
        allowedValues: ["committed", "uncommitted", "all"]
      }
    }
  };

  class ServiceImpl {
    constructor(client) {
      this.client = client;
    }
    setProperties(blobServiceProperties2, options) {
      return this.client.sendOperationRequest({ blobServiceProperties: blobServiceProperties2, options }, setPropertiesOperationSpec);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec$2);
    }
    getStatistics(options) {
      return this.client.sendOperationRequest({ options }, getStatisticsOperationSpec);
    }
    listContainersSegment(options) {
      return this.client.sendOperationRequest({ options }, listContainersSegmentOperationSpec);
    }
    getUserDelegationKey(keyInfo2, options) {
      return this.client.sendOperationRequest({ keyInfo: keyInfo2, options }, getUserDelegationKeyOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec$2);
    }
    submitBatch(contentLength2, multipartContentType2, body2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, multipartContentType: multipartContentType2, body: body2, options }, submitBatchOperationSpec$1);
    }
    filterBlobs(options) {
      return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec$1);
    }
  }
  var xmlSerializer$5 = coreClient__namespace.createSerializer(Mappers, true);
  var setPropertiesOperationSpec = {
    path: "/",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: ServiceSetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceSetPropertiesExceptionHeaders
      }
    },
    requestBody: blobServiceProperties,
    queryParameters: [
      restype,
      comp,
      timeoutInSeconds
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$5
  };
  var getPropertiesOperationSpec$2 = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlobServiceProperties,
        headersMapper: ServiceGetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      restype,
      comp,
      timeoutInSeconds
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var getStatisticsOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlobServiceStatistics,
        headersMapper: ServiceGetStatisticsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetStatisticsExceptionHeaders
      }
    },
    queryParameters: [
      restype,
      timeoutInSeconds,
      comp1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var listContainersSegmentOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: ListContainersSegmentResponse,
        headersMapper: ServiceListContainersSegmentHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceListContainersSegmentExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp2,
      prefix,
      marker,
      maxPageSize,
      include
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var getUserDelegationKeyOperationSpec = {
    path: "/",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: UserDelegationKey,
        headersMapper: ServiceGetUserDelegationKeyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetUserDelegationKeyExceptionHeaders
      }
    },
    requestBody: keyInfo,
    queryParameters: [
      restype,
      timeoutInSeconds,
      comp3
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$5
  };
  var getAccountInfoOperationSpec$2 = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: ServiceGetAccountInfoHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      comp,
      timeoutInSeconds,
      restype1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var submitBatchOperationSpec$1 = {
    path: "/",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: ServiceSubmitBatchHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceSubmitBatchExceptionHeaders
      }
    },
    requestBody: body,
    queryParameters: [timeoutInSeconds, comp4],
    urlParameters: [url],
    headerParameters: [
      accept,
      version,
      requestId,
      contentLength,
      multipartContentType
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$5
  };
  var filterBlobsOperationSpec$1 = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: FilterBlobSegment,
        headersMapper: ServiceFilterBlobsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      comp5,
      where
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };

  class ContainerImpl {
    constructor(client) {
      this.client = client;
    }
    create(options) {
      return this.client.sendOperationRequest({ options }, createOperationSpec$2);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec$1);
    }
    delete(options) {
      return this.client.sendOperationRequest({ options }, deleteOperationSpec$1);
    }
    setMetadata(options) {
      return this.client.sendOperationRequest({ options }, setMetadataOperationSpec$1);
    }
    getAccessPolicy(options) {
      return this.client.sendOperationRequest({ options }, getAccessPolicyOperationSpec);
    }
    setAccessPolicy(options) {
      return this.client.sendOperationRequest({ options }, setAccessPolicyOperationSpec);
    }
    restore(options) {
      return this.client.sendOperationRequest({ options }, restoreOperationSpec);
    }
    rename(sourceContainerName2, options) {
      return this.client.sendOperationRequest({ sourceContainerName: sourceContainerName2, options }, renameOperationSpec);
    }
    submitBatch(contentLength2, multipartContentType2, body2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, multipartContentType: multipartContentType2, body: body2, options }, submitBatchOperationSpec);
    }
    filterBlobs(options) {
      return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec);
    }
    acquireLease(options) {
      return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec$1);
    }
    releaseLease(leaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options }, releaseLeaseOperationSpec$1);
    }
    renewLease(leaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options }, renewLeaseOperationSpec$1);
    }
    breakLease(options) {
      return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec$1);
    }
    changeLease(leaseId2, proposedLeaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, proposedLeaseId: proposedLeaseId2, options }, changeLeaseOperationSpec$1);
    }
    listBlobFlatSegment(options) {
      return this.client.sendOperationRequest({ options }, listBlobFlatSegmentOperationSpec);
    }
    listBlobHierarchySegment(delimiter2, options) {
      return this.client.sendOperationRequest({ delimiter: delimiter2, options }, listBlobHierarchySegmentOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec$1);
    }
  }
  var xmlSerializer$4 = coreClient__namespace.createSerializer(Mappers, true);
  var createOperationSpec$2 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: ContainerCreateHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerCreateExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      access,
      defaultEncryptionScope,
      preventEncryptionScopeOverride
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var getPropertiesOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: ContainerGetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var deleteOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: ContainerDeleteHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerDeleteExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var setMetadataOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerSetMetadataHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerSetMetadataExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp6
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var getAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: {
            name: "Sequence",
            element: {
              type: { name: "Composite", className: "SignedIdentifier" }
            }
          },
          serializedName: "SignedIdentifiers",
          xmlName: "SignedIdentifiers",
          xmlIsWrapped: true,
          xmlElementName: "SignedIdentifier"
        },
        headersMapper: ContainerGetAccessPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerGetAccessPolicyExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp7
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var setAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerSetAccessPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerSetAccessPolicyExceptionHeaders
      }
    },
    requestBody: containerAcl,
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp7
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      access,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$4
  };
  var restoreOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: ContainerRestoreHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerRestoreExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp8
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      deletedContainerName,
      deletedContainerVersion
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var renameOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerRenameHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerRenameExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp9
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      sourceContainerName,
      sourceLeaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var submitBatchOperationSpec = {
    path: "/{containerName}",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: ContainerSubmitBatchHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerSubmitBatchExceptionHeaders
      }
    },
    requestBody: body,
    queryParameters: [
      timeoutInSeconds,
      comp4,
      restype2
    ],
    urlParameters: [url],
    headerParameters: [
      accept,
      version,
      requestId,
      contentLength,
      multipartContentType
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$4
  };
  var filterBlobsOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: FilterBlobSegment,
        headersMapper: ContainerFilterBlobsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      comp5,
      where,
      restype2
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var acquireLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: ContainerAcquireLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action,
      duration,
      proposedLeaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var releaseLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerReleaseLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action1,
      leaseId1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var renewLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerRenewLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action2
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var breakLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: ContainerBreakLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action3,
      breakPeriod
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var changeLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerChangeLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action4,
      proposedLeaseId1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var listBlobFlatSegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: ListBlobsFlatSegmentResponse,
        headersMapper: ContainerListBlobFlatSegmentHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerListBlobFlatSegmentExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp2,
      prefix,
      marker,
      maxPageSize,
      restype2,
      include1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var listBlobHierarchySegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: ListBlobsHierarchySegmentResponse,
        headersMapper: ContainerListBlobHierarchySegmentHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerListBlobHierarchySegmentExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp2,
      prefix,
      marker,
      maxPageSize,
      restype2,
      include1,
      delimiter
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var getAccountInfoOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: ContainerGetAccountInfoHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      comp,
      timeoutInSeconds,
      restype1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };

  class BlobImpl {
    constructor(client) {
      this.client = client;
    }
    download(options) {
      return this.client.sendOperationRequest({ options }, downloadOperationSpec);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
    }
    delete(options) {
      return this.client.sendOperationRequest({ options }, deleteOperationSpec);
    }
    undelete(options) {
      return this.client.sendOperationRequest({ options }, undeleteOperationSpec);
    }
    setExpiry(expiryOptions2, options) {
      return this.client.sendOperationRequest({ expiryOptions: expiryOptions2, options }, setExpiryOperationSpec);
    }
    setHttpHeaders(options) {
      return this.client.sendOperationRequest({ options }, setHttpHeadersOperationSpec);
    }
    setImmutabilityPolicy(options) {
      return this.client.sendOperationRequest({ options }, setImmutabilityPolicyOperationSpec);
    }
    deleteImmutabilityPolicy(options) {
      return this.client.sendOperationRequest({ options }, deleteImmutabilityPolicyOperationSpec);
    }
    setLegalHold(legalHold2, options) {
      return this.client.sendOperationRequest({ legalHold: legalHold2, options }, setLegalHoldOperationSpec);
    }
    setMetadata(options) {
      return this.client.sendOperationRequest({ options }, setMetadataOperationSpec);
    }
    acquireLease(options) {
      return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec);
    }
    releaseLease(leaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options }, releaseLeaseOperationSpec);
    }
    renewLease(leaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options }, renewLeaseOperationSpec);
    }
    changeLease(leaseId2, proposedLeaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, proposedLeaseId: proposedLeaseId2, options }, changeLeaseOperationSpec);
    }
    breakLease(options) {
      return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec);
    }
    createSnapshot(options) {
      return this.client.sendOperationRequest({ options }, createSnapshotOperationSpec);
    }
    startCopyFromURL(copySource2, options) {
      return this.client.sendOperationRequest({ copySource: copySource2, options }, startCopyFromURLOperationSpec);
    }
    copyFromURL(copySource2, options) {
      return this.client.sendOperationRequest({ copySource: copySource2, options }, copyFromURLOperationSpec);
    }
    abortCopyFromURL(copyId2, options) {
      return this.client.sendOperationRequest({ copyId: copyId2, options }, abortCopyFromURLOperationSpec);
    }
    setTier(tier2, options) {
      return this.client.sendOperationRequest({ tier: tier2, options }, setTierOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
    }
    query(options) {
      return this.client.sendOperationRequest({ options }, queryOperationSpec);
    }
    getTags(options) {
      return this.client.sendOperationRequest({ options }, getTagsOperationSpec);
    }
    setTags(options) {
      return this.client.sendOperationRequest({ options }, setTagsOperationSpec);
    }
  }
  var xmlSerializer$3 = coreClient__namespace.createSerializer(Mappers, true);
  var downloadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobDownloadHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobDownloadHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobDownloadExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      rangeGetContentMD5,
      rangeGetContentCRC64,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var getPropertiesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "HEAD",
    responses: {
      200: {
        headersMapper: BlobGetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var deleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: BlobDeleteHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobDeleteExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      blobDeleteType
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      deleteSnapshots
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var undeleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobUndeleteHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobUndeleteExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp8],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setExpiryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetExpiryHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetExpiryExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp11],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      expiryOptions,
      expiresOn
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setHttpHeadersOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetHttpHeadersHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetHttpHeadersExceptionHeaders
      }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp12
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifUnmodifiedSince,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var deleteImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      200: {
        headersMapper: BlobDeleteImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobDeleteImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp12
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setLegalHoldOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetLegalHoldHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetLegalHoldExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp13
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      legalHold
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setMetadataOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetMetadataHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetMetadataExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp6],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var acquireLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlobAcquireLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action,
      duration,
      proposedLeaseId,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var releaseLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobReleaseLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action1,
      leaseId1,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var renewLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobRenewLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action2,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var changeLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobChangeLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action4,
      proposedLeaseId1,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var breakLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: BlobBreakLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action3,
      breakPeriod,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var createSnapshotOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlobCreateSnapshotHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobCreateSnapshotExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp14],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var startCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: BlobStartCopyFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobStartCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      tier,
      rehydratePriority,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceIfTags,
      copySource,
      blobTagsString,
      sealBlob,
      legalHold1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var copyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: BlobCopyFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      copySource,
      blobTagsString,
      legalHold1,
      xMsRequiresSync,
      sourceContentMD5,
      copySourceAuthorization,
      copySourceTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var abortCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: BlobAbortCopyFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobAbortCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp15,
      copyId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      copyActionAbortConstant
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setTierOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetTierHeaders
      },
      202: {
        headersMapper: BlobSetTierHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetTierExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp16
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifTags,
      rehydratePriority,
      tier1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var getAccountInfoOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: BlobGetAccountInfoHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      comp,
      timeoutInSeconds,
      restype1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var queryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobQueryHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobQueryHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobQueryExceptionHeaders
      }
    },
    requestBody: queryRequest,
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      comp17
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$3
  };
  var getTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlobTags,
        headersMapper: BlobGetTagsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobGetTagsExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp18
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: BlobSetTagsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetTagsExceptionHeaders
      }
    },
    requestBody: tags,
    queryParameters: [
      timeoutInSeconds,
      versionId,
      comp18
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      leaseId,
      ifTags,
      transactionalContentMD5,
      transactionalContentCrc64
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$3
  };

  class PageBlobImpl {
    constructor(client) {
      this.client = client;
    }
    create(contentLength2, blobContentLength2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, blobContentLength: blobContentLength2, options }, createOperationSpec$1);
    }
    uploadPages(contentLength2, body2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, body: body2, options }, uploadPagesOperationSpec);
    }
    clearPages(contentLength2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, options }, clearPagesOperationSpec);
    }
    uploadPagesFromURL(sourceUrl2, sourceRange2, contentLength2, range2, options) {
      return this.client.sendOperationRequest({ sourceUrl: sourceUrl2, sourceRange: sourceRange2, contentLength: contentLength2, range: range2, options }, uploadPagesFromURLOperationSpec);
    }
    getPageRanges(options) {
      return this.client.sendOperationRequest({ options }, getPageRangesOperationSpec);
    }
    getPageRangesDiff(options) {
      return this.client.sendOperationRequest({ options }, getPageRangesDiffOperationSpec);
    }
    resize(blobContentLength2, options) {
      return this.client.sendOperationRequest({ blobContentLength: blobContentLength2, options }, resizeOperationSpec);
    }
    updateSequenceNumber(sequenceNumberAction2, options) {
      return this.client.sendOperationRequest({ sequenceNumberAction: sequenceNumberAction2, options }, updateSequenceNumberOperationSpec);
    }
    copyIncremental(copySource2, options) {
      return this.client.sendOperationRequest({ copySource: copySource2, options }, copyIncrementalOperationSpec);
    }
  }
  var xmlSerializer$2 = coreClient__namespace.createSerializer(Mappers, true);
  var createOperationSpec$1 = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobCreateHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobCreateExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      blobTagsString,
      legalHold1,
      blobType,
      blobContentLength,
      blobSequenceNumber
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var uploadPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobUploadPagesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobUploadPagesExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [timeoutInSeconds, comp19],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2,
      pageWrite,
      ifSequenceNumberLessThanOrEqualTo,
      ifSequenceNumberLessThan,
      ifSequenceNumberEqualTo
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer$2
  };
  var clearPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobClearPagesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobClearPagesExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp19],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      ifSequenceNumberLessThanOrEqualTo,
      ifSequenceNumberLessThan,
      ifSequenceNumberEqualTo,
      pageWrite1
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var uploadPagesFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobUploadPagesFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobUploadPagesFromURLExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp19],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceContentMD5,
      copySourceAuthorization,
      pageWrite,
      ifSequenceNumberLessThanOrEqualTo,
      ifSequenceNumberLessThan,
      ifSequenceNumberEqualTo,
      sourceUrl,
      sourceRange,
      sourceContentCrc64,
      range1
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var getPageRangesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: PageList,
        headersMapper: PageBlobGetPageRangesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobGetPageRangesExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      snapshot,
      comp20
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var getPageRangesDiffOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: PageList,
        headersMapper: PageBlobGetPageRangesDiffHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobGetPageRangesDiffExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      snapshot,
      comp20,
      prevsnapshot
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      ifMatch,
      ifNoneMatch,
      ifTags,
      prevSnapshotUrl
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var resizeOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: PageBlobResizeHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobResizeExceptionHeaders
      }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      blobContentLength
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var updateSequenceNumberOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: PageBlobUpdateSequenceNumberHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobUpdateSequenceNumberExceptionHeaders
      }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobSequenceNumber,
      sequenceNumberAction
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var copyIncrementalOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: PageBlobCopyIncrementalHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobCopyIncrementalExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp21],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      copySource
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };

  class AppendBlobImpl {
    constructor(client) {
      this.client = client;
    }
    create(contentLength2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, options }, createOperationSpec);
    }
    appendBlock(contentLength2, body2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, body: body2, options }, appendBlockOperationSpec);
    }
    appendBlockFromUrl(sourceUrl2, contentLength2, options) {
      return this.client.sendOperationRequest({ sourceUrl: sourceUrl2, contentLength: contentLength2, options }, appendBlockFromUrlOperationSpec);
    }
    seal(options) {
      return this.client.sendOperationRequest({ options }, sealOperationSpec);
    }
  }
  var xmlSerializer$1 = coreClient__namespace.createSerializer(Mappers, true);
  var createOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: AppendBlobCreateHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobCreateExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      blobTagsString,
      legalHold1,
      blobType1
    ],
    isXML: true,
    serializer: xmlSerializer$1
  };
  var appendBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: AppendBlobAppendBlockHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobAppendBlockExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [timeoutInSeconds, comp22],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2,
      maxSize,
      appendPosition
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer$1
  };
  var appendBlockFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: AppendBlobAppendBlockFromUrlHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobAppendBlockFromUrlExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp22],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceContentMD5,
      copySourceAuthorization,
      transactionalContentMD5,
      sourceUrl,
      sourceContentCrc64,
      maxSize,
      appendPosition,
      sourceRange1
    ],
    isXML: true,
    serializer: xmlSerializer$1
  };
  var sealOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: AppendBlobSealHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobSealExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp23],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      appendPosition
    ],
    isXML: true,
    serializer: xmlSerializer$1
  };

  class BlockBlobImpl {
    constructor(client) {
      this.client = client;
    }
    upload(contentLength2, body2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, body: body2, options }, uploadOperationSpec);
    }
    putBlobFromUrl(contentLength2, copySource2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, copySource: copySource2, options }, putBlobFromUrlOperationSpec);
    }
    stageBlock(blockId2, contentLength2, body2, options) {
      return this.client.sendOperationRequest({ blockId: blockId2, contentLength: contentLength2, body: body2, options }, stageBlockOperationSpec);
    }
    stageBlockFromURL(blockId2, contentLength2, sourceUrl2, options) {
      return this.client.sendOperationRequest({ blockId: blockId2, contentLength: contentLength2, sourceUrl: sourceUrl2, options }, stageBlockFromURLOperationSpec);
    }
    commitBlockList(blocks2, options) {
      return this.client.sendOperationRequest({ blocks: blocks2, options }, commitBlockListOperationSpec);
    }
    getBlockList(listType2, options) {
      return this.client.sendOperationRequest({ listType: listType2, options }, getBlockListOperationSpec);
    }
  }
  var xmlSerializer = coreClient__namespace.createSerializer(Mappers, true);
  var uploadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobUploadHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobUploadExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      blobTagsString,
      legalHold1,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2,
      blobType2
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  var putBlobFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobPutBlobFromUrlHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobPutBlobFromUrlExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      encryptionScope,
      tier,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceIfTags,
      copySource,
      blobTagsString,
      sourceContentMD5,
      copySourceAuthorization,
      copySourceTags,
      transactionalContentMD5,
      blobType2,
      copySourceBlobProperties
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var stageBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobStageBlockHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobStageBlockExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [
      timeoutInSeconds,
      comp24,
      blockId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      leaseId,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      encryptionScope,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  var stageBlockFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobStageBlockFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobStageBlockFromURLExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp24,
      blockId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      encryptionScope,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceContentMD5,
      copySourceAuthorization,
      sourceUrl,
      sourceContentCrc64,
      sourceRange1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var commitBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobCommitBlockListHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobCommitBlockListExceptionHeaders
      }
    },
    requestBody: blocks,
    queryParameters: [timeoutInSeconds, comp25],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      blobTagsString,
      legalHold1,
      transactionalContentMD5,
      transactionalContentCrc64
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  var getBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlockList,
        headersMapper: BlockBlobGetBlockListHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobGetBlockListExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      comp25,
      listType
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var StorageClient$1 = class StorageClient2 extends coreHttpCompat__namespace.ExtendedServiceClient {
    constructor(url2, options) {
      var _a, _b;
      if (url2 === undefined) {
        throw new Error("'url' cannot be null");
      }
      if (!options) {
        options = {};
      }
      const defaults = {
        requestContentType: "application/json; charset=utf-8"
      };
      const packageDetails = `azsdk-js-azure-storage-blob/12.26.0`;
      const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
      const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
        userAgentPrefix
      }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== undefined ? _a : options.baseUri) !== null && _b !== undefined ? _b : "{url}" });
      super(optionsWithDefaults);
      this.url = url2;
      this.version = options.version || "2025-01-05";
      this.service = new ServiceImpl(this);
      this.container = new ContainerImpl(this);
      this.blob = new BlobImpl(this);
      this.pageBlob = new PageBlobImpl(this);
      this.appendBlob = new AppendBlobImpl(this);
      this.blockBlob = new BlockBlobImpl(this);
    }
  };

  class StorageContextClient extends StorageClient$1 {
    async sendOperationRequest(operationArguments, operationSpec) {
      const operationSpecToSend = Object.assign({}, operationSpec);
      if (operationSpecToSend.path === "/{containerName}" || operationSpecToSend.path === "/{containerName}/{blob}") {
        operationSpecToSend.path = "";
      }
      return super.sendOperationRequest(operationArguments, operationSpecToSend);
    }
  }

  class StorageClient {
    constructor(url2, pipeline) {
      this.url = escapeURLPath(url2);
      this.accountName = getAccountNameFromUrl(url2);
      this.pipeline = pipeline;
      this.storageClientContext = new StorageContextClient(this.url, getCoreClientOptions(pipeline));
      this.isHttps = iEqual(getURLScheme(this.url) || "", "https");
      this.credential = getCredentialFromPipeline(pipeline);
      const storageClientContext = this.storageClientContext;
      storageClientContext.requestContentType = undefined;
    }
  }
  var tracingClient = coreTracing.createTracingClient({
    packageName: "@azure/storage-blob",
    packageVersion: SDK_VERSION,
    namespace: "Microsoft.Storage"
  });

  class BlobSASPermissions {
    constructor() {
      this.read = false;
      this.add = false;
      this.create = false;
      this.write = false;
      this.delete = false;
      this.deleteVersion = false;
      this.tag = false;
      this.move = false;
      this.execute = false;
      this.setImmutabilityPolicy = false;
      this.permanentDelete = false;
    }
    static parse(permissions) {
      const blobSASPermissions = new BlobSASPermissions;
      for (const char of permissions) {
        switch (char) {
          case "r":
            blobSASPermissions.read = true;
            break;
          case "a":
            blobSASPermissions.add = true;
            break;
          case "c":
            blobSASPermissions.create = true;
            break;
          case "w":
            blobSASPermissions.write = true;
            break;
          case "d":
            blobSASPermissions.delete = true;
            break;
          case "x":
            blobSASPermissions.deleteVersion = true;
            break;
          case "t":
            blobSASPermissions.tag = true;
            break;
          case "m":
            blobSASPermissions.move = true;
            break;
          case "e":
            blobSASPermissions.execute = true;
            break;
          case "i":
            blobSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            blobSASPermissions.permanentDelete = true;
            break;
          default:
            throw new RangeError(`Invalid permission: ${char}`);
        }
      }
      return blobSASPermissions;
    }
    static from(permissionLike) {
      const blobSASPermissions = new BlobSASPermissions;
      if (permissionLike.read) {
        blobSASPermissions.read = true;
      }
      if (permissionLike.add) {
        blobSASPermissions.add = true;
      }
      if (permissionLike.create) {
        blobSASPermissions.create = true;
      }
      if (permissionLike.write) {
        blobSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        blobSASPermissions.delete = true;
      }
      if (permissionLike.deleteVersion) {
        blobSASPermissions.deleteVersion = true;
      }
      if (permissionLike.tag) {
        blobSASPermissions.tag = true;
      }
      if (permissionLike.move) {
        blobSASPermissions.move = true;
      }
      if (permissionLike.execute) {
        blobSASPermissions.execute = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        blobSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        blobSASPermissions.permanentDelete = true;
      }
      return blobSASPermissions;
    }
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.move) {
        permissions.push("m");
      }
      if (this.execute) {
        permissions.push("e");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      return permissions.join("");
    }
  }

  class ContainerSASPermissions {
    constructor() {
      this.read = false;
      this.add = false;
      this.create = false;
      this.write = false;
      this.delete = false;
      this.deleteVersion = false;
      this.list = false;
      this.tag = false;
      this.move = false;
      this.execute = false;
      this.setImmutabilityPolicy = false;
      this.permanentDelete = false;
      this.filterByTags = false;
    }
    static parse(permissions) {
      const containerSASPermissions = new ContainerSASPermissions;
      for (const char of permissions) {
        switch (char) {
          case "r":
            containerSASPermissions.read = true;
            break;
          case "a":
            containerSASPermissions.add = true;
            break;
          case "c":
            containerSASPermissions.create = true;
            break;
          case "w":
            containerSASPermissions.write = true;
            break;
          case "d":
            containerSASPermissions.delete = true;
            break;
          case "l":
            containerSASPermissions.list = true;
            break;
          case "t":
            containerSASPermissions.tag = true;
            break;
          case "x":
            containerSASPermissions.deleteVersion = true;
            break;
          case "m":
            containerSASPermissions.move = true;
            break;
          case "e":
            containerSASPermissions.execute = true;
            break;
          case "i":
            containerSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            containerSASPermissions.permanentDelete = true;
            break;
          case "f":
            containerSASPermissions.filterByTags = true;
            break;
          default:
            throw new RangeError(`Invalid permission ${char}`);
        }
      }
      return containerSASPermissions;
    }
    static from(permissionLike) {
      const containerSASPermissions = new ContainerSASPermissions;
      if (permissionLike.read) {
        containerSASPermissions.read = true;
      }
      if (permissionLike.add) {
        containerSASPermissions.add = true;
      }
      if (permissionLike.create) {
        containerSASPermissions.create = true;
      }
      if (permissionLike.write) {
        containerSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        containerSASPermissions.delete = true;
      }
      if (permissionLike.list) {
        containerSASPermissions.list = true;
      }
      if (permissionLike.deleteVersion) {
        containerSASPermissions.deleteVersion = true;
      }
      if (permissionLike.tag) {
        containerSASPermissions.tag = true;
      }
      if (permissionLike.move) {
        containerSASPermissions.move = true;
      }
      if (permissionLike.execute) {
        containerSASPermissions.execute = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        containerSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        containerSASPermissions.permanentDelete = true;
      }
      if (permissionLike.filterByTags) {
        containerSASPermissions.filterByTags = true;
      }
      return containerSASPermissions;
    }
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.list) {
        permissions.push("l");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.move) {
        permissions.push("m");
      }
      if (this.execute) {
        permissions.push("e");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      if (this.filterByTags) {
        permissions.push("f");
      }
      return permissions.join("");
    }
  }

  class UserDelegationKeyCredential {
    constructor(accountName, userDelegationKey) {
      this.accountName = accountName;
      this.userDelegationKey = userDelegationKey;
      this.key = Buffer.from(userDelegationKey.value, "base64");
    }
    computeHMACSHA256(stringToSign) {
      return crypto.createHmac("sha256", this.key).update(stringToSign, "utf8").digest("base64");
    }
  }
  function ipRangeToString(ipRange) {
    return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
  }
  exports.SASProtocol = undefined;
  (function(SASProtocol) {
    SASProtocol["Https"] = "https";
    SASProtocol["HttpsAndHttp"] = "https,http";
  })(exports.SASProtocol || (exports.SASProtocol = {}));

  class SASQueryParameters {
    get ipRange() {
      if (this.ipRangeInner) {
        return {
          end: this.ipRangeInner.end,
          start: this.ipRangeInner.start
        };
      }
      return;
    }
    constructor(version2, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn2, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType2, userDelegationKey, preauthorizedAgentObjectId, correlationId, encryptionScope2) {
      this.version = version2;
      this.signature = signature;
      if (permissionsOrOptions !== undefined && typeof permissionsOrOptions !== "string") {
        this.permissions = permissionsOrOptions.permissions;
        this.services = permissionsOrOptions.services;
        this.resourceTypes = permissionsOrOptions.resourceTypes;
        this.protocol = permissionsOrOptions.protocol;
        this.startsOn = permissionsOrOptions.startsOn;
        this.expiresOn = permissionsOrOptions.expiresOn;
        this.ipRangeInner = permissionsOrOptions.ipRange;
        this.identifier = permissionsOrOptions.identifier;
        this.encryptionScope = permissionsOrOptions.encryptionScope;
        this.resource = permissionsOrOptions.resource;
        this.cacheControl = permissionsOrOptions.cacheControl;
        this.contentDisposition = permissionsOrOptions.contentDisposition;
        this.contentEncoding = permissionsOrOptions.contentEncoding;
        this.contentLanguage = permissionsOrOptions.contentLanguage;
        this.contentType = permissionsOrOptions.contentType;
        if (permissionsOrOptions.userDelegationKey) {
          this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId;
          this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId;
          this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn;
          this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn;
          this.signedService = permissionsOrOptions.userDelegationKey.signedService;
          this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion;
          this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId;
          this.correlationId = permissionsOrOptions.correlationId;
        }
      } else {
        this.services = services;
        this.resourceTypes = resourceTypes;
        this.expiresOn = expiresOn2;
        this.permissions = permissionsOrOptions;
        this.protocol = protocol;
        this.startsOn = startsOn;
        this.ipRangeInner = ipRange;
        this.encryptionScope = encryptionScope2;
        this.identifier = identifier;
        this.resource = resource;
        this.cacheControl = cacheControl;
        this.contentDisposition = contentDisposition;
        this.contentEncoding = contentEncoding;
        this.contentLanguage = contentLanguage;
        this.contentType = contentType2;
        if (userDelegationKey) {
          this.signedOid = userDelegationKey.signedObjectId;
          this.signedTenantId = userDelegationKey.signedTenantId;
          this.signedStartsOn = userDelegationKey.signedStartsOn;
          this.signedExpiresOn = userDelegationKey.signedExpiresOn;
          this.signedService = userDelegationKey.signedService;
          this.signedVersion = userDelegationKey.signedVersion;
          this.preauthorizedAgentObjectId = preauthorizedAgentObjectId;
          this.correlationId = correlationId;
        }
      }
    }
    toString() {
      const params = [
        "sv",
        "ss",
        "srt",
        "spr",
        "st",
        "se",
        "sip",
        "si",
        "ses",
        "skoid",
        "sktid",
        "skt",
        "ske",
        "sks",
        "skv",
        "sr",
        "sp",
        "sig",
        "rscc",
        "rscd",
        "rsce",
        "rscl",
        "rsct",
        "saoid",
        "scid"
      ];
      const queries = [];
      for (const param of params) {
        switch (param) {
          case "sv":
            this.tryAppendQueryParameter(queries, param, this.version);
            break;
          case "ss":
            this.tryAppendQueryParameter(queries, param, this.services);
            break;
          case "srt":
            this.tryAppendQueryParameter(queries, param, this.resourceTypes);
            break;
          case "spr":
            this.tryAppendQueryParameter(queries, param, this.protocol);
            break;
          case "st":
            this.tryAppendQueryParameter(queries, param, this.startsOn ? truncatedISO8061Date(this.startsOn, false) : undefined);
            break;
          case "se":
            this.tryAppendQueryParameter(queries, param, this.expiresOn ? truncatedISO8061Date(this.expiresOn, false) : undefined);
            break;
          case "sip":
            this.tryAppendQueryParameter(queries, param, this.ipRange ? ipRangeToString(this.ipRange) : undefined);
            break;
          case "si":
            this.tryAppendQueryParameter(queries, param, this.identifier);
            break;
          case "ses":
            this.tryAppendQueryParameter(queries, param, this.encryptionScope);
            break;
          case "skoid":
            this.tryAppendQueryParameter(queries, param, this.signedOid);
            break;
          case "sktid":
            this.tryAppendQueryParameter(queries, param, this.signedTenantId);
            break;
          case "skt":
            this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? truncatedISO8061Date(this.signedStartsOn, false) : undefined);
            break;
          case "ske":
            this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? truncatedISO8061Date(this.signedExpiresOn, false) : undefined);
            break;
          case "sks":
            this.tryAppendQueryParameter(queries, param, this.signedService);
            break;
          case "skv":
            this.tryAppendQueryParameter(queries, param, this.signedVersion);
            break;
          case "sr":
            this.tryAppendQueryParameter(queries, param, this.resource);
            break;
          case "sp":
            this.tryAppendQueryParameter(queries, param, this.permissions);
            break;
          case "sig":
            this.tryAppendQueryParameter(queries, param, this.signature);
            break;
          case "rscc":
            this.tryAppendQueryParameter(queries, param, this.cacheControl);
            break;
          case "rscd":
            this.tryAppendQueryParameter(queries, param, this.contentDisposition);
            break;
          case "rsce":
            this.tryAppendQueryParameter(queries, param, this.contentEncoding);
            break;
          case "rscl":
            this.tryAppendQueryParameter(queries, param, this.contentLanguage);
            break;
          case "rsct":
            this.tryAppendQueryParameter(queries, param, this.contentType);
            break;
          case "saoid":
            this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
            break;
          case "scid":
            this.tryAppendQueryParameter(queries, param, this.correlationId);
            break;
        }
      }
      return queries.join("&");
    }
    tryAppendQueryParameter(queries, key, value) {
      if (!value) {
        return;
      }
      key = encodeURIComponent(key);
      value = encodeURIComponent(value);
      if (key.length > 0 && value.length > 0) {
        queries.push(`${key}=${value}`);
      }
    }
  }
  function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    return generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName).sasQueryParameters;
  }
  function generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    const version2 = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;
    const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : undefined;
    let userDelegationKeyCredential;
    if (sharedKeyCredential === undefined && accountName !== undefined) {
      userDelegationKeyCredential = new UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
    }
    if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {
      throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
    }
    if (version2 >= "2020-12-06") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);
      } else {
        return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);
      }
    }
    if (version2 >= "2018-11-09") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);
      } else {
        if (version2 >= "2020-02-10") {
          return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);
        } else {
          return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
        }
      }
    }
    if (version2 >= "2015-04-05") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
      } else {
        throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
      }
    }
    throw new RangeError("'version' must be >= '2015-04-05'.");
  }
  function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    if (blobSASSignatureValues.blobName) {
      resource = "b";
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`);
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
      stringToSign
    };
  }
  function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`);
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
      stringToSign
    };
  }
  function generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`);
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, undefined, undefined, undefined, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`);
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      undefined,
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`);
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      undefined,
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`);
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function getCanonicalName(accountName, containerName, blobName) {
    const elements = [`/blob/${accountName}/${containerName}`];
    if (blobName) {
      elements.push(`/${blobName}`);
    }
    return elements.join("");
  }
  function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
    const version2 = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;
    if (blobSASSignatureValues.snapshotTime && version2 < "2018-11-09") {
      throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.snapshotTime) {
      throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.versionId && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.versionId) {
      throw RangeError("Must provide 'blobName' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version2 < "2020-08-04") {
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
    }
    if (version2 < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) {
      throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
    }
    if (version2 < "2021-04-10" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) {
      throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
    }
    if (version2 < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) {
      throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
    }
    if (blobSASSignatureValues.encryptionScope && version2 < "2020-12-06") {
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    blobSASSignatureValues.version = version2;
    return blobSASSignatureValues;
  }

  class BlobLeaseClient {
    get leaseId() {
      return this._leaseId;
    }
    get url() {
      return this._url;
    }
    constructor(client, leaseId2) {
      const clientContext = client.storageClientContext;
      this._url = client.url;
      if (client.name === undefined) {
        this._isContainer = true;
        this._containerOrBlobOperation = clientContext.container;
      } else {
        this._isContainer = false;
        this._containerOrBlobOperation = clientContext.blob;
      }
      if (!leaseId2) {
        leaseId2 = coreUtil.randomUUID();
      }
      this._leaseId = leaseId2;
    }
    async acquireLease(duration2, options = {}) {
      var _a, _b, _c, _d, _e;
      if (this._isContainer && (((_a = options.conditions) === null || _a === undefined ? undefined : _a.ifMatch) && ((_b = options.conditions) === null || _b === undefined ? undefined : _b.ifMatch) !== ETagNone || ((_c = options.conditions) === null || _c === undefined ? undefined : _c.ifNoneMatch) && ((_d = options.conditions) === null || _d === undefined ? undefined : _d.ifNoneMatch) !== ETagNone || ((_e = options.conditions) === null || _e === undefined ? undefined : _e.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-acquireLease", options, async (updatedOptions) => {
        var _a2;
        return assertResponse(await this._containerOrBlobOperation.acquireLease({
          abortSignal: options.abortSignal,
          duration: duration2,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a2 = options.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions }),
          proposedLeaseId: this._leaseId,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async changeLease(proposedLeaseId2, options = {}) {
      var _a, _b, _c, _d, _e;
      if (this._isContainer && (((_a = options.conditions) === null || _a === undefined ? undefined : _a.ifMatch) && ((_b = options.conditions) === null || _b === undefined ? undefined : _b.ifMatch) !== ETagNone || ((_c = options.conditions) === null || _c === undefined ? undefined : _c.ifNoneMatch) && ((_d = options.conditions) === null || _d === undefined ? undefined : _d.ifNoneMatch) !== ETagNone || ((_e = options.conditions) === null || _e === undefined ? undefined : _e.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-changeLease", options, async (updatedOptions) => {
        var _a2;
        const response = assertResponse(await this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId2, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a2 = options.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        this._leaseId = proposedLeaseId2;
        return response;
      });
    }
    async releaseLease(options = {}) {
      var _a, _b, _c, _d, _e;
      if (this._isContainer && (((_a = options.conditions) === null || _a === undefined ? undefined : _a.ifMatch) && ((_b = options.conditions) === null || _b === undefined ? undefined : _b.ifMatch) !== ETagNone || ((_c = options.conditions) === null || _c === undefined ? undefined : _c.ifNoneMatch) && ((_d = options.conditions) === null || _d === undefined ? undefined : _d.ifNoneMatch) !== ETagNone || ((_e = options.conditions) === null || _e === undefined ? undefined : _e.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-releaseLease", options, async (updatedOptions) => {
        var _a2;
        return assertResponse(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a2 = options.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async renewLease(options = {}) {
      var _a, _b, _c, _d, _e;
      if (this._isContainer && (((_a = options.conditions) === null || _a === undefined ? undefined : _a.ifMatch) && ((_b = options.conditions) === null || _b === undefined ? undefined : _b.ifMatch) !== ETagNone || ((_c = options.conditions) === null || _c === undefined ? undefined : _c.ifNoneMatch) && ((_d = options.conditions) === null || _d === undefined ? undefined : _d.ifNoneMatch) !== ETagNone || ((_e = options.conditions) === null || _e === undefined ? undefined : _e.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-renewLease", options, async (updatedOptions) => {
        var _a2;
        return this._containerOrBlobOperation.renewLease(this._leaseId, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a2 = options.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        });
      });
    }
    async breakLease(breakPeriod2, options = {}) {
      var _a, _b, _c, _d, _e;
      if (this._isContainer && (((_a = options.conditions) === null || _a === undefined ? undefined : _a.ifMatch) && ((_b = options.conditions) === null || _b === undefined ? undefined : _b.ifMatch) !== ETagNone || ((_c = options.conditions) === null || _c === undefined ? undefined : _c.ifNoneMatch) && ((_d = options.conditions) === null || _d === undefined ? undefined : _d.ifNoneMatch) !== ETagNone || ((_e = options.conditions) === null || _e === undefined ? undefined : _e.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-breakLease", options, async (updatedOptions) => {
        var _a2;
        const operationOptions = {
          abortSignal: options.abortSignal,
          breakPeriod: breakPeriod2,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a2 = options.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        };
        return assertResponse(await this._containerOrBlobOperation.breakLease(operationOptions));
      });
    }
  }

  class RetriableReadableStream extends stream.Readable {
    constructor(source, getter, offset, count, options = {}) {
      super({ highWaterMark: options.highWaterMark });
      this.retries = 0;
      this.sourceDataHandler = (data) => {
        if (this.options.doInjectErrorOnce) {
          this.options.doInjectErrorOnce = undefined;
          this.source.pause();
          this.sourceErrorOrEndHandler();
          this.source.destroy();
          return;
        }
        this.offset += data.length;
        if (this.onProgress) {
          this.onProgress({ loadedBytes: this.offset - this.start });
        }
        if (!this.push(data)) {
          this.source.pause();
        }
      };
      this.sourceAbortedHandler = () => {
        const abortError = new abortController.AbortError("The operation was aborted.");
        this.destroy(abortError);
      };
      this.sourceErrorOrEndHandler = (err) => {
        if (err && err.name === "AbortError") {
          this.destroy(err);
          return;
        }
        this.removeSourceEventHandlers();
        if (this.offset - 1 === this.end) {
          this.push(null);
        } else if (this.offset <= this.end) {
          if (this.retries < this.maxRetryRequests) {
            this.retries += 1;
            this.getter(this.offset).then((newSource) => {
              this.source = newSource;
              this.setSourceEventHandlers();
              return;
            }).catch((error) => {
              this.destroy(error);
            });
          } else {
            this.destroy(new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
          }
        } else {
          this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
        }
      };
      this.getter = getter;
      this.source = source;
      this.start = offset;
      this.offset = offset;
      this.end = offset + count - 1;
      this.maxRetryRequests = options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
      this.onProgress = options.onProgress;
      this.options = options;
      this.setSourceEventHandlers();
    }
    _read() {
      this.source.resume();
    }
    setSourceEventHandlers() {
      this.source.on("data", this.sourceDataHandler);
      this.source.on("end", this.sourceErrorOrEndHandler);
      this.source.on("error", this.sourceErrorOrEndHandler);
      this.source.on("aborted", this.sourceAbortedHandler);
    }
    removeSourceEventHandlers() {
      this.source.removeListener("data", this.sourceDataHandler);
      this.source.removeListener("end", this.sourceErrorOrEndHandler);
      this.source.removeListener("error", this.sourceErrorOrEndHandler);
      this.source.removeListener("aborted", this.sourceAbortedHandler);
    }
    _destroy(error, callback) {
      this.removeSourceEventHandlers();
      this.source.destroy();
      callback(error === null ? undefined : error);
    }
  }

  class BlobDownloadResponse {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return this.originalResponse.copyCompletedOn;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get tagCount() {
      return this.originalResponse.tagCount;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get lastAccessed() {
      return this.originalResponse.lastAccessed;
    }
    get createdOn() {
      return this.originalResponse.createdOn;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get versionId() {
      return this.originalResponse.versionId;
    }
    get isCurrentVersion() {
      return this.originalResponse.isCurrentVersion;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get objectReplicationDestinationPolicyId() {
      return this.originalResponse.objectReplicationDestinationPolicyId;
    }
    get objectReplicationSourceProperties() {
      return this.originalResponse.objectReplicationSourceProperties;
    }
    get isSealed() {
      return this.originalResponse.isSealed;
    }
    get immutabilityPolicyExpiresOn() {
      return this.originalResponse.immutabilityPolicyExpiresOn;
    }
    get immutabilityPolicyMode() {
      return this.originalResponse.immutabilityPolicyMode;
    }
    get legalHold() {
      return this.originalResponse.legalHold;
    }
    get contentAsBlob() {
      return this.originalResponse.blobBody;
    }
    get readableStreamBody() {
      return coreUtil.isNode ? this.blobDownloadStream : undefined;
    }
    get _response() {
      return this.originalResponse._response;
    }
    constructor(originalResponse, getter, offset, count, options = {}) {
      this.originalResponse = originalResponse;
      this.blobDownloadStream = new RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
    }
  }
  var AVRO_SYNC_MARKER_SIZE = 16;
  var AVRO_INIT_BYTES = new Uint8Array([79, 98, 106, 1]);
  var AVRO_CODEC_KEY = "avro.codec";
  var AVRO_SCHEMA_KEY = "avro.schema";

  class AvroParser {
    static async readFixedBytes(stream2, length, options = {}) {
      const bytes = await stream2.read(length, { abortSignal: options.abortSignal });
      if (bytes.length !== length) {
        throw new Error("Hit stream end.");
      }
      return bytes;
    }
    static async readByte(stream2, options = {}) {
      const buf = await AvroParser.readFixedBytes(stream2, 1, options);
      return buf[0];
    }
    static async readZigZagLong(stream2, options = {}) {
      let zigZagEncoded = 0;
      let significanceInBit = 0;
      let byte, haveMoreByte, significanceInFloat;
      do {
        byte = await AvroParser.readByte(stream2, options);
        haveMoreByte = byte & 128;
        zigZagEncoded |= (byte & 127) << significanceInBit;
        significanceInBit += 7;
      } while (haveMoreByte && significanceInBit < 28);
      if (haveMoreByte) {
        zigZagEncoded = zigZagEncoded;
        significanceInFloat = 268435456;
        do {
          byte = await AvroParser.readByte(stream2, options);
          zigZagEncoded += (byte & 127) * significanceInFloat;
          significanceInFloat *= 128;
        } while (byte & 128);
        const res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;
        if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER) {
          throw new Error("Integer overflow.");
        }
        return res;
      }
      return zigZagEncoded >> 1 ^ -(zigZagEncoded & 1);
    }
    static async readLong(stream2, options = {}) {
      return AvroParser.readZigZagLong(stream2, options);
    }
    static async readInt(stream2, options = {}) {
      return AvroParser.readZigZagLong(stream2, options);
    }
    static async readNull() {
      return null;
    }
    static async readBoolean(stream2, options = {}) {
      const b = await AvroParser.readByte(stream2, options);
      if (b === 1) {
        return true;
      } else if (b === 0) {
        return false;
      } else {
        throw new Error("Byte was not a boolean.");
      }
    }
    static async readFloat(stream2, options = {}) {
      const u8arr = await AvroParser.readFixedBytes(stream2, 4, options);
      const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
      return view.getFloat32(0, true);
    }
    static async readDouble(stream2, options = {}) {
      const u8arr = await AvroParser.readFixedBytes(stream2, 8, options);
      const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
      return view.getFloat64(0, true);
    }
    static async readBytes(stream2, options = {}) {
      const size = await AvroParser.readLong(stream2, options);
      if (size < 0) {
        throw new Error("Bytes size was negative.");
      }
      return stream2.read(size, { abortSignal: options.abortSignal });
    }
    static async readString(stream2, options = {}) {
      const u8arr = await AvroParser.readBytes(stream2, options);
      const utf8decoder = new TextDecoder;
      return utf8decoder.decode(u8arr);
    }
    static async readMapPair(stream2, readItemMethod, options = {}) {
      const key = await AvroParser.readString(stream2, options);
      const value = await readItemMethod(stream2, options);
      return { key, value };
    }
    static async readMap(stream2, readItemMethod, options = {}) {
      const readPairMethod = (s, opts = {}) => {
        return AvroParser.readMapPair(s, readItemMethod, opts);
      };
      const pairs = await AvroParser.readArray(stream2, readPairMethod, options);
      const dict = {};
      for (const pair of pairs) {
        dict[pair.key] = pair.value;
      }
      return dict;
    }
    static async readArray(stream2, readItemMethod, options = {}) {
      const items = [];
      for (let count = await AvroParser.readLong(stream2, options);count !== 0; count = await AvroParser.readLong(stream2, options)) {
        if (count < 0) {
          await AvroParser.readLong(stream2, options);
          count = -count;
        }
        while (count--) {
          const item = await readItemMethod(stream2, options);
          items.push(item);
        }
      }
      return items;
    }
  }
  var AvroComplex;
  (function(AvroComplex2) {
    AvroComplex2["RECORD"] = "record";
    AvroComplex2["ENUM"] = "enum";
    AvroComplex2["ARRAY"] = "array";
    AvroComplex2["MAP"] = "map";
    AvroComplex2["UNION"] = "union";
    AvroComplex2["FIXED"] = "fixed";
  })(AvroComplex || (AvroComplex = {}));
  var AvroPrimitive;
  (function(AvroPrimitive2) {
    AvroPrimitive2["NULL"] = "null";
    AvroPrimitive2["BOOLEAN"] = "boolean";
    AvroPrimitive2["INT"] = "int";
    AvroPrimitive2["LONG"] = "long";
    AvroPrimitive2["FLOAT"] = "float";
    AvroPrimitive2["DOUBLE"] = "double";
    AvroPrimitive2["BYTES"] = "bytes";
    AvroPrimitive2["STRING"] = "string";
  })(AvroPrimitive || (AvroPrimitive = {}));

  class AvroType {
    static fromSchema(schema) {
      if (typeof schema === "string") {
        return AvroType.fromStringSchema(schema);
      } else if (Array.isArray(schema)) {
        return AvroType.fromArraySchema(schema);
      } else {
        return AvroType.fromObjectSchema(schema);
      }
    }
    static fromStringSchema(schema) {
      switch (schema) {
        case AvroPrimitive.NULL:
        case AvroPrimitive.BOOLEAN:
        case AvroPrimitive.INT:
        case AvroPrimitive.LONG:
        case AvroPrimitive.FLOAT:
        case AvroPrimitive.DOUBLE:
        case AvroPrimitive.BYTES:
        case AvroPrimitive.STRING:
          return new AvroPrimitiveType(schema);
        default:
          throw new Error(`Unexpected Avro type ${schema}`);
      }
    }
    static fromArraySchema(schema) {
      return new AvroUnionType(schema.map(AvroType.fromSchema));
    }
    static fromObjectSchema(schema) {
      const type = schema.type;
      try {
        return AvroType.fromStringSchema(type);
      } catch (_a) {
      }
      switch (type) {
        case AvroComplex.RECORD:
          if (schema.aliases) {
            throw new Error(`aliases currently is not supported, schema: ${schema}`);
          }
          if (!schema.name) {
            throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);
          }
          const fields = {};
          if (!schema.fields) {
            throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);
          }
          for (const field of schema.fields) {
            fields[field.name] = AvroType.fromSchema(field.type);
          }
          return new AvroRecordType(fields, schema.name);
        case AvroComplex.ENUM:
          if (schema.aliases) {
            throw new Error(`aliases currently is not supported, schema: ${schema}`);
          }
          if (!schema.symbols) {
            throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);
          }
          return new AvroEnumType(schema.symbols);
        case AvroComplex.MAP:
          if (!schema.values) {
            throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);
          }
          return new AvroMapType(AvroType.fromSchema(schema.values));
        case AvroComplex.ARRAY:
        case AvroComplex.FIXED:
        default:
          throw new Error(`Unexpected Avro type ${type} in ${schema}`);
      }
    }
  }

  class AvroPrimitiveType extends AvroType {
    constructor(primitive) {
      super();
      this._primitive = primitive;
    }
    read(stream2, options = {}) {
      switch (this._primitive) {
        case AvroPrimitive.NULL:
          return AvroParser.readNull();
        case AvroPrimitive.BOOLEAN:
          return AvroParser.readBoolean(stream2, options);
        case AvroPrimitive.INT:
          return AvroParser.readInt(stream2, options);
        case AvroPrimitive.LONG:
          return AvroParser.readLong(stream2, options);
        case AvroPrimitive.FLOAT:
          return AvroParser.readFloat(stream2, options);
        case AvroPrimitive.DOUBLE:
          return AvroParser.readDouble(stream2, options);
        case AvroPrimitive.BYTES:
          return AvroParser.readBytes(stream2, options);
        case AvroPrimitive.STRING:
          return AvroParser.readString(stream2, options);
        default:
          throw new Error("Unknown Avro Primitive");
      }
    }
  }

  class AvroEnumType extends AvroType {
    constructor(symbols) {
      super();
      this._symbols = symbols;
    }
    async read(stream2, options = {}) {
      const value = await AvroParser.readInt(stream2, options);
      return this._symbols[value];
    }
  }

  class AvroUnionType extends AvroType {
    constructor(types) {
      super();
      this._types = types;
    }
    async read(stream2, options = {}) {
      const typeIndex = await AvroParser.readInt(stream2, options);
      return this._types[typeIndex].read(stream2, options);
    }
  }

  class AvroMapType extends AvroType {
    constructor(itemType) {
      super();
      this._itemType = itemType;
    }
    read(stream2, options = {}) {
      const readItemMethod = (s, opts) => {
        return this._itemType.read(s, opts);
      };
      return AvroParser.readMap(stream2, readItemMethod, options);
    }
  }

  class AvroRecordType extends AvroType {
    constructor(fields, name) {
      super();
      this._fields = fields;
      this._name = name;
    }
    async read(stream2, options = {}) {
      const record = {};
      record["$schema"] = this._name;
      for (const key in this._fields) {
        if (Object.prototype.hasOwnProperty.call(this._fields, key)) {
          record[key] = await this._fields[key].read(stream2, options);
        }
      }
      return record;
    }
  }
  function arraysEqual(a, b) {
    if (a === b)
      return true;
    if (a == null || b == null)
      return false;
    if (a.length !== b.length)
      return false;
    for (let i = 0;i < a.length; ++i) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }

  class AvroReader {
    get blockOffset() {
      return this._blockOffset;
    }
    get objectIndex() {
      return this._objectIndex;
    }
    constructor(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock) {
      this._dataStream = dataStream;
      this._headerStream = headerStream || dataStream;
      this._initialized = false;
      this._blockOffset = currentBlockOffset || 0;
      this._objectIndex = indexWithinCurrentBlock || 0;
      this._initialBlockOffset = currentBlockOffset || 0;
    }
    async initialize(options = {}) {
      const header = await AvroParser.readFixedBytes(this._headerStream, AVRO_INIT_BYTES.length, {
        abortSignal: options.abortSignal
      });
      if (!arraysEqual(header, AVRO_INIT_BYTES)) {
        throw new Error("Stream is not an Avro file.");
      }
      this._metadata = await AvroParser.readMap(this._headerStream, AvroParser.readString, {
        abortSignal: options.abortSignal
      });
      const codec = this._metadata[AVRO_CODEC_KEY];
      if (!(codec === undefined || codec === null || codec === "null")) {
        throw new Error("Codecs are not supported");
      }
      this._syncMarker = await AvroParser.readFixedBytes(this._headerStream, AVRO_SYNC_MARKER_SIZE, {
        abortSignal: options.abortSignal
      });
      const schema = JSON.parse(this._metadata[AVRO_SCHEMA_KEY]);
      this._itemType = AvroType.fromSchema(schema);
      if (this._blockOffset === 0) {
        this._blockOffset = this._initialBlockOffset + this._dataStream.position;
      }
      this._itemsRemainingInBlock = await AvroParser.readLong(this._dataStream, {
        abortSignal: options.abortSignal
      });
      await AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
      this._initialized = true;
      if (this._objectIndex && this._objectIndex > 0) {
        for (let i = 0;i < this._objectIndex; i++) {
          await this._itemType.read(this._dataStream, { abortSignal: options.abortSignal });
          this._itemsRemainingInBlock--;
        }
      }
    }
    hasNext() {
      return !this._initialized || this._itemsRemainingInBlock > 0;
    }
    parseObjects() {
      return tslib.__asyncGenerator(this, arguments, function* parseObjects_1(options = {}) {
        if (!this._initialized) {
          yield tslib.__await(this.initialize(options));
        }
        while (this.hasNext()) {
          const result = yield tslib.__await(this._itemType.read(this._dataStream, {
            abortSignal: options.abortSignal
          }));
          this._itemsRemainingInBlock--;
          this._objectIndex++;
          if (this._itemsRemainingInBlock === 0) {
            const marker2 = yield tslib.__await(AvroParser.readFixedBytes(this._dataStream, AVRO_SYNC_MARKER_SIZE, {
              abortSignal: options.abortSignal
            }));
            this._blockOffset = this._initialBlockOffset + this._dataStream.position;
            this._objectIndex = 0;
            if (!arraysEqual(this._syncMarker, marker2)) {
              throw new Error("Stream is not a valid Avro file.");
            }
            try {
              this._itemsRemainingInBlock = yield tslib.__await(AvroParser.readLong(this._dataStream, {
                abortSignal: options.abortSignal
              }));
            } catch (_a) {
              this._itemsRemainingInBlock = 0;
            }
            if (this._itemsRemainingInBlock > 0) {
              yield tslib.__await(AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal }));
            }
          }
          yield yield tslib.__await(result);
        }
      });
    }
  }

  class AvroReadable {
  }
  var ABORT_ERROR = new abortController.AbortError("Reading from the avro stream was aborted.");

  class AvroReadableFromStream extends AvroReadable {
    toUint8Array(data) {
      if (typeof data === "string") {
        return Buffer.from(data);
      }
      return data;
    }
    constructor(readable) {
      super();
      this._readable = readable;
      this._position = 0;
    }
    get position() {
      return this._position;
    }
    async read(size, options = {}) {
      var _a;
      if ((_a = options.abortSignal) === null || _a === undefined ? undefined : _a.aborted) {
        throw ABORT_ERROR;
      }
      if (size < 0) {
        throw new Error(`size parameter should be positive: ${size}`);
      }
      if (size === 0) {
        return new Uint8Array;
      }
      if (!this._readable.readable) {
        throw new Error("Stream no longer readable.");
      }
      const chunk = this._readable.read(size);
      if (chunk) {
        this._position += chunk.length;
        return this.toUint8Array(chunk);
      } else {
        return new Promise((resolve, reject) => {
          const cleanUp = () => {
            this._readable.removeListener("readable", readableCallback);
            this._readable.removeListener("error", rejectCallback);
            this._readable.removeListener("end", rejectCallback);
            this._readable.removeListener("close", rejectCallback);
            if (options.abortSignal) {
              options.abortSignal.removeEventListener("abort", abortHandler);
            }
          };
          const readableCallback = () => {
            const callbackChunk = this._readable.read(size);
            if (callbackChunk) {
              this._position += callbackChunk.length;
              cleanUp();
              resolve(this.toUint8Array(callbackChunk));
            }
          };
          const rejectCallback = () => {
            cleanUp();
            reject();
          };
          const abortHandler = () => {
            cleanUp();
            reject(ABORT_ERROR);
          };
          this._readable.on("readable", readableCallback);
          this._readable.once("error", rejectCallback);
          this._readable.once("end", rejectCallback);
          this._readable.once("close", rejectCallback);
          if (options.abortSignal) {
            options.abortSignal.addEventListener("abort", abortHandler);
          }
        });
      }
    }
  }

  class BlobQuickQueryStream extends stream.Readable {
    constructor(source, options = {}) {
      super();
      this.avroPaused = true;
      this.source = source;
      this.onProgress = options.onProgress;
      this.onError = options.onError;
      this.avroReader = new AvroReader(new AvroReadableFromStream(this.source));
      this.avroIter = this.avroReader.parseObjects({ abortSignal: options.abortSignal });
    }
    _read() {
      if (this.avroPaused) {
        this.readInternal().catch((err) => {
          this.emit("error", err);
        });
      }
    }
    async readInternal() {
      this.avroPaused = false;
      let avroNext;
      do {
        avroNext = await this.avroIter.next();
        if (avroNext.done) {
          break;
        }
        const obj = avroNext.value;
        const schema = obj.$schema;
        if (typeof schema !== "string") {
          throw Error("Missing schema in avro record.");
        }
        switch (schema) {
          case "com.microsoft.azure.storage.queryBlobContents.resultData":
            {
              const data = obj.data;
              if (data instanceof Uint8Array === false) {
                throw Error("Invalid data in avro result record.");
              }
              if (!this.push(Buffer.from(data))) {
                this.avroPaused = true;
              }
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.progress":
            {
              const bytesScanned = obj.bytesScanned;
              if (typeof bytesScanned !== "number") {
                throw Error("Invalid bytesScanned in avro progress record.");
              }
              if (this.onProgress) {
                this.onProgress({ loadedBytes: bytesScanned });
              }
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.end":
            if (this.onProgress) {
              const totalBytes = obj.totalBytes;
              if (typeof totalBytes !== "number") {
                throw Error("Invalid totalBytes in avro end record.");
              }
              this.onProgress({ loadedBytes: totalBytes });
            }
            this.push(null);
            break;
          case "com.microsoft.azure.storage.queryBlobContents.error":
            if (this.onError) {
              const fatal = obj.fatal;
              if (typeof fatal !== "boolean") {
                throw Error("Invalid fatal in avro error record.");
              }
              const name = obj.name;
              if (typeof name !== "string") {
                throw Error("Invalid name in avro error record.");
              }
              const description = obj.description;
              if (typeof description !== "string") {
                throw Error("Invalid description in avro error record.");
              }
              const position = obj.position;
              if (typeof position !== "number") {
                throw Error("Invalid position in avro error record.");
              }
              this.onError({
                position,
                name,
                isFatal: fatal,
                description
              });
            }
            break;
          default:
            throw Error(`Unknown schema ${schema} in avro progress record.`);
        }
      } while (!avroNext.done && !this.avroPaused);
    }
  }

  class BlobQueryResponse {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get blobBody() {
      return;
    }
    get readableStreamBody() {
      return coreUtil.isNode ? this.blobDownloadStream : undefined;
    }
    get _response() {
      return this.originalResponse._response;
    }
    constructor(originalResponse, options = {}) {
      this.originalResponse = originalResponse;
      this.blobDownloadStream = new BlobQuickQueryStream(this.originalResponse.readableStreamBody, options);
    }
  }
  exports.BlockBlobTier = undefined;
  (function(BlockBlobTier) {
    BlockBlobTier["Hot"] = "Hot";
    BlockBlobTier["Cool"] = "Cool";
    BlockBlobTier["Cold"] = "Cold";
    BlockBlobTier["Archive"] = "Archive";
  })(exports.BlockBlobTier || (exports.BlockBlobTier = {}));
  exports.PremiumPageBlobTier = undefined;
  (function(PremiumPageBlobTier) {
    PremiumPageBlobTier["P4"] = "P4";
    PremiumPageBlobTier["P6"] = "P6";
    PremiumPageBlobTier["P10"] = "P10";
    PremiumPageBlobTier["P15"] = "P15";
    PremiumPageBlobTier["P20"] = "P20";
    PremiumPageBlobTier["P30"] = "P30";
    PremiumPageBlobTier["P40"] = "P40";
    PremiumPageBlobTier["P50"] = "P50";
    PremiumPageBlobTier["P60"] = "P60";
    PremiumPageBlobTier["P70"] = "P70";
    PremiumPageBlobTier["P80"] = "P80";
  })(exports.PremiumPageBlobTier || (exports.PremiumPageBlobTier = {}));
  function toAccessTier(tier2) {
    if (tier2 === undefined) {
      return;
    }
    return tier2;
  }
  function ensureCpkIfSpecified(cpk, isHttps) {
    if (cpk && !isHttps) {
      throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
    }
    if (cpk && !cpk.encryptionAlgorithm) {
      cpk.encryptionAlgorithm = EncryptionAlgorithmAES25;
    }
  }
  exports.StorageBlobAudience = undefined;
  (function(StorageBlobAudience) {
    StorageBlobAudience["StorageOAuthScopes"] = "https://storage.azure.com/.default";
    StorageBlobAudience["DiskComputeOAuthScopes"] = "https://disk.compute.azure.com/.default";
  })(exports.StorageBlobAudience || (exports.StorageBlobAudience = {}));
  function getBlobServiceAccountAudience(storageAccountName) {
    return `https://${storageAccountName}.blob.core.windows.net/.default`;
  }
  function rangeResponseFromModel(response) {
    const pageRange = (response._response.parsedBody.pageRange || []).map((x) => ({
      offset: x.start,
      count: x.end - x.start
    }));
    const clearRange = (response._response.parsedBody.clearRange || []).map((x) => ({
      offset: x.start,
      count: x.end - x.start
    }));
    return Object.assign(Object.assign({}, response), {
      pageRange,
      clearRange,
      _response: Object.assign(Object.assign({}, response._response), { parsedBody: {
        pageRange,
        clearRange
      } })
    });
  }

  class BlobBeginCopyFromUrlPoller extends coreLro.Poller {
    constructor(options) {
      const { blobClient, copySource: copySource2, intervalInMs = 15000, onProgress, resumeFrom, startCopyFromURLOptions } = options;
      let state;
      if (resumeFrom) {
        state = JSON.parse(resumeFrom).state;
      }
      const operation = makeBlobBeginCopyFromURLPollOperation(Object.assign(Object.assign({}, state), {
        blobClient,
        copySource: copySource2,
        startCopyFromURLOptions
      }));
      super(operation);
      if (typeof onProgress === "function") {
        this.onProgress(onProgress);
      }
      this.intervalInMs = intervalInMs;
    }
    delay() {
      return coreUtil.delay(this.intervalInMs);
    }
  }
  var cancel = async function cancel(options = {}) {
    const state = this.state;
    const { copyId: copyId2 } = state;
    if (state.isCompleted) {
      return makeBlobBeginCopyFromURLPollOperation(state);
    }
    if (!copyId2) {
      state.isCancelled = true;
      return makeBlobBeginCopyFromURLPollOperation(state);
    }
    await state.blobClient.abortCopyFromURL(copyId2, {
      abortSignal: options.abortSignal
    });
    state.isCancelled = true;
    return makeBlobBeginCopyFromURLPollOperation(state);
  };
  var update = async function update(options = {}) {
    const state = this.state;
    const { blobClient, copySource: copySource2, startCopyFromURLOptions } = state;
    if (!state.isStarted) {
      state.isStarted = true;
      const result = await blobClient.startCopyFromURL(copySource2, startCopyFromURLOptions);
      state.copyId = result.copyId;
      if (result.copyStatus === "success") {
        state.result = result;
        state.isCompleted = true;
      }
    } else if (!state.isCompleted) {
      try {
        const result = await state.blobClient.getProperties({ abortSignal: options.abortSignal });
        const { copyStatus, copyProgress } = result;
        const prevCopyProgress = state.copyProgress;
        if (copyProgress) {
          state.copyProgress = copyProgress;
        }
        if (copyStatus === "pending" && copyProgress !== prevCopyProgress && typeof options.fireProgress === "function") {
          options.fireProgress(state);
        } else if (copyStatus === "success") {
          state.result = result;
          state.isCompleted = true;
        } else if (copyStatus === "failed") {
          state.error = new Error(`Blob copy failed with reason: "${result.copyStatusDescription || "unknown"}"`);
          state.isCompleted = true;
        }
      } catch (err) {
        state.error = err;
        state.isCompleted = true;
      }
    }
    return makeBlobBeginCopyFromURLPollOperation(state);
  };
  var toString = function toString() {
    return JSON.stringify({ state: this.state }, (key, value) => {
      if (key === "blobClient") {
        return;
      }
      return value;
    });
  };
  function makeBlobBeginCopyFromURLPollOperation(state) {
    return {
      state: Object.assign({}, state),
      cancel,
      toString,
      update
    };
  }
  function rangeToString(iRange) {
    if (iRange.offset < 0) {
      throw new RangeError(`Range.offset cannot be smaller than 0.`);
    }
    if (iRange.count && iRange.count <= 0) {
      throw new RangeError(`Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.`);
    }
    return iRange.count ? `bytes=${iRange.offset}-${iRange.offset + iRange.count - 1}` : `bytes=${iRange.offset}-`;
  }
  var BatchStates;
  (function(BatchStates2) {
    BatchStates2[BatchStates2["Good"] = 0] = "Good";
    BatchStates2[BatchStates2["Error"] = 1] = "Error";
  })(BatchStates || (BatchStates = {}));

  class Batch {
    constructor(concurrency = 5) {
      this.actives = 0;
      this.completed = 0;
      this.offset = 0;
      this.operations = [];
      this.state = BatchStates.Good;
      if (concurrency < 1) {
        throw new RangeError("concurrency must be larger than 0");
      }
      this.concurrency = concurrency;
      this.emitter = new events.EventEmitter;
    }
    addOperation(operation) {
      this.operations.push(async () => {
        try {
          this.actives++;
          await operation();
          this.actives--;
          this.completed++;
          this.parallelExecute();
        } catch (error) {
          this.emitter.emit("error", error);
        }
      });
    }
    async do() {
      if (this.operations.length === 0) {
        return Promise.resolve();
      }
      this.parallelExecute();
      return new Promise((resolve, reject) => {
        this.emitter.on("finish", resolve);
        this.emitter.on("error", (error) => {
          this.state = BatchStates.Error;
          reject(error);
        });
      });
    }
    nextOperation() {
      if (this.offset < this.operations.length) {
        return this.operations[this.offset++];
      }
      return null;
    }
    parallelExecute() {
      if (this.state === BatchStates.Error) {
        return;
      }
      if (this.completed >= this.operations.length) {
        this.emitter.emit("finish");
        return;
      }
      while (this.actives < this.concurrency) {
        const operation = this.nextOperation();
        if (operation) {
          operation();
        } else {
          return;
        }
      }
    }
  }

  class BuffersStream extends stream.Readable {
    constructor(buffers, byteLength, options) {
      super(options);
      this.buffers = buffers;
      this.byteLength = byteLength;
      this.byteOffsetInCurrentBuffer = 0;
      this.bufferIndex = 0;
      this.pushedBytesLength = 0;
      let buffersLength = 0;
      for (const buf of this.buffers) {
        buffersLength += buf.byteLength;
      }
      if (buffersLength < this.byteLength) {
        throw new Error("Data size shouldn't be larger than the total length of buffers.");
      }
    }
    _read(size) {
      if (this.pushedBytesLength >= this.byteLength) {
        this.push(null);
      }
      if (!size) {
        size = this.readableHighWaterMark;
      }
      const outBuffers = [];
      let i = 0;
      while (i < size && this.pushedBytesLength < this.byteLength) {
        const remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength;
        const remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer;
        const remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
        if (remaining > size - i) {
          const end = this.byteOffsetInCurrentBuffer + size - i;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
          this.pushedBytesLength += size - i;
          this.byteOffsetInCurrentBuffer = end;
          i = size;
          break;
        } else {
          const end = this.byteOffsetInCurrentBuffer + remaining;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
          if (remaining === remainingCapacityInThisBuffer) {
            this.byteOffsetInCurrentBuffer = 0;
            this.bufferIndex++;
          } else {
            this.byteOffsetInCurrentBuffer = end;
          }
          this.pushedBytesLength += remaining;
          i += remaining;
        }
      }
      if (outBuffers.length > 1) {
        this.push(Buffer.concat(outBuffers));
      } else if (outBuffers.length === 1) {
        this.push(outBuffers[0]);
      }
    }
  }
  var maxBufferLength = buffer.constants.MAX_LENGTH;

  class PooledBuffer {
    get size() {
      return this._size;
    }
    constructor(capacity, buffers, totalLength) {
      this.buffers = [];
      this.capacity = capacity;
      this._size = 0;
      const bufferNum = Math.ceil(capacity / maxBufferLength);
      for (let i = 0;i < bufferNum; i++) {
        let len = i === bufferNum - 1 ? capacity % maxBufferLength : maxBufferLength;
        if (len === 0) {
          len = maxBufferLength;
        }
        this.buffers.push(Buffer.allocUnsafe(len));
      }
      if (buffers) {
        this.fill(buffers, totalLength);
      }
    }
    fill(buffers, totalLength) {
      this._size = Math.min(this.capacity, totalLength);
      let i = 0, j = 0, targetOffset = 0, sourceOffset = 0, totalCopiedNum = 0;
      while (totalCopiedNum < this._size) {
        const source = buffers[i];
        const target = this.buffers[j];
        const copiedNum = source.copy(target, targetOffset, sourceOffset);
        totalCopiedNum += copiedNum;
        sourceOffset += copiedNum;
        targetOffset += copiedNum;
        if (sourceOffset === source.length) {
          i++;
          sourceOffset = 0;
        }
        if (targetOffset === target.length) {
          j++;
          targetOffset = 0;
        }
      }
      buffers.splice(0, i);
      if (buffers.length > 0) {
        buffers[0] = buffers[0].slice(sourceOffset);
      }
    }
    getReadableStream() {
      return new BuffersStream(this.buffers, this.size);
    }
  }

  class BufferScheduler {
    constructor(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
      this.emitter = new events.EventEmitter;
      this.offset = 0;
      this.isStreamEnd = false;
      this.isError = false;
      this.executingOutgoingHandlers = 0;
      this.numBuffers = 0;
      this.unresolvedDataArray = [];
      this.unresolvedLength = 0;
      this.incoming = [];
      this.outgoing = [];
      if (bufferSize <= 0) {
        throw new RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);
      }
      if (maxBuffers <= 0) {
        throw new RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);
      }
      if (concurrency <= 0) {
        throw new RangeError(`concurrency must be larger than 0, current is ${concurrency}`);
      }
      this.bufferSize = bufferSize;
      this.maxBuffers = maxBuffers;
      this.readable = readable;
      this.outgoingHandler = outgoingHandler;
      this.concurrency = concurrency;
      this.encoding = encoding;
    }
    async do() {
      return new Promise((resolve, reject) => {
        this.readable.on("data", (data) => {
          data = typeof data === "string" ? Buffer.from(data, this.encoding) : data;
          this.appendUnresolvedData(data);
          if (!this.resolveData()) {
            this.readable.pause();
          }
        });
        this.readable.on("error", (err) => {
          this.emitter.emit("error", err);
        });
        this.readable.on("end", () => {
          this.isStreamEnd = true;
          this.emitter.emit("checkEnd");
        });
        this.emitter.on("error", (err) => {
          this.isError = true;
          this.readable.pause();
          reject(err);
        });
        this.emitter.on("checkEnd", () => {
          if (this.outgoing.length > 0) {
            this.triggerOutgoingHandlers();
            return;
          }
          if (this.isStreamEnd && this.executingOutgoingHandlers === 0) {
            if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
              const buffer2 = this.shiftBufferFromUnresolvedDataArray();
              this.outgoingHandler(() => buffer2.getReadableStream(), buffer2.size, this.offset).then(resolve).catch(reject);
            } else if (this.unresolvedLength >= this.bufferSize) {
              return;
            } else {
              resolve();
            }
          }
        });
      });
    }
    appendUnresolvedData(data) {
      this.unresolvedDataArray.push(data);
      this.unresolvedLength += data.length;
    }
    shiftBufferFromUnresolvedDataArray(buffer2) {
      if (!buffer2) {
        buffer2 = new PooledBuffer(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength);
      } else {
        buffer2.fill(this.unresolvedDataArray, this.unresolvedLength);
      }
      this.unresolvedLength -= buffer2.size;
      return buffer2;
    }
    resolveData() {
      while (this.unresolvedLength >= this.bufferSize) {
        let buffer2;
        if (this.incoming.length > 0) {
          buffer2 = this.incoming.shift();
          this.shiftBufferFromUnresolvedDataArray(buffer2);
        } else {
          if (this.numBuffers < this.maxBuffers) {
            buffer2 = this.shiftBufferFromUnresolvedDataArray();
            this.numBuffers++;
          } else {
            return false;
          }
        }
        this.outgoing.push(buffer2);
        this.triggerOutgoingHandlers();
      }
      return true;
    }
    async triggerOutgoingHandlers() {
      let buffer2;
      do {
        if (this.executingOutgoingHandlers >= this.concurrency) {
          return;
        }
        buffer2 = this.outgoing.shift();
        if (buffer2) {
          this.triggerOutgoingHandler(buffer2);
        }
      } while (buffer2);
    }
    async triggerOutgoingHandler(buffer2) {
      const bufferLength = buffer2.size;
      this.executingOutgoingHandlers++;
      this.offset += bufferLength;
      try {
        await this.outgoingHandler(() => buffer2.getReadableStream(), bufferLength, this.offset - bufferLength);
      } catch (err) {
        this.emitter.emit("error", err);
        return;
      }
      this.executingOutgoingHandlers--;
      this.reuseBuffer(buffer2);
      this.emitter.emit("checkEnd");
    }
    reuseBuffer(buffer2) {
      this.incoming.push(buffer2);
      if (!this.isError && this.resolveData() && !this.isStreamEnd) {
        this.readable.resume();
      }
    }
  }
  async function streamToBuffer(stream2, buffer2, offset, end, encoding) {
    let pos = 0;
    const count = end - offset;
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error(`The operation cannot be completed in timeout.`)), REQUEST_TIMEOUT);
      stream2.on("readable", () => {
        if (pos >= count) {
          clearTimeout(timeout);
          resolve();
          return;
        }
        let chunk = stream2.read();
        if (!chunk) {
          return;
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        const chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
        buffer2.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
        pos += chunkLength;
      });
      stream2.on("end", () => {
        clearTimeout(timeout);
        if (pos < count) {
          reject(new Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`));
        }
        resolve();
      });
      stream2.on("error", (msg) => {
        clearTimeout(timeout);
        reject(msg);
      });
    });
  }
  async function streamToBuffer2(stream2, buffer2, encoding) {
    let pos = 0;
    const bufferSize = buffer2.length;
    return new Promise((resolve, reject) => {
      stream2.on("readable", () => {
        let chunk = stream2.read();
        if (!chunk) {
          return;
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        if (pos + chunk.length > bufferSize) {
          reject(new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));
          return;
        }
        buffer2.fill(chunk, pos, pos + chunk.length);
        pos += chunk.length;
      });
      stream2.on("end", () => {
        resolve(pos);
      });
      stream2.on("error", reject);
    });
  }
  async function readStreamToLocalFile(rs, file) {
    return new Promise((resolve, reject) => {
      const ws = fs__namespace.createWriteStream(file);
      rs.on("error", (err) => {
        reject(err);
      });
      ws.on("error", (err) => {
        reject(err);
      });
      ws.on("close", resolve);
      rs.pipe(ws);
    });
  }
  var fsStat = util__namespace.promisify(fs__namespace.stat);
  var fsCreateReadStream = fs__namespace.createReadStream;

  class BlobClient extends StorageClient {
    get name() {
      return this._name;
    }
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      options = options || {};
      let pipeline;
      let url2;
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
          options = blobNameOrOptions;
        }
        pipeline = newPipeline(new AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline = newPipeline(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = newPipeline(new AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline);
      ({ blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl());
      this.blobContext = this.storageClientContext.blob;
      this._snapshot = getURLParameter(this.url, URLConstants.Parameters.SNAPSHOT);
      this._versionId = getURLParameter(this.url, URLConstants.Parameters.VERSIONID);
    }
    withSnapshot(snapshot2) {
      return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    withVersion(versionId2) {
      return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.VERSIONID, versionId2.length === 0 ? undefined : versionId2), this.pipeline);
    }
    getAppendBlobClient() {
      return new AppendBlobClient(this.url, this.pipeline);
    }
    getBlockBlobClient() {
      return new BlockBlobClient(this.url, this.pipeline);
    }
    getPageBlobClient() {
      return new PageBlobClient(this.url, this.pipeline);
    }
    async download(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-download", options, async (updatedOptions) => {
        var _a;
        const res = assertResponse(await this.blobContext.download({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          requestOptions: {
            onDownloadProgress: coreUtil.isNode ? undefined : options.onProgress
          },
          range: offset === 0 && !count ? undefined : rangeToString({ offset, count }),
          rangeGetContentMD5: options.rangeGetContentMD5,
          rangeGetContentCRC64: options.rangeGetContentCrc64,
          snapshot: options.snapshot,
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedRes = Object.assign(Object.assign({}, res), { _response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules) });
        if (!coreUtil.isNode) {
          return wrappedRes;
        }
        if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {
          options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
        }
        if (res.contentLength === undefined) {
          throw new RangeError(`File download response doesn't contain valid content length header`);
        }
        if (!res.etag) {
          throw new RangeError(`File download response doesn't contain valid etag header`);
        }
        return new BlobDownloadResponse(wrappedRes, async (start) => {
          var _a2;
          const updatedDownloadOptions = {
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ifMatch: options.conditions.ifMatch || res.etag,
              ifModifiedSince: options.conditions.ifModifiedSince,
              ifNoneMatch: options.conditions.ifNoneMatch,
              ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,
              ifTags: (_a2 = options.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions
            },
            range: rangeToString({
              count: offset + res.contentLength - start,
              offset: start
            }),
            rangeGetContentMD5: options.rangeGetContentMD5,
            rangeGetContentCRC64: options.rangeGetContentCrc64,
            snapshot: options.snapshot,
            cpkInfo: options.customerProvidedKey
          };
          return (await this.blobContext.download(Object.assign({ abortSignal: options.abortSignal }, updatedDownloadOptions))).readableStreamBody;
        }, offset, res.contentLength, {
          maxRetryRequests: options.maxRetryRequests,
          onProgress: options.onProgress
        });
      });
    }
    async exists(options = {}) {
      return tracingClient.withSpan("BlobClient-exists", options, async (updatedOptions) => {
        try {
          ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
          await this.getProperties({
            abortSignal: options.abortSignal,
            customerProvidedKey: options.customerProvidedKey,
            conditions: options.conditions,
            tracingOptions: updatedOptions.tracingOptions
          });
          return true;
        } catch (e) {
          if (e.statusCode === 404) {
            return false;
          } else if (e.statusCode === 409 && (e.details.errorCode === BlobUsesCustomerSpecifiedEncryptionMsg || e.details.errorCode === BlobDoesNotUseCustomerSpecifiedEncryption)) {
            return true;
          }
          throw e;
        }
      });
    }
    async getProperties(options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-getProperties", options, async (updatedOptions) => {
        var _a;
        const res = assertResponse(await this.blobContext.getProperties({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return Object.assign(Object.assign({}, res), { _response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules) });
      });
    }
    async delete(options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("BlobClient-delete", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.delete({
          abortSignal: options.abortSignal,
          deleteSnapshots: options.deleteSnapshots,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async deleteIfExists(options = {}) {
      return tracingClient.withSpan("BlobClient-deleteIfExists", options, async (updatedOptions) => {
        var _a, _b;
        try {
          const res = assertResponse(await this.delete(updatedOptions));
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e) {
          if (((_a = e.details) === null || _a === undefined ? undefined : _a.errorCode) === "BlobNotFound") {
            return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === undefined ? undefined : _b.parsedHeaders), { _response: e.response });
          }
          throw e;
        }
      });
    }
    async undelete(options = {}) {
      return tracingClient.withSpan("BlobClient-undelete", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.undelete({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setHTTPHeaders(blobHTTPHeaders, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-setHTTPHeaders", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.setHttpHeaders({
          abortSignal: options.abortSignal,
          blobHttpHeaders: blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setMetadata(metadata2, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-setMetadata", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.setMetadata({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: metadata2,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setTags(tags2, options = {}) {
      return tracingClient.withSpan("BlobClient-setTags", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.setTags({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions,
          tags: toBlobTags(tags2)
        }));
      });
    }
    async getTags(options = {}) {
      return tracingClient.withSpan("BlobClient-getTags", options, async (updatedOptions) => {
        var _a;
        const response = assertResponse(await this.blobContext.getTags({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, tags: toTags({ blobTagSet: response.blobTagSet }) || {} });
        return wrappedResponse;
      });
    }
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient(this, proposeLeaseId);
    }
    async createSnapshot(options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-createSnapshot", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.createSnapshot({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async beginCopyFromURL(copySource2, options = {}) {
      const client = {
        abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),
        getProperties: (...args) => this.getProperties(...args),
        startCopyFromURL: (...args) => this.startCopyFromURL(...args)
      };
      const poller = new BlobBeginCopyFromUrlPoller({
        blobClient: client,
        copySource: copySource2,
        intervalInMs: options.intervalInMs,
        onProgress: options.onProgress,
        resumeFrom: options.resumeFrom,
        startCopyFromURLOptions: options
      });
      await poller.poll();
      return poller;
    }
    async abortCopyFromURL(copyId2, options = {}) {
      return tracingClient.withSpan("BlobClient-abortCopyFromURL", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.abortCopyFromURL(copyId2, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async syncCopyFromURL(copySource2, options = {}) {
      options.conditions = options.conditions || {};
      options.sourceConditions = options.sourceConditions || {};
      return tracingClient.withSpan("BlobClient-syncCopyFromURL", options, async (updatedOptions) => {
        var _a, _b, _c, _d, _e, _f, _g;
        return assertResponse(await this.blobContext.copyFromURL(copySource2, {
          abortSignal: options.abortSignal,
          metadata: options.metadata,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: (_b = options.sourceConditions) === null || _b === undefined ? undefined : _b.ifMatch,
            sourceIfModifiedSince: (_c = options.sourceConditions) === null || _c === undefined ? undefined : _c.ifModifiedSince,
            sourceIfNoneMatch: (_d = options.sourceConditions) === null || _d === undefined ? undefined : _d.ifNoneMatch,
            sourceIfUnmodifiedSince: (_e = options.sourceConditions) === null || _e === undefined ? undefined : _e.ifUnmodifiedSince
          },
          sourceContentMD5: options.sourceContentMD5,
          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
          tier: toAccessTier(options.tier),
          blobTagsString: toBlobTagsString(options.tags),
          immutabilityPolicyExpiry: (_f = options.immutabilityPolicy) === null || _f === undefined ? undefined : _f.expiriesOn,
          immutabilityPolicyMode: (_g = options.immutabilityPolicy) === null || _g === undefined ? undefined : _g.policyMode,
          legalHold: options.legalHold,
          encryptionScope: options.encryptionScope,
          copySourceTags: options.copySourceTags,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setAccessTier(tier2, options = {}) {
      return tracingClient.withSpan("BlobClient-setAccessTier", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.setTier(toAccessTier(tier2), {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          rehydratePriority: options.rehydratePriority,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async downloadToBuffer(param1, param2, param3, param4 = {}) {
      var _a;
      let buffer2;
      let offset = 0;
      let count = 0;
      let options = param4;
      if (param1 instanceof Buffer) {
        buffer2 = param1;
        offset = param2 || 0;
        count = typeof param3 === "number" ? param3 : 0;
      } else {
        offset = typeof param1 === "number" ? param1 : 0;
        count = typeof param2 === "number" ? param2 : 0;
        options = param3 || {};
      }
      let blockSize = (_a = options.blockSize) !== null && _a !== undefined ? _a : 0;
      if (blockSize < 0) {
        throw new RangeError("blockSize option must be >= 0");
      }
      if (blockSize === 0) {
        blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
      }
      if (offset < 0) {
        throw new RangeError("offset option must be >= 0");
      }
      if (count && count <= 0) {
        throw new RangeError("count option must be greater than 0");
      }
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("BlobClient-downloadToBuffer", options, async (updatedOptions) => {
        if (!count) {
          const response = await this.getProperties(Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));
          count = response.contentLength - offset;
          if (count < 0) {
            throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);
          }
        }
        if (!buffer2) {
          try {
            buffer2 = Buffer.alloc(count);
          } catch (error) {
            throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".\t ${error.message}`);
          }
        }
        if (buffer2.length < count) {
          throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);
        }
        let transferProgress = 0;
        const batch = new Batch(options.concurrency);
        for (let off = offset;off < offset + count; off = off + blockSize) {
          batch.addOperation(async () => {
            let chunkEnd = offset + count;
            if (off + blockSize < chunkEnd) {
              chunkEnd = off + blockSize;
            }
            const response = await this.download(off, chunkEnd - off, {
              abortSignal: options.abortSignal,
              conditions: options.conditions,
              maxRetryRequests: options.maxRetryRequestsPerBlock,
              customerProvidedKey: options.customerProvidedKey,
              tracingOptions: updatedOptions.tracingOptions
            });
            const stream2 = response.readableStreamBody;
            await streamToBuffer(stream2, buffer2, off - offset, chunkEnd - offset);
            transferProgress += chunkEnd - off;
            if (options.onProgress) {
              options.onProgress({ loadedBytes: transferProgress });
            }
          });
        }
        await batch.do();
        return buffer2;
      });
    }
    async downloadToFile(filePath, offset = 0, count, options = {}) {
      return tracingClient.withSpan("BlobClient-downloadToFile", options, async (updatedOptions) => {
        const response = await this.download(offset, count, Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));
        if (response.readableStreamBody) {
          await readStreamToLocalFile(response.readableStreamBody, filePath);
        }
        response.blobDownloadStream = undefined;
        return response;
      });
    }
    getBlobAndContainerNamesFromUrl() {
      let containerName;
      let blobName;
      try {
        const parsedUrl = new URL(this.url);
        if (parsedUrl.host.split(".")[1] === "blob") {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1];
          blobName = pathComponents[3];
        } else if (isIpEndpointStyle(parsedUrl)) {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
          containerName = pathComponents[2];
          blobName = pathComponents[4];
        } else {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1];
          blobName = pathComponents[3];
        }
        containerName = decodeURIComponent(containerName);
        blobName = decodeURIComponent(blobName);
        blobName = blobName.replace(/\\/g, "/");
        if (!containerName) {
          throw new Error("Provided containerName is invalid.");
        }
        return { blobName, containerName };
      } catch (error) {
        throw new Error("Unable to extract blobName and containerName with provided information.");
      }
    }
    async startCopyFromURL(copySource2, options = {}) {
      return tracingClient.withSpan("BlobClient-startCopyFromURL", options, async (updatedOptions) => {
        var _a, _b, _c;
        options.conditions = options.conditions || {};
        options.sourceConditions = options.sourceConditions || {};
        return assertResponse(await this.blobContext.startCopyFromURL(copySource2, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions.ifMatch,
            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,
            sourceIfTags: options.sourceConditions.tagConditions
          },
          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === undefined ? undefined : _b.expiriesOn,
          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === undefined ? undefined : _c.policyMode,
          legalHold: options.legalHold,
          rehydratePriority: options.rehydratePriority,
          tier: toAccessTier(options.tier),
          blobTagsString: toBlobTagsString(options.tags),
          sealBlob: options.sealBlob,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    generateSasUrl(options) {
      return new Promise((resolve) => {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options), this.credential).toString();
        resolve(appendToURLQuery(this.url, sas));
      });
    }
    generateSasStringToSign(options) {
      if (!(this.credential instanceof StorageSharedKeyCredential)) {
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      }
      return generateBlobSASQueryParametersInternal(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options), this.credential).stringToSign;
    }
    generateUserDelegationSasUrl(options, userDelegationKey) {
      return new Promise((resolve) => {
        const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options), userDelegationKey, this.accountName).toString();
        resolve(appendToURLQuery(this.url, sas));
      });
    }
    generateUserDelegationSasStringToSign(options, userDelegationKey) {
      return generateBlobSASQueryParametersInternal(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options), userDelegationKey, this.accountName).stringToSign;
    }
    async deleteImmutabilityPolicy(options = {}) {
      return tracingClient.withSpan("BlobClient-deleteImmutabilityPolicy", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.deleteImmutabilityPolicy({
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setImmutabilityPolicy(immutabilityPolicy, options = {}) {
      return tracingClient.withSpan("BlobClient-setImmutabilityPolicy", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.setImmutabilityPolicy({
          immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,
          immutabilityPolicyMode: immutabilityPolicy.policyMode,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setLegalHold(legalHoldEnabled, options = {}) {
      return tracingClient.withSpan("BlobClient-setLegalHold", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.setLegalHold(legalHoldEnabled, {
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccountInfo(options = {}) {
      return tracingClient.withSpan("BlobClient-getAccountInfo", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }

  class AppendBlobClient extends BlobClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline;
      let url2;
      options = options || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        pipeline = newPipeline(new AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline = newPipeline(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = newPipeline(new AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline);
      this.appendBlobContext = this.storageClientContext.appendBlob;
    }
    withSnapshot(snapshot2) {
      return new AppendBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    async create(options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("AppendBlobClient-create", options, async (updatedOptions) => {
        var _a, _b, _c;
        return assertResponse(await this.appendBlobContext.create(0, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === undefined ? undefined : _b.expiriesOn,
          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === undefined ? undefined : _c.policyMode,
          legalHold: options.legalHold,
          blobTagsString: toBlobTagsString(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async createIfNotExists(options = {}) {
      const conditions = { ifNoneMatch: ETagAny };
      return tracingClient.withSpan("AppendBlobClient-createIfNotExists", options, async (updatedOptions) => {
        var _a, _b;
        try {
          const res = assertResponse(await this.create(Object.assign(Object.assign({}, updatedOptions), { conditions })));
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e) {
          if (((_a = e.details) === null || _a === undefined ? undefined : _a.errorCode) === "BlobAlreadyExists") {
            return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === undefined ? undefined : _b.parsedHeaders), { _response: e.response });
          }
          throw e;
        }
      });
    }
    async seal(options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("AppendBlobClient-seal", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.appendBlobContext.seal({
          abortSignal: options.abortSignal,
          appendPositionAccessConditions: options.conditions,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async appendBlock(body2, contentLength2, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("AppendBlobClient-appendBlock", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.appendBlobContext.appendBlock(contentLength2, body2, {
          abortSignal: options.abortSignal,
          appendPositionAccessConditions: options.conditions,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {
      options.conditions = options.conditions || {};
      options.sourceConditions = options.sourceConditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("AppendBlobClient-appendBlockFromURL", options, async (updatedOptions) => {
        var _a, _b, _c, _d, _e;
        return assertResponse(await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {
          abortSignal: options.abortSignal,
          sourceRange: rangeToString({ offset: sourceOffset, count }),
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          leaseAccessConditions: options.conditions,
          appendPositionAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: (_b = options.sourceConditions) === null || _b === undefined ? undefined : _b.ifMatch,
            sourceIfModifiedSince: (_c = options.sourceConditions) === null || _c === undefined ? undefined : _c.ifModifiedSince,
            sourceIfNoneMatch: (_d = options.sourceConditions) === null || _d === undefined ? undefined : _d.ifNoneMatch,
            sourceIfUnmodifiedSince: (_e = options.sourceConditions) === null || _e === undefined ? undefined : _e.ifUnmodifiedSince
          },
          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }

  class BlockBlobClient extends BlobClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline;
      let url2;
      options = options || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
          options = blobNameOrOptions;
        }
        pipeline = newPipeline(new AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline = newPipeline(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = newPipeline(new AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline);
      this.blockBlobContext = this.storageClientContext.blockBlob;
      this._blobContext = this.storageClientContext.blob;
    }
    withSnapshot(snapshot2) {
      return new BlockBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    async query(query, options = {}) {
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      if (!coreUtil.isNode) {
        throw new Error("This operation currently is only supported in Node.js.");
      }
      return tracingClient.withSpan("BlockBlobClient-query", options, async (updatedOptions) => {
        var _a;
        const response = assertResponse(await this._blobContext.query({
          abortSignal: options.abortSignal,
          queryRequest: {
            queryType: "SQL",
            expression: query,
            inputSerialization: toQuerySerialization(options.inputTextConfiguration),
            outputSerialization: toQuerySerialization(options.outputTextConfiguration)
          },
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return new BlobQueryResponse(response, {
          abortSignal: options.abortSignal,
          onProgress: options.onProgress,
          onError: options.onError
        });
      });
    }
    async upload(body2, contentLength2, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-upload", options, async (updatedOptions) => {
        var _a, _b, _c;
        return assertResponse(await this.blockBlobContext.upload(contentLength2, body2, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === undefined ? undefined : _b.expiriesOn,
          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === undefined ? undefined : _c.policyMode,
          legalHold: options.legalHold,
          tier: toAccessTier(options.tier),
          blobTagsString: toBlobTagsString(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async syncUploadFromURL(sourceURL, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-syncUploadFromURL", options, async (updatedOptions) => {
        var _a, _b, _c, _d, _e, _f;
        return assertResponse(await this.blockBlobContext.putBlobFromUrl(0, sourceURL, Object.assign(Object.assign({}, options), { blobHttpHeaders: options.blobHTTPHeaders, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }), sourceModifiedAccessConditions: {
          sourceIfMatch: (_b = options.sourceConditions) === null || _b === undefined ? undefined : _b.ifMatch,
          sourceIfModifiedSince: (_c = options.sourceConditions) === null || _c === undefined ? undefined : _c.ifModifiedSince,
          sourceIfNoneMatch: (_d = options.sourceConditions) === null || _d === undefined ? undefined : _d.ifNoneMatch,
          sourceIfUnmodifiedSince: (_e = options.sourceConditions) === null || _e === undefined ? undefined : _e.ifUnmodifiedSince,
          sourceIfTags: (_f = options.sourceConditions) === null || _f === undefined ? undefined : _f.tagConditions
        }, cpkInfo: options.customerProvidedKey, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization), tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags), copySourceTags: options.copySourceTags, tracingOptions: updatedOptions.tracingOptions })));
      });
    }
    async stageBlock(blockId2, body2, contentLength2, options = {}) {
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-stageBlock", options, async (updatedOptions) => {
        return assertResponse(await this.blockBlobContext.stageBlock(blockId2, contentLength2, body2, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async stageBlockFromURL(blockId2, sourceURL, offset = 0, count, options = {}) {
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-stageBlockFromURL", options, async (updatedOptions) => {
        return assertResponse(await this.blockBlobContext.stageBlockFromURL(blockId2, 0, sourceURL, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          sourceRange: offset === 0 && !count ? undefined : rangeToString({ offset, count }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async commitBlockList(blocks2, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-commitBlockList", options, async (updatedOptions) => {
        var _a, _b, _c;
        return assertResponse(await this.blockBlobContext.commitBlockList({ latest: blocks2 }, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === undefined ? undefined : _b.expiriesOn,
          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === undefined ? undefined : _c.policyMode,
          legalHold: options.legalHold,
          tier: toAccessTier(options.tier),
          blobTagsString: toBlobTagsString(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getBlockList(listType2, options = {}) {
      return tracingClient.withSpan("BlockBlobClient-getBlockList", options, async (updatedOptions) => {
        var _a;
        const res = assertResponse(await this.blockBlobContext.getBlockList(listType2, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        if (!res.committedBlocks) {
          res.committedBlocks = [];
        }
        if (!res.uncommittedBlocks) {
          res.uncommittedBlocks = [];
        }
        return res;
      });
    }
    async uploadData(data, options = {}) {
      return tracingClient.withSpan("BlockBlobClient-uploadData", options, async (updatedOptions) => {
        if (coreUtil.isNode) {
          let buffer2;
          if (data instanceof Buffer) {
            buffer2 = data;
          } else if (data instanceof ArrayBuffer) {
            buffer2 = Buffer.from(data);
          } else {
            data = data;
            buffer2 = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
          }
          return this.uploadSeekableInternal((offset, size) => buffer2.slice(offset, offset + size), buffer2.byteLength, updatedOptions);
        } else {
          const browserBlob = new Blob([data]);
          return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
        }
      });
    }
    async uploadBrowserData(browserData, options = {}) {
      return tracingClient.withSpan("BlockBlobClient-uploadBrowserData", options, async (updatedOptions) => {
        const browserBlob = new Blob([browserData]);
        return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
      });
    }
    async uploadSeekableInternal(bodyFactory, size, options = {}) {
      var _a, _b;
      let blockSize = (_a = options.blockSize) !== null && _a !== undefined ? _a : 0;
      if (blockSize < 0 || blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {
        throw new RangeError(`blockSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);
      }
      const maxSingleShotSize = (_b = options.maxSingleShotSize) !== null && _b !== undefined ? _b : BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
      if (maxSingleShotSize < 0 || maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {
        throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);
      }
      if (blockSize === 0) {
        if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS) {
          throw new RangeError(`${size} is too larger to upload to a block blob.`);
        }
        if (size > maxSingleShotSize) {
          blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);
          if (blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {
            blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
          }
        }
      }
      if (!options.blobHTTPHeaders) {
        options.blobHTTPHeaders = {};
      }
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("BlockBlobClient-uploadSeekableInternal", options, async (updatedOptions) => {
        if (size <= maxSingleShotSize) {
          return assertResponse(await this.upload(bodyFactory(0, size), size, updatedOptions));
        }
        const numBlocks = Math.floor((size - 1) / blockSize) + 1;
        if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {
          throw new RangeError(`The buffer's size is too big or the BlockSize is too small;` + `the number of blocks must be <= ${BLOCK_BLOB_MAX_BLOCKS}`);
        }
        const blockList = [];
        const blockIDPrefix = coreUtil.randomUUID();
        let transferProgress = 0;
        const batch = new Batch(options.concurrency);
        for (let i = 0;i < numBlocks; i++) {
          batch.addOperation(async () => {
            const blockID = generateBlockID(blockIDPrefix, i);
            const start = blockSize * i;
            const end = i === numBlocks - 1 ? size : start + blockSize;
            const contentLength2 = end - start;
            blockList.push(blockID);
            await this.stageBlock(blockID, bodyFactory(start, contentLength2), contentLength2, {
              abortSignal: options.abortSignal,
              conditions: options.conditions,
              encryptionScope: options.encryptionScope,
              tracingOptions: updatedOptions.tracingOptions
            });
            transferProgress += contentLength2;
            if (options.onProgress) {
              options.onProgress({
                loadedBytes: transferProgress
              });
            }
          });
        }
        await batch.do();
        return this.commitBlockList(blockList, updatedOptions);
      });
    }
    async uploadFile(filePath, options = {}) {
      return tracingClient.withSpan("BlockBlobClient-uploadFile", options, async (updatedOptions) => {
        const size = (await fsStat(filePath)).size;
        return this.uploadSeekableInternal((offset, count) => {
          return () => fsCreateReadStream(filePath, {
            autoClose: true,
            end: count ? offset + count - 1 : Infinity,
            start: offset
          });
        }, size, Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));
      });
    }
    async uploadStream(stream2, bufferSize = DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {
      if (!options.blobHTTPHeaders) {
        options.blobHTTPHeaders = {};
      }
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("BlockBlobClient-uploadStream", options, async (updatedOptions) => {
        let blockNum = 0;
        const blockIDPrefix = coreUtil.randomUUID();
        let transferProgress = 0;
        const blockList = [];
        const scheduler = new BufferScheduler(stream2, bufferSize, maxConcurrency, async (body2, length) => {
          const blockID = generateBlockID(blockIDPrefix, blockNum);
          blockList.push(blockID);
          blockNum++;
          await this.stageBlock(blockID, body2, length, {
            customerProvidedKey: options.customerProvidedKey,
            conditions: options.conditions,
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          });
          transferProgress += length;
          if (options.onProgress) {
            options.onProgress({ loadedBytes: transferProgress });
          }
        }, Math.ceil(maxConcurrency / 4 * 3));
        await scheduler.do();
        return assertResponse(await this.commitBlockList(blockList, Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions })));
      });
    }
  }

  class PageBlobClient extends BlobClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline;
      let url2;
      options = options || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        pipeline = newPipeline(new AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline = newPipeline(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = newPipeline(new AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline);
      this.pageBlobContext = this.storageClientContext.pageBlob;
    }
    withSnapshot(snapshot2) {
      return new PageBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    async create(size, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("PageBlobClient-create", options, async (updatedOptions) => {
        var _a, _b, _c;
        return assertResponse(await this.pageBlobContext.create(0, size, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          blobSequenceNumber: options.blobSequenceNumber,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: (_b = options.immutabilityPolicy) === null || _b === undefined ? undefined : _b.expiriesOn,
          immutabilityPolicyMode: (_c = options.immutabilityPolicy) === null || _c === undefined ? undefined : _c.policyMode,
          legalHold: options.legalHold,
          tier: toAccessTier(options.tier),
          blobTagsString: toBlobTagsString(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async createIfNotExists(size, options = {}) {
      return tracingClient.withSpan("PageBlobClient-createIfNotExists", options, async (updatedOptions) => {
        var _a, _b;
        try {
          const conditions = { ifNoneMatch: ETagAny };
          const res = assertResponse(await this.create(size, Object.assign(Object.assign({}, options), { conditions, tracingOptions: updatedOptions.tracingOptions })));
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e) {
          if (((_a = e.details) === null || _a === undefined ? undefined : _a.errorCode) === "BlobAlreadyExists") {
            return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === undefined ? undefined : _b.parsedHeaders), { _response: e.response });
          }
          throw e;
        }
      });
    }
    async uploadPages(body2, offset, count, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("PageBlobClient-uploadPages", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.uploadPages(count, body2, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          range: rangeToString({ offset, count }),
          sequenceNumberAccessConditions: options.conditions,
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {
      options.conditions = options.conditions || {};
      options.sourceConditions = options.sourceConditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("PageBlobClient-uploadPagesFromURL", options, async (updatedOptions) => {
        var _a, _b, _c, _d, _e;
        return assertResponse(await this.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({ offset: sourceOffset, count }), 0, rangeToString({ offset: destOffset, count }), {
          abortSignal: options.abortSignal,
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          leaseAccessConditions: options.conditions,
          sequenceNumberAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: (_b = options.sourceConditions) === null || _b === undefined ? undefined : _b.ifMatch,
            sourceIfModifiedSince: (_c = options.sourceConditions) === null || _c === undefined ? undefined : _c.ifModifiedSince,
            sourceIfNoneMatch: (_d = options.sourceConditions) === null || _d === undefined ? undefined : _d.ifNoneMatch,
            sourceIfUnmodifiedSince: (_e = options.sourceConditions) === null || _e === undefined ? undefined : _e.ifUnmodifiedSince
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async clearPages(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-clearPages", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.clearPages(0, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          range: rangeToString({ offset, count }),
          sequenceNumberAccessConditions: options.conditions,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getPageRanges(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-getPageRanges", options, async (updatedOptions) => {
        var _a;
        const response = assertResponse(await this.pageBlobContext.getPageRanges({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          range: rangeToString({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return rangeResponseFromModel(response);
      });
    }
    async listPageRangesSegment(offset = 0, count, marker2, options = {}) {
      return tracingClient.withSpan("PageBlobClient-getPageRangesSegment", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.getPageRanges({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          range: rangeToString({ offset, count }),
          marker: marker2,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    listPageRangeItemSegments() {
      return tslib.__asyncGenerator(this, arguments, function* listPageRangeItemSegments_1(offset = 0, count, marker2, options = {}) {
        let getPageRangeItemSegmentsResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            getPageRangeItemSegmentsResponse = yield tslib.__await(this.listPageRangesSegment(offset, count, marker2, options));
            marker2 = getPageRangeItemSegmentsResponse.continuationToken;
            yield yield tslib.__await(yield tslib.__await(getPageRangeItemSegmentsResponse));
          } while (marker2);
        }
      });
    }
    listPageRangeItems() {
      return tslib.__asyncGenerator(this, arguments, function* listPageRangeItems_1(offset = 0, count, options = {}) {
        var _a, e_1, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.listPageRangeItemSegments(offset, count, marker2, options)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const getPageRangesSegment = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    listPageRanges(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      const iter = this.listPageRangeItems(offset, count, options);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listPageRangeItemSegments(offset, count, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
        }
      };
    }
    async getPageRangesDiff(offset, count, prevSnapshot, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-getPageRangesDiff", options, async (updatedOptions) => {
        var _a;
        const result = assertResponse(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          prevsnapshot: prevSnapshot,
          range: rangeToString({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return rangeResponseFromModel(result);
      });
    }
    async listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker2, options = {}) {
      return tracingClient.withSpan("PageBlobClient-getPageRangesDiffSegment", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options === null || options === undefined ? undefined : options.abortSignal,
          leaseAccessConditions: options === null || options === undefined ? undefined : options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options === null || options === undefined ? undefined : options.conditions), { ifTags: (_a = options === null || options === undefined ? undefined : options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          prevsnapshot: prevSnapshotOrUrl,
          range: rangeToString({
            offset,
            count
          }),
          marker: marker2,
          maxPageSize: options === null || options === undefined ? undefined : options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker2, options) {
      return tslib.__asyncGenerator(this, arguments, function* listPageRangeDiffItemSegments_1() {
        let getPageRangeItemSegmentsResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            getPageRangeItemSegmentsResponse = yield tslib.__await(this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker2, options));
            marker2 = getPageRangeItemSegmentsResponse.continuationToken;
            yield yield tslib.__await(yield tslib.__await(getPageRangeItemSegmentsResponse));
          } while (marker2);
        }
      });
    }
    listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options) {
      return tslib.__asyncGenerator(this, arguments, function* listPageRangeDiffItems_1() {
        var _a, e_2, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker2, options)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const getPageRangesSegment = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))));
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    listPageRangesDiff(offset, count, prevSnapshot, options = {}) {
      options.conditions = options.conditions || {};
      const iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, Object.assign({}, options));
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
        }
      };
    }
    async getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl2, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", options, async (updatedOptions) => {
        var _a;
        const response = assertResponse(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          prevSnapshotUrl: prevSnapshotUrl2,
          range: rangeToString({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return rangeResponseFromModel(response);
      });
    }
    async resize(size, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-resize", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.resize(size, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async updateSequenceNumber(sequenceNumberAction2, sequenceNumber, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-updateSequenceNumber", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction2, {
          abortSignal: options.abortSignal,
          blobSequenceNumber: sequenceNumber,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async startCopyIncremental(copySource2, options = {}) {
      return tracingClient.withSpan("PageBlobClient-startCopyIncremental", options, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.copyIncremental(copySource2, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a = options.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  async function getBodyAsText(batchResponse) {
    let buffer2 = Buffer.alloc(BATCH_MAX_PAYLOAD_IN_BYTES);
    const responseLength = await streamToBuffer2(batchResponse.readableStreamBody, buffer2);
    buffer2 = buffer2.slice(0, responseLength);
    return buffer2.toString();
  }
  function utf8ByteLength(str) {
    return Buffer.byteLength(str);
  }
  var HTTP_HEADER_DELIMITER = ": ";
  var SPACE_DELIMITER = " ";
  var NOT_FOUND = -1;

  class BatchResponseParser {
    constructor(batchResponse, subRequests) {
      if (!batchResponse || !batchResponse.contentType) {
        throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
      }
      if (!subRequests || subRequests.size === 0) {
        throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
      }
      this.batchResponse = batchResponse;
      this.subRequests = subRequests;
      this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1];
      this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;
      this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
    }
    async parseBatchResponse() {
      if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {
        throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
      }
      const responseBodyAsText = await getBodyAsText(this.batchResponse);
      const subResponses = responseBodyAsText.split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1);
      const subResponseCount = subResponses.length;
      if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {
        throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
      }
      const deserializedSubResponses = new Array(subResponseCount);
      let subResponsesSucceededCount = 0;
      let subResponsesFailedCount = 0;
      for (let index = 0;index < subResponseCount; index++) {
        const subResponse = subResponses[index];
        const deserializedSubResponse = {};
        deserializedSubResponse.headers = coreHttpCompat.toHttpHeadersLike(coreRestPipeline.createHttpHeaders());
        const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);
        let subRespHeaderStartFound = false;
        let subRespHeaderEndFound = false;
        let subRespFailed = false;
        let contentId = NOT_FOUND;
        for (const responseLine of responseLines) {
          if (!subRespHeaderStartFound) {
            if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {
              contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);
            }
            if (responseLine.startsWith(HTTP_VERSION_1_1)) {
              subRespHeaderStartFound = true;
              const tokens = responseLine.split(SPACE_DELIMITER);
              deserializedSubResponse.status = parseInt(tokens[1]);
              deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);
            }
            continue;
          }
          if (responseLine.trim() === "") {
            if (!subRespHeaderEndFound) {
              subRespHeaderEndFound = true;
            }
            continue;
          }
          if (!subRespHeaderEndFound) {
            if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {
              throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);
            }
            const tokens = responseLine.split(HTTP_HEADER_DELIMITER);
            deserializedSubResponse.headers.set(tokens[0], tokens[1]);
            if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {
              deserializedSubResponse.errorCode = tokens[1];
              subRespFailed = true;
            }
          } else {
            if (!deserializedSubResponse.bodyAsText) {
              deserializedSubResponse.bodyAsText = "";
            }
            deserializedSubResponse.bodyAsText += responseLine;
          }
        }
        if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === undefined) {
          deserializedSubResponse._request = this.subRequests.get(contentId);
          deserializedSubResponses[contentId] = deserializedSubResponse;
        } else {
          logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);
        }
        if (subRespFailed) {
          subResponsesFailedCount++;
        } else {
          subResponsesSucceededCount++;
        }
      }
      return {
        subResponses: deserializedSubResponses,
        subResponsesSucceededCount,
        subResponsesFailedCount
      };
    }
  }
  var MutexLockStatus;
  (function(MutexLockStatus2) {
    MutexLockStatus2[MutexLockStatus2["LOCKED"] = 0] = "LOCKED";
    MutexLockStatus2[MutexLockStatus2["UNLOCKED"] = 1] = "UNLOCKED";
  })(MutexLockStatus || (MutexLockStatus = {}));

  class Mutex {
    static async lock(key) {
      return new Promise((resolve) => {
        if (this.keys[key] === undefined || this.keys[key] === MutexLockStatus.UNLOCKED) {
          this.keys[key] = MutexLockStatus.LOCKED;
          resolve();
        } else {
          this.onUnlockEvent(key, () => {
            this.keys[key] = MutexLockStatus.LOCKED;
            resolve();
          });
        }
      });
    }
    static async unlock(key) {
      return new Promise((resolve) => {
        if (this.keys[key] === MutexLockStatus.LOCKED) {
          this.emitUnlockEvent(key);
        }
        delete this.keys[key];
        resolve();
      });
    }
    static onUnlockEvent(key, handler) {
      if (this.listeners[key] === undefined) {
        this.listeners[key] = [handler];
      } else {
        this.listeners[key].push(handler);
      }
    }
    static emitUnlockEvent(key) {
      if (this.listeners[key] !== undefined && this.listeners[key].length > 0) {
        const handler = this.listeners[key].shift();
        setImmediate(() => {
          handler.call(this);
        });
      }
    }
  }
  Mutex.keys = {};
  Mutex.listeners = {};

  class BlobBatch {
    constructor() {
      this.batch = "batch";
      this.batchRequest = new InnerBatchRequest;
    }
    getMultiPartContentType() {
      return this.batchRequest.getMultipartContentType();
    }
    getHttpRequestBody() {
      return this.batchRequest.getHttpRequestBody();
    }
    getSubRequests() {
      return this.batchRequest.getSubRequests();
    }
    async addSubRequestInternal(subRequest, assembleSubRequestFunc) {
      await Mutex.lock(this.batch);
      try {
        this.batchRequest.preAddSubRequest(subRequest);
        await assembleSubRequestFunc();
        this.batchRequest.postAddSubRequest(subRequest);
      } finally {
        await Mutex.unlock(this.batch);
      }
    }
    setBatchType(batchType) {
      if (!this.batchType) {
        this.batchType = batchType;
      }
      if (this.batchType !== batchType) {
        throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
      }
    }
    async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {
      let url2;
      let credential;
      if (typeof urlOrBlobClient === "string" && (coreUtil.isNode && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrOptions))) {
        url2 = urlOrBlobClient;
        credential = credentialOrOptions;
      } else if (urlOrBlobClient instanceof BlobClient) {
        url2 = urlOrBlobClient.url;
        credential = urlOrBlobClient.credential;
        options = credentialOrOptions;
      } else {
        throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      }
      if (!options) {
        options = {};
      }
      return tracingClient.withSpan("BatchDeleteRequest-addSubRequest", options, async (updatedOptions) => {
        this.setBatchType("delete");
        await this.addSubRequestInternal({
          url: url2,
          credential
        }, async () => {
          await new BlobClient(url2, this.batchRequest.createPipeline(credential)).delete(updatedOptions);
        });
      });
    }
    async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {
      let url2;
      let credential;
      let tier2;
      if (typeof urlOrBlobClient === "string" && (coreUtil.isNode && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrTier))) {
        url2 = urlOrBlobClient;
        credential = credentialOrTier;
        tier2 = tierOrOptions;
      } else if (urlOrBlobClient instanceof BlobClient) {
        url2 = urlOrBlobClient.url;
        credential = urlOrBlobClient.credential;
        tier2 = credentialOrTier;
        options = tierOrOptions;
      } else {
        throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      }
      if (!options) {
        options = {};
      }
      return tracingClient.withSpan("BatchSetTierRequest-addSubRequest", options, async (updatedOptions) => {
        this.setBatchType("setAccessTier");
        await this.addSubRequestInternal({
          url: url2,
          credential
        }, async () => {
          await new BlobClient(url2, this.batchRequest.createPipeline(credential)).setAccessTier(tier2, updatedOptions);
        });
      });
    }
  }

  class InnerBatchRequest {
    constructor() {
      this.operationCount = 0;
      this.body = "";
      const tempGuid = coreUtil.randomUUID();
      this.boundary = `batch_${tempGuid}`;
      this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;
      this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;
      this.batchRequestEnding = `--${this.boundary}--`;
      this.subRequests = new Map;
    }
    createPipeline(credential) {
      const corePipeline = coreRestPipeline.createEmptyPipeline();
      corePipeline.addPolicy(coreClient.serializationPolicy({
        stringifyXML: coreXml.stringifyXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      }), { phase: "Serialize" });
      corePipeline.addPolicy(batchHeaderFilterPolicy());
      corePipeline.addPolicy(batchRequestAssemblePolicy(this), { afterPhase: "Sign" });
      if (coreAuth.isTokenCredential(credential)) {
        corePipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
          credential,
          scopes: StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: coreClient.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      } else if (credential instanceof StorageSharedKeyCredential) {
        corePipeline.addPolicy(storageSharedKeyCredentialPolicy({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      }
      const pipeline = new Pipeline([]);
      pipeline._credential = credential;
      pipeline._corePipeline = corePipeline;
      return pipeline;
    }
    appendSubRequestToBody(request) {
      this.body += [
        this.subRequestPrefix,
        `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`,
        "",
        `${request.method.toString()} ${getURLPathAndQuery(request.url)} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}`
      ].join(HTTP_LINE_ENDING);
      for (const [name, value] of request.headers) {
        this.body += `${name}: ${value}${HTTP_LINE_ENDING}`;
      }
      this.body += HTTP_LINE_ENDING;
    }
    preAddSubRequest(subRequest) {
      if (this.operationCount >= BATCH_MAX_REQUEST) {
        throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);
      }
      const path = getURLPath(subRequest.url);
      if (!path || path === "") {
        throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);
      }
    }
    postAddSubRequest(subRequest) {
      this.subRequests.set(this.operationCount, subRequest);
      this.operationCount++;
    }
    getHttpRequestBody() {
      return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;
    }
    getMultipartContentType() {
      return this.multipartContentType;
    }
    getSubRequests() {
      return this.subRequests;
    }
  }
  function batchRequestAssemblePolicy(batchRequest) {
    return {
      name: "batchRequestAssemblePolicy",
      async sendRequest(request) {
        batchRequest.appendSubRequestToBody(request);
        return {
          request,
          status: 200,
          headers: coreRestPipeline.createHttpHeaders()
        };
      }
    };
  }
  function batchHeaderFilterPolicy() {
    return {
      name: "batchHeaderFilterPolicy",
      async sendRequest(request, next) {
        let xMsHeaderName = "";
        for (const [name] of request.headers) {
          if (iEqual(name, HeaderConstants.X_MS_VERSION)) {
            xMsHeaderName = name;
          }
        }
        if (xMsHeaderName !== "") {
          request.headers.delete(xMsHeaderName);
        }
        return next(request);
      }
    };
  }

  class BlobBatchClient {
    constructor(url2, credentialOrPipeline, options) {
      let pipeline;
      if (isPipelineLike(credentialOrPipeline)) {
        pipeline = credentialOrPipeline;
      } else if (!credentialOrPipeline) {
        pipeline = newPipeline(new AnonymousCredential, options);
      } else {
        pipeline = newPipeline(credentialOrPipeline, options);
      }
      const storageClientContext = new StorageContextClient(url2, getCoreClientOptions(pipeline));
      const path = getURLPath(url2);
      if (path && path !== "/") {
        this.serviceOrContainerContext = storageClientContext.container;
      } else {
        this.serviceOrContainerContext = storageClientContext.service;
      }
    }
    createBatch() {
      return new BlobBatch;
    }
    async deleteBlobs(urlsOrBlobClients, credentialOrOptions, options) {
      const batch = new BlobBatch;
      for (const urlOrBlobClient of urlsOrBlobClients) {
        if (typeof urlOrBlobClient === "string") {
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options);
        } else {
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions);
        }
      }
      return this.submitBatch(batch);
    }
    async setBlobsAccessTier(urlsOrBlobClients, credentialOrTier, tierOrOptions, options) {
      const batch = new BlobBatch;
      for (const urlOrBlobClient of urlsOrBlobClients) {
        if (typeof urlOrBlobClient === "string") {
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options);
        } else {
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions);
        }
      }
      return this.submitBatch(batch);
    }
    async submitBatch(batchRequest, options = {}) {
      if (!batchRequest || batchRequest.getSubRequests().size === 0) {
        throw new RangeError("Batch request should contain one or more sub requests.");
      }
      return tracingClient.withSpan("BlobBatchClient-submitBatch", options, async (updatedOptions) => {
        const batchRequestBody = batchRequest.getHttpRequestBody();
        const rawBatchResponse = assertResponse(await this.serviceOrContainerContext.submitBatch(utf8ByteLength(batchRequestBody), batchRequest.getMultiPartContentType(), batchRequestBody, Object.assign({}, updatedOptions)));
        const batchResponseParser = new BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests());
        const responseSummary = await batchResponseParser.parseBatchResponse();
        const res = {
          _response: rawBatchResponse._response,
          contentType: rawBatchResponse.contentType,
          errorCode: rawBatchResponse.errorCode,
          requestId: rawBatchResponse.requestId,
          clientRequestId: rawBatchResponse.clientRequestId,
          version: rawBatchResponse.version,
          subResponses: responseSummary.subResponses,
          subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
          subResponsesFailedCount: responseSummary.subResponsesFailedCount
        };
        return res;
      });
    }
  }

  class ContainerClient extends StorageClient {
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, options) {
      let pipeline;
      let url2;
      options = options || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        pipeline = newPipeline(new AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName));
            if (!options.proxyOptions) {
              options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline = newPipeline(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas;
          pipeline = newPipeline(new AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName parameter");
      }
      super(url2, pipeline);
      this._containerName = this.getContainerNameFromUrl();
      this.containerContext = this.storageClientContext.container;
    }
    async create(options = {}) {
      return tracingClient.withSpan("ContainerClient-create", options, async (updatedOptions) => {
        return assertResponse(await this.containerContext.create(updatedOptions));
      });
    }
    async createIfNotExists(options = {}) {
      return tracingClient.withSpan("ContainerClient-createIfNotExists", options, async (updatedOptions) => {
        var _a, _b;
        try {
          const res = await this.create(updatedOptions);
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e) {
          if (((_a = e.details) === null || _a === undefined ? undefined : _a.errorCode) === "ContainerAlreadyExists") {
            return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === undefined ? undefined : _b.parsedHeaders), { _response: e.response });
          } else {
            throw e;
          }
        }
      });
    }
    async exists(options = {}) {
      return tracingClient.withSpan("ContainerClient-exists", options, async (updatedOptions) => {
        try {
          await this.getProperties({
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          });
          return true;
        } catch (e) {
          if (e.statusCode === 404) {
            return false;
          }
          throw e;
        }
      });
    }
    getBlobClient(blobName) {
      return new BlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    getAppendBlobClient(blobName) {
      return new AppendBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    getBlockBlobClient(blobName) {
      return new BlockBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    getPageBlobClient(blobName) {
      return new PageBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    async getProperties(options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("ContainerClient-getProperties", options, async (updatedOptions) => {
        return assertResponse(await this.containerContext.getProperties(Object.assign(Object.assign({ abortSignal: options.abortSignal }, options.conditions), { tracingOptions: updatedOptions.tracingOptions })));
      });
    }
    async delete(options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("ContainerClient-delete", options, async (updatedOptions) => {
        return assertResponse(await this.containerContext.delete({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async deleteIfExists(options = {}) {
      return tracingClient.withSpan("ContainerClient-deleteIfExists", options, async (updatedOptions) => {
        var _a, _b;
        try {
          const res = await this.delete(updatedOptions);
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e) {
          if (((_a = e.details) === null || _a === undefined ? undefined : _a.errorCode) === "ContainerNotFound") {
            return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === undefined ? undefined : _b.parsedHeaders), { _response: e.response });
          }
          throw e;
        }
      });
    }
    async setMetadata(metadata2, options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      if (options.conditions.ifUnmodifiedSince) {
        throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
      }
      return tracingClient.withSpan("ContainerClient-setMetadata", options, async (updatedOptions) => {
        return assertResponse(await this.containerContext.setMetadata({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: metadata2,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccessPolicy(options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("ContainerClient-getAccessPolicy", options, async (updatedOptions) => {
        const response = assertResponse(await this.containerContext.getAccessPolicy({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const res = {
          _response: response._response,
          blobPublicAccess: response.blobPublicAccess,
          date: response.date,
          etag: response.etag,
          errorCode: response.errorCode,
          lastModified: response.lastModified,
          requestId: response.requestId,
          clientRequestId: response.clientRequestId,
          signedIdentifiers: [],
          version: response.version
        };
        for (const identifier of response) {
          let accessPolicy = undefined;
          if (identifier.accessPolicy) {
            accessPolicy = {
              permissions: identifier.accessPolicy.permissions
            };
            if (identifier.accessPolicy.expiresOn) {
              accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
            }
            if (identifier.accessPolicy.startsOn) {
              accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
            }
          }
          res.signedIdentifiers.push({
            accessPolicy,
            id: identifier.id
          });
        }
        return res;
      });
    }
    async setAccessPolicy(access2, containerAcl2, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("ContainerClient-setAccessPolicy", options, async (updatedOptions) => {
        const acl = [];
        for (const identifier of containerAcl2 || []) {
          acl.push({
            accessPolicy: {
              expiresOn: identifier.accessPolicy.expiresOn ? truncatedISO8061Date(identifier.accessPolicy.expiresOn) : "",
              permissions: identifier.accessPolicy.permissions,
              startsOn: identifier.accessPolicy.startsOn ? truncatedISO8061Date(identifier.accessPolicy.startsOn) : ""
            },
            id: identifier.id
          });
        }
        return assertResponse(await this.containerContext.setAccessPolicy({
          abortSignal: options.abortSignal,
          access: access2,
          containerAcl: acl,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient(this, proposeLeaseId);
    }
    async uploadBlockBlob(blobName, body2, contentLength2, options = {}) {
      return tracingClient.withSpan("ContainerClient-uploadBlockBlob", options, async (updatedOptions) => {
        const blockBlobClient = this.getBlockBlobClient(blobName);
        const response = await blockBlobClient.upload(body2, contentLength2, updatedOptions);
        return {
          blockBlobClient,
          response
        };
      });
    }
    async deleteBlob(blobName, options = {}) {
      return tracingClient.withSpan("ContainerClient-deleteBlob", options, async (updatedOptions) => {
        let blobClient = this.getBlobClient(blobName);
        if (options.versionId) {
          blobClient = blobClient.withVersion(options.versionId);
        }
        return blobClient.delete(updatedOptions);
      });
    }
    async listBlobFlatSegment(marker2, options = {}) {
      return tracingClient.withSpan("ContainerClient-listBlobFlatSegment", options, async (updatedOptions) => {
        const response = assertResponse(await this.containerContext.listBlobFlatSegment(Object.assign(Object.assign({ marker: marker2 }, options), { tracingOptions: updatedOptions.tracingOptions })));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: Object.assign(Object.assign({}, response._response), { parsedBody: ConvertInternalResponseOfListBlobFlat(response._response.parsedBody) }), segment: Object.assign(Object.assign({}, response.segment), { blobItems: response.segment.blobItems.map((blobItemInternal) => {
          const blobItem = Object.assign(Object.assign({}, blobItemInternal), { name: BlobNameToString(blobItemInternal.name), tags: toTags(blobItemInternal.blobTags), objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInternal.objectReplicationMetadata) });
          return blobItem;
        }) }) });
        return wrappedResponse;
      });
    }
    async listBlobHierarchySegment(delimiter2, marker2, options = {}) {
      return tracingClient.withSpan("ContainerClient-listBlobHierarchySegment", options, async (updatedOptions) => {
        var _a;
        const response = assertResponse(await this.containerContext.listBlobHierarchySegment(delimiter2, Object.assign(Object.assign({ marker: marker2 }, options), { tracingOptions: updatedOptions.tracingOptions })));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: Object.assign(Object.assign({}, response._response), { parsedBody: ConvertInternalResponseOfListBlobHierarchy(response._response.parsedBody) }), segment: Object.assign(Object.assign({}, response.segment), { blobItems: response.segment.blobItems.map((blobItemInternal) => {
          const blobItem = Object.assign(Object.assign({}, blobItemInternal), { name: BlobNameToString(blobItemInternal.name), tags: toTags(blobItemInternal.blobTags), objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInternal.objectReplicationMetadata) });
          return blobItem;
        }), blobPrefixes: (_a = response.segment.blobPrefixes) === null || _a === undefined ? undefined : _a.map((blobPrefixInternal) => {
          const blobPrefix = Object.assign(Object.assign({}, blobPrefixInternal), { name: BlobNameToString(blobPrefixInternal.name) });
          return blobPrefix;
        }) }) });
        return wrappedResponse;
      });
    }
    listSegments(marker_1) {
      return tslib.__asyncGenerator(this, arguments, function* listSegments_1(marker2, options = {}) {
        let listBlobsFlatSegmentResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            listBlobsFlatSegmentResponse = yield tslib.__await(this.listBlobFlatSegment(marker2, options));
            marker2 = listBlobsFlatSegmentResponse.continuationToken;
            yield yield tslib.__await(yield tslib.__await(listBlobsFlatSegmentResponse));
          } while (marker2);
        }
      });
    }
    listItems() {
      return tslib.__asyncGenerator(this, arguments, function* listItems_1(options = {}) {
        var _a, e_1, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.listSegments(marker2, options)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const listBlobsFlatSegmentResponse = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(listBlobsFlatSegmentResponse.segment.blobItems)));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    listBlobsFlat(options = {}) {
      const include2 = [];
      if (options.includeCopy) {
        include2.push("copy");
      }
      if (options.includeDeleted) {
        include2.push("deleted");
      }
      if (options.includeMetadata) {
        include2.push("metadata");
      }
      if (options.includeSnapshots) {
        include2.push("snapshots");
      }
      if (options.includeVersions) {
        include2.push("versions");
      }
      if (options.includeUncommitedBlobs) {
        include2.push("uncommittedblobs");
      }
      if (options.includeTags) {
        include2.push("tags");
      }
      if (options.includeDeletedWithVersions) {
        include2.push("deletedwithversions");
      }
      if (options.includeImmutabilityPolicy) {
        include2.push("immutabilitypolicy");
      }
      if (options.includeLegalHold) {
        include2.push("legalhold");
      }
      if (options.prefix === "") {
        options.prefix = undefined;
      }
      const updatedOptions = Object.assign(Object.assign({}, options), include2.length > 0 ? { include: include2 } : {});
      const iter = this.listItems(updatedOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, updatedOptions));
        }
      };
    }
    listHierarchySegments(delimiter_1, marker_1) {
      return tslib.__asyncGenerator(this, arguments, function* listHierarchySegments_1(delimiter2, marker2, options = {}) {
        let listBlobsHierarchySegmentResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            listBlobsHierarchySegmentResponse = yield tslib.__await(this.listBlobHierarchySegment(delimiter2, marker2, options));
            marker2 = listBlobsHierarchySegmentResponse.continuationToken;
            yield yield tslib.__await(yield tslib.__await(listBlobsHierarchySegmentResponse));
          } while (marker2);
        }
      });
    }
    listItemsByHierarchy(delimiter_1) {
      return tslib.__asyncGenerator(this, arguments, function* listItemsByHierarchy_1(delimiter2, options = {}) {
        var _a, e_2, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.listHierarchySegments(delimiter2, marker2, options)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const listBlobsHierarchySegmentResponse = _c;
            const segment = listBlobsHierarchySegmentResponse.segment;
            if (segment.blobPrefixes) {
              for (const prefix2 of segment.blobPrefixes) {
                yield yield tslib.__await(Object.assign({ kind: "prefix" }, prefix2));
              }
            }
            for (const blob of segment.blobItems) {
              yield yield tslib.__await(Object.assign({ kind: "blob" }, blob));
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    listBlobsByHierarchy(delimiter2, options = {}) {
      if (delimiter2 === "") {
        throw new RangeError("delimiter should contain one or more characters");
      }
      const include2 = [];
      if (options.includeCopy) {
        include2.push("copy");
      }
      if (options.includeDeleted) {
        include2.push("deleted");
      }
      if (options.includeMetadata) {
        include2.push("metadata");
      }
      if (options.includeSnapshots) {
        include2.push("snapshots");
      }
      if (options.includeVersions) {
        include2.push("versions");
      }
      if (options.includeUncommitedBlobs) {
        include2.push("uncommittedblobs");
      }
      if (options.includeTags) {
        include2.push("tags");
      }
      if (options.includeDeletedWithVersions) {
        include2.push("deletedwithversions");
      }
      if (options.includeImmutabilityPolicy) {
        include2.push("immutabilitypolicy");
      }
      if (options.includeLegalHold) {
        include2.push("legalhold");
      }
      if (options.prefix === "") {
        options.prefix = undefined;
      }
      const updatedOptions = Object.assign(Object.assign({}, options), include2.length > 0 ? { include: include2 } : {});
      const iter = this.listItemsByHierarchy(delimiter2, updatedOptions);
      return {
        async next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listHierarchySegments(delimiter2, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, updatedOptions));
        }
      };
    }
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options = {}) {
      return tracingClient.withSpan("ContainerClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
        const response = assertResponse(await this.containerContext.filterBlobs({
          abortSignal: options.abortSignal,
          where: tagFilterSqlExpression,
          marker: marker2,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, blobs: response.blobs.map((blob) => {
          var _a;
          let tagValue = "";
          if (((_a = blob.tags) === null || _a === undefined ? undefined : _a.blobTagSet.length) === 1) {
            tagValue = blob.tags.blobTagSet[0].value;
          }
          return Object.assign(Object.assign({}, blob), { tags: toTags(blob.tags), tagValue });
        }) });
        return wrappedResponse;
      });
    }
    findBlobsByTagsSegments(tagFilterSqlExpression_1, marker_1) {
      return tslib.__asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1(tagFilterSqlExpression, marker2, options = {}) {
        let response;
        if (!!marker2 || marker2 === undefined) {
          do {
            response = yield tslib.__await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options));
            response.blobs = response.blobs || [];
            marker2 = response.continuationToken;
            yield yield tslib.__await(response);
          } while (marker2);
        }
      });
    }
    findBlobsByTagsItems(tagFilterSqlExpression_1) {
      return tslib.__asyncGenerator(this, arguments, function* findBlobsByTagsItems_1(tagFilterSqlExpression, options = {}) {
        var _a, e_3, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker2, options)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const segment = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment.blobs)));
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      });
    }
    findBlobsByTags(tagFilterSqlExpression, options = {}) {
      const listSegmentOptions = Object.assign({}, options);
      const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));
        }
      };
    }
    async getAccountInfo(options = {}) {
      return tracingClient.withSpan("ContainerClient-getAccountInfo", options, async (updatedOptions) => {
        return assertResponse(await this.containerContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getContainerNameFromUrl() {
      let containerName;
      try {
        const parsedUrl = new URL(this.url);
        if (parsedUrl.hostname.split(".")[1] === "blob") {
          containerName = parsedUrl.pathname.split("/")[1];
        } else if (isIpEndpointStyle(parsedUrl)) {
          containerName = parsedUrl.pathname.split("/")[2];
        } else {
          containerName = parsedUrl.pathname.split("/")[1];
        }
        containerName = decodeURIComponent(containerName);
        if (!containerName) {
          throw new Error("Provided containerName is invalid.");
        }
        return containerName;
      } catch (error) {
        throw new Error("Unable to extract containerName with provided information.");
      }
    }
    generateSasUrl(options) {
      return new Promise((resolve) => {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName }, options), this.credential).toString();
        resolve(appendToURLQuery(this.url, sas));
      });
    }
    generateSasStringToSign(options) {
      if (!(this.credential instanceof StorageSharedKeyCredential)) {
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      }
      return generateBlobSASQueryParametersInternal(Object.assign({ containerName: this._containerName }, options), this.credential).stringToSign;
    }
    generateUserDelegationSasUrl(options, userDelegationKey) {
      return new Promise((resolve) => {
        const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName }, options), userDelegationKey, this.accountName).toString();
        resolve(appendToURLQuery(this.url, sas));
      });
    }
    generateUserDelegationSasStringToSign(options, userDelegationKey) {
      return generateBlobSASQueryParametersInternal(Object.assign({ containerName: this._containerName }, options), userDelegationKey, this.accountName).stringToSign;
    }
    getBlobBatchClient() {
      return new BlobBatchClient(this.url, this.pipeline);
    }
  }

  class AccountSASPermissions {
    constructor() {
      this.read = false;
      this.write = false;
      this.delete = false;
      this.deleteVersion = false;
      this.list = false;
      this.add = false;
      this.create = false;
      this.update = false;
      this.process = false;
      this.tag = false;
      this.filter = false;
      this.setImmutabilityPolicy = false;
      this.permanentDelete = false;
    }
    static parse(permissions) {
      const accountSASPermissions = new AccountSASPermissions;
      for (const c of permissions) {
        switch (c) {
          case "r":
            accountSASPermissions.read = true;
            break;
          case "w":
            accountSASPermissions.write = true;
            break;
          case "d":
            accountSASPermissions.delete = true;
            break;
          case "x":
            accountSASPermissions.deleteVersion = true;
            break;
          case "l":
            accountSASPermissions.list = true;
            break;
          case "a":
            accountSASPermissions.add = true;
            break;
          case "c":
            accountSASPermissions.create = true;
            break;
          case "u":
            accountSASPermissions.update = true;
            break;
          case "p":
            accountSASPermissions.process = true;
            break;
          case "t":
            accountSASPermissions.tag = true;
            break;
          case "f":
            accountSASPermissions.filter = true;
            break;
          case "i":
            accountSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            accountSASPermissions.permanentDelete = true;
            break;
          default:
            throw new RangeError(`Invalid permission character: ${c}`);
        }
      }
      return accountSASPermissions;
    }
    static from(permissionLike) {
      const accountSASPermissions = new AccountSASPermissions;
      if (permissionLike.read) {
        accountSASPermissions.read = true;
      }
      if (permissionLike.write) {
        accountSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        accountSASPermissions.delete = true;
      }
      if (permissionLike.deleteVersion) {
        accountSASPermissions.deleteVersion = true;
      }
      if (permissionLike.filter) {
        accountSASPermissions.filter = true;
      }
      if (permissionLike.tag) {
        accountSASPermissions.tag = true;
      }
      if (permissionLike.list) {
        accountSASPermissions.list = true;
      }
      if (permissionLike.add) {
        accountSASPermissions.add = true;
      }
      if (permissionLike.create) {
        accountSASPermissions.create = true;
      }
      if (permissionLike.update) {
        accountSASPermissions.update = true;
      }
      if (permissionLike.process) {
        accountSASPermissions.process = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        accountSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        accountSASPermissions.permanentDelete = true;
      }
      return accountSASPermissions;
    }
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.filter) {
        permissions.push("f");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.list) {
        permissions.push("l");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.update) {
        permissions.push("u");
      }
      if (this.process) {
        permissions.push("p");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      return permissions.join("");
    }
  }

  class AccountSASResourceTypes {
    constructor() {
      this.service = false;
      this.container = false;
      this.object = false;
    }
    static parse(resourceTypes) {
      const accountSASResourceTypes = new AccountSASResourceTypes;
      for (const c of resourceTypes) {
        switch (c) {
          case "s":
            accountSASResourceTypes.service = true;
            break;
          case "c":
            accountSASResourceTypes.container = true;
            break;
          case "o":
            accountSASResourceTypes.object = true;
            break;
          default:
            throw new RangeError(`Invalid resource type: ${c}`);
        }
      }
      return accountSASResourceTypes;
    }
    toString() {
      const resourceTypes = [];
      if (this.service) {
        resourceTypes.push("s");
      }
      if (this.container) {
        resourceTypes.push("c");
      }
      if (this.object) {
        resourceTypes.push("o");
      }
      return resourceTypes.join("");
    }
  }

  class AccountSASServices {
    constructor() {
      this.blob = false;
      this.file = false;
      this.queue = false;
      this.table = false;
    }
    static parse(services) {
      const accountSASServices = new AccountSASServices;
      for (const c of services) {
        switch (c) {
          case "b":
            accountSASServices.blob = true;
            break;
          case "f":
            accountSASServices.file = true;
            break;
          case "q":
            accountSASServices.queue = true;
            break;
          case "t":
            accountSASServices.table = true;
            break;
          default:
            throw new RangeError(`Invalid service character: ${c}`);
        }
      }
      return accountSASServices;
    }
    toString() {
      const services = [];
      if (this.blob) {
        services.push("b");
      }
      if (this.table) {
        services.push("t");
      }
      if (this.queue) {
        services.push("q");
      }
      if (this.file) {
        services.push("f");
      }
      return services.join("");
    }
  }
  function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    return generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential).sasQueryParameters;
  }
  function generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential) {
    const version2 = accountSASSignatureValues.version ? accountSASSignatureValues.version : SERVICE_VERSION;
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.setImmutabilityPolicy && version2 < "2020-08-04") {
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.permanentDelete && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
    }
    if (accountSASSignatureValues.encryptionScope && version2 < "2020-12-06") {
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    const parsedPermissions = AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString());
    const parsedServices = AccountSASServices.parse(accountSASSignatureValues.services).toString();
    const parsedResourceTypes = AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
    let stringToSign;
    if (version2 >= "2020-12-06") {
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false) : "",
        truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version2,
        accountSASSignatureValues.encryptionScope ? accountSASSignatureValues.encryptionScope : "",
        ""
      ].join(`
`);
    } else {
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false) : "",
        truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version2,
        ""
      ].join(`
`);
    }
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(version2, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, accountSASSignatureValues.encryptionScope),
      stringToSign
    };
  }

  class BlobServiceClient extends StorageClient {
    static fromConnectionString(connectionString, options) {
      options = options || {};
      const extractedCreds = extractConnectionStringParts(connectionString);
      if (extractedCreds.kind === "AccountConnString") {
        if (coreUtil.isNode) {
          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          if (!options.proxyOptions) {
            options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
          }
          const pipeline = newPipeline(sharedKeyCredential, options);
          return new BlobServiceClient(extractedCreds.url, pipeline);
        } else {
          throw new Error("Account connection string is only supported in Node.js environment");
        }
      } else if (extractedCreds.kind === "SASConnString") {
        const pipeline = newPipeline(new AnonymousCredential, options);
        return new BlobServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
      } else {
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
      }
    }
    constructor(url2, credentialOrPipeline, options) {
      let pipeline;
      if (isPipelineLike(credentialOrPipeline)) {
        pipeline = credentialOrPipeline;
      } else if (coreUtil.isNode && credentialOrPipeline instanceof StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipeline)) {
        pipeline = newPipeline(credentialOrPipeline, options);
      } else {
        pipeline = newPipeline(new AnonymousCredential, options);
      }
      super(url2, pipeline);
      this.serviceContext = this.storageClientContext.service;
    }
    getContainerClient(containerName) {
      return new ContainerClient(appendToURLPath(this.url, encodeURIComponent(containerName)), this.pipeline);
    }
    async createContainer(containerName, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-createContainer", options, async (updatedOptions) => {
        const containerClient = this.getContainerClient(containerName);
        const containerCreateResponse = await containerClient.create(updatedOptions);
        return {
          containerClient,
          containerCreateResponse
        };
      });
    }
    async deleteContainer(containerName, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-deleteContainer", options, async (updatedOptions) => {
        const containerClient = this.getContainerClient(containerName);
        return containerClient.delete(updatedOptions);
      });
    }
    async undeleteContainer(deletedContainerName2, deletedContainerVersion2, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-undeleteContainer", options, async (updatedOptions) => {
        const containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName2);
        const containerContext = containerClient["storageClientContext"].container;
        const containerUndeleteResponse = assertResponse(await containerContext.restore({
          deletedContainerName: deletedContainerName2,
          deletedContainerVersion: deletedContainerVersion2,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return { containerClient, containerUndeleteResponse };
      });
    }
    async renameContainer(sourceContainerName2, destinationContainerName, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-renameContainer", options, async (updatedOptions) => {
        var _a;
        const containerClient = this.getContainerClient(destinationContainerName);
        const containerContext = containerClient["storageClientContext"].container;
        const containerRenameResponse = assertResponse(await containerContext.rename(sourceContainerName2, Object.assign(Object.assign({}, updatedOptions), { sourceLeaseId: (_a = options.sourceCondition) === null || _a === undefined ? undefined : _a.leaseId })));
        return { containerClient, containerRenameResponse };
      });
    }
    async getProperties(options = {}) {
      return tracingClient.withSpan("BlobServiceClient-getProperties", options, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.getProperties({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setProperties(properties, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-setProperties", options, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.setProperties(properties, {
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getStatistics(options = {}) {
      return tracingClient.withSpan("BlobServiceClient-getStatistics", options, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.getStatistics({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccountInfo(options = {}) {
      return tracingClient.withSpan("BlobServiceClient-getAccountInfo", options, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async listContainersSegment(marker2, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-listContainersSegment", options, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.listContainersSegment(Object.assign(Object.assign({ abortSignal: options.abortSignal, marker: marker2 }, options), { include: typeof options.include === "string" ? [options.include] : options.include, tracingOptions: updatedOptions.tracingOptions })));
      });
    }
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
        const response = assertResponse(await this.serviceContext.filterBlobs({
          abortSignal: options.abortSignal,
          where: tagFilterSqlExpression,
          marker: marker2,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, blobs: response.blobs.map((blob) => {
          var _a;
          let tagValue = "";
          if (((_a = blob.tags) === null || _a === undefined ? undefined : _a.blobTagSet.length) === 1) {
            tagValue = blob.tags.blobTagSet[0].value;
          }
          return Object.assign(Object.assign({}, blob), { tags: toTags(blob.tags), tagValue });
        }) });
        return wrappedResponse;
      });
    }
    findBlobsByTagsSegments(tagFilterSqlExpression_1, marker_1) {
      return tslib.__asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1(tagFilterSqlExpression, marker2, options = {}) {
        let response;
        if (!!marker2 || marker2 === undefined) {
          do {
            response = yield tslib.__await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options));
            response.blobs = response.blobs || [];
            marker2 = response.continuationToken;
            yield yield tslib.__await(response);
          } while (marker2);
        }
      });
    }
    findBlobsByTagsItems(tagFilterSqlExpression_1) {
      return tslib.__asyncGenerator(this, arguments, function* findBlobsByTagsItems_1(tagFilterSqlExpression, options = {}) {
        var _a, e_1, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker2, options)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const segment = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment.blobs)));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    findBlobsByTags(tagFilterSqlExpression, options = {}) {
      const listSegmentOptions = Object.assign({}, options);
      const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));
        }
      };
    }
    listSegments(marker_1) {
      return tslib.__asyncGenerator(this, arguments, function* listSegments_1(marker2, options = {}) {
        let listContainersSegmentResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            listContainersSegmentResponse = yield tslib.__await(this.listContainersSegment(marker2, options));
            listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];
            marker2 = listContainersSegmentResponse.continuationToken;
            yield yield tslib.__await(yield tslib.__await(listContainersSegmentResponse));
          } while (marker2);
        }
      });
    }
    listItems() {
      return tslib.__asyncGenerator(this, arguments, function* listItems_1(options = {}) {
        var _a, e_2, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.listSegments(marker2, options)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const segment = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment.containerItems)));
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    listContainers(options = {}) {
      if (options.prefix === "") {
        options.prefix = undefined;
      }
      const include2 = [];
      if (options.includeDeleted) {
        include2.push("deleted");
      }
      if (options.includeMetadata) {
        include2.push("metadata");
      }
      if (options.includeSystem) {
        include2.push("system");
      }
      const listSegmentOptions = Object.assign(Object.assign({}, options), include2.length > 0 ? { include: include2 } : {});
      const iter = this.listItems(listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));
        }
      };
    }
    async getUserDelegationKey(startsOn, expiresOn2, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-getUserDelegationKey", options, async (updatedOptions) => {
        const response = assertResponse(await this.serviceContext.getUserDelegationKey({
          startsOn: truncatedISO8061Date(startsOn, false),
          expiresOn: truncatedISO8061Date(expiresOn2, false)
        }, {
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const userDelegationKey = {
          signedObjectId: response.signedObjectId,
          signedTenantId: response.signedTenantId,
          signedStartsOn: new Date(response.signedStartsOn),
          signedExpiresOn: new Date(response.signedExpiresOn),
          signedService: response.signedService,
          signedVersion: response.signedVersion,
          value: response.value
        };
        const res = Object.assign({ _response: response._response, requestId: response.requestId, clientRequestId: response.clientRequestId, version: response.version, date: response.date, errorCode: response.errorCode }, userDelegationKey);
        return res;
      });
    }
    getBlobBatchClient() {
      return new BlobBatchClient(this.url, this.pipeline);
    }
    generateAccountSasUrl(expiresOn2, permissions = AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
      if (!(this.credential instanceof StorageSharedKeyCredential)) {
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      }
      if (expiresOn2 === undefined) {
        const now = new Date;
        expiresOn2 = new Date(now.getTime() + 3600 * 1000);
      }
      const sas = generateAccountSASQueryParameters(Object.assign({
        permissions,
        expiresOn: expiresOn2,
        resourceTypes,
        services: AccountSASServices.parse("b").toString()
      }, options), this.credential).toString();
      return appendToURLQuery(this.url, sas);
    }
    generateSasStringToSign(expiresOn2, permissions = AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
      if (!(this.credential instanceof StorageSharedKeyCredential)) {
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      }
      if (expiresOn2 === undefined) {
        const now = new Date;
        expiresOn2 = new Date(now.getTime() + 3600 * 1000);
      }
      return generateAccountSASQueryParametersInternal(Object.assign({
        permissions,
        expiresOn: expiresOn2,
        resourceTypes,
        services: AccountSASServices.parse("b").toString()
      }, options), this.credential).stringToSign;
    }
  }
  exports.KnownEncryptionAlgorithmType = undefined;
  (function(KnownEncryptionAlgorithmType) {
    KnownEncryptionAlgorithmType["AES256"] = "AES256";
  })(exports.KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = {}));
  Object.defineProperty(exports, "RestError", {
    enumerable: true,
    get: function() {
      return coreRestPipeline.RestError;
    }
  });
  exports.AccountSASPermissions = AccountSASPermissions;
  exports.AccountSASResourceTypes = AccountSASResourceTypes;
  exports.AccountSASServices = AccountSASServices;
  exports.AnonymousCredential = AnonymousCredential;
  exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
  exports.AppendBlobClient = AppendBlobClient;
  exports.BaseRequestPolicy = BaseRequestPolicy;
  exports.BlobBatch = BlobBatch;
  exports.BlobBatchClient = BlobBatchClient;
  exports.BlobClient = BlobClient;
  exports.BlobLeaseClient = BlobLeaseClient;
  exports.BlobSASPermissions = BlobSASPermissions;
  exports.BlobServiceClient = BlobServiceClient;
  exports.BlockBlobClient = BlockBlobClient;
  exports.ContainerClient = ContainerClient;
  exports.ContainerSASPermissions = ContainerSASPermissions;
  exports.Credential = Credential;
  exports.CredentialPolicy = CredentialPolicy;
  exports.PageBlobClient = PageBlobClient;
  exports.Pipeline = Pipeline;
  exports.SASQueryParameters = SASQueryParameters;
  exports.StorageBrowserPolicy = StorageBrowserPolicy;
  exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
  exports.StorageOAuthScopes = StorageOAuthScopes;
  exports.StorageRetryPolicy = StorageRetryPolicy;
  exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
  exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
  exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
  exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
  exports.generateBlobSASQueryParameters = generateBlobSASQueryParameters;
  exports.getBlobServiceAccountAudience = getBlobServiceAccountAudience;
  exports.isPipelineLike = isPipelineLike;
  exports.logger = logger;
  exports.newPipeline = newPipeline;
});

// node_modules/@actions/cache/lib/internal/shared/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UsageError = exports.NetworkError = exports.GHESNotSupportedError = exports.CacheNotFoundError = exports.InvalidResponseError = exports.FilesNotFoundError = undefined;

  class FilesNotFoundError extends Error {
    constructor(files = []) {
      let message = "No files were found to upload";
      if (files.length > 0) {
        message += `: ${files.join(", ")}`;
      }
      super(message);
      this.files = files;
      this.name = "FilesNotFoundError";
    }
  }
  exports.FilesNotFoundError = FilesNotFoundError;

  class InvalidResponseError extends Error {
    constructor(message) {
      super(message);
      this.name = "InvalidResponseError";
    }
  }
  exports.InvalidResponseError = InvalidResponseError;

  class CacheNotFoundError extends Error {
    constructor(message = "Cache not found") {
      super(message);
      this.name = "CacheNotFoundError";
    }
  }
  exports.CacheNotFoundError = CacheNotFoundError;

  class GHESNotSupportedError extends Error {
    constructor(message = "@actions/cache v4.1.4+, actions/cache/save@v4+ and actions/cache/restore@v4+ are not currently supported on GHES.") {
      super(message);
      this.name = "GHESNotSupportedError";
    }
  }
  exports.GHESNotSupportedError = GHESNotSupportedError;

  class NetworkError extends Error {
    constructor(code) {
      const message = `Unable to make request: ${code}
If you are using self-hosted runners, please make sure your runner has access to all GitHub endpoints: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github`;
      super(message);
      this.code = code;
      this.name = "NetworkError";
    }
  }
  exports.NetworkError = NetworkError;
  NetworkError.isNetworkErrorCode = (code) => {
    if (!code)
      return false;
    return [
      "ECONNRESET",
      "ENOTFOUND",
      "ETIMEDOUT",
      "ECONNREFUSED",
      "EHOSTUNREACH"
    ].includes(code);
  };

  class UsageError extends Error {
    constructor() {
      const message = `Cache storage quota has been hit. Unable to upload any new cache entries. Usage is recalculated every 6-12 hours.
More info on storage limits: https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#calculating-minute-and-storage-spending`;
      super(message);
      this.name = "UsageError";
    }
  }
  exports.UsageError = UsageError;
  UsageError.isUsageErrorMessage = (msg) => {
    if (!msg)
      return false;
    return msg.includes("insufficient usage");
  };
});

// node_modules/@actions/cache/lib/internal/uploadUtils.js
var require_uploadUtils = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uploadCacheArchiveSDK = exports.UploadProgress = undefined;
  var core = __importStar(require_core());
  var storage_blob_1 = require_dist4();
  var errors_1 = require_errors();

  class UploadProgress {
    constructor(contentLength) {
      this.contentLength = contentLength;
      this.sentBytes = 0;
      this.displayedComplete = false;
      this.startTime = Date.now();
    }
    setSentBytes(sentBytes) {
      this.sentBytes = sentBytes;
    }
    getTransferredBytes() {
      return this.sentBytes;
    }
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    display() {
      if (this.displayedComplete) {
        return;
      }
      const transferredBytes = this.sentBytes;
      const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1);
      const elapsedTime = Date.now() - this.startTime;
      const uploadSpeed = (transferredBytes / (1024 * 1024) / (elapsedTime / 1000)).toFixed(1);
      core.info(`Sent ${transferredBytes} of ${this.contentLength} (${percentage}%), ${uploadSpeed} MBs/sec`);
      if (this.isDone()) {
        this.displayedComplete = true;
      }
    }
    onProgress() {
      return (progress) => {
        this.setSentBytes(progress.loadedBytes);
      };
    }
    startDisplayTimer(delayInMs = 1000) {
      const displayCallback = () => {
        this.display();
        if (!this.isDone()) {
          this.timeoutHandle = setTimeout(displayCallback, delayInMs);
        }
      };
      this.timeoutHandle = setTimeout(displayCallback, delayInMs);
    }
    stopDisplayTimer() {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = undefined;
      }
      this.display();
    }
  }
  exports.UploadProgress = UploadProgress;
  function uploadCacheArchiveSDK(signedUploadURL, archivePath, options) {
    var _a;
    return __awaiter(this, undefined, undefined, function* () {
      const blobClient = new storage_blob_1.BlobClient(signedUploadURL);
      const blockBlobClient = blobClient.getBlockBlobClient();
      const uploadProgress = new UploadProgress((_a = options === null || options === undefined ? undefined : options.archiveSizeBytes) !== null && _a !== undefined ? _a : 0);
      const uploadOptions = {
        blockSize: options === null || options === undefined ? undefined : options.uploadChunkSize,
        concurrency: options === null || options === undefined ? undefined : options.uploadConcurrency,
        maxSingleShotSize: 128 * 1024 * 1024,
        onProgress: uploadProgress.onProgress()
      };
      try {
        uploadProgress.startDisplayTimer();
        core.debug(`BlobClient: ${blobClient.name}:${blobClient.accountName}:${blobClient.containerName}`);
        const response = yield blockBlobClient.uploadFile(archivePath, uploadOptions);
        if (response._response.status >= 400) {
          throw new errors_1.InvalidResponseError(`uploadCacheArchiveSDK: upload failed with status code ${response._response.status}`);
        }
        return response;
      } catch (error) {
        core.warning(`uploadCacheArchiveSDK: internal error uploading cache archive: ${error.message}`);
        throw error;
      } finally {
        uploadProgress.stopDisplayTimer();
      }
    });
  }
  exports.uploadCacheArchiveSDK = uploadCacheArchiveSDK;
});

// node_modules/@actions/cache/lib/internal/requestUtils.js
var require_requestUtils = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryHttpClientResponse = exports.retryTypedResponse = exports.retry = exports.isRetryableStatusCode = exports.isServerErrorStatusCode = exports.isSuccessStatusCode = undefined;
  var core = __importStar(require_core());
  var http_client_1 = require_lib();
  var constants_1 = require_constants();
  function isSuccessStatusCode(statusCode) {
    if (!statusCode) {
      return false;
    }
    return statusCode >= 200 && statusCode < 300;
  }
  exports.isSuccessStatusCode = isSuccessStatusCode;
  function isServerErrorStatusCode(statusCode) {
    if (!statusCode) {
      return true;
    }
    return statusCode >= 500;
  }
  exports.isServerErrorStatusCode = isServerErrorStatusCode;
  function isRetryableStatusCode(statusCode) {
    if (!statusCode) {
      return false;
    }
    const retryableStatusCodes = [
      http_client_1.HttpCodes.BadGateway,
      http_client_1.HttpCodes.ServiceUnavailable,
      http_client_1.HttpCodes.GatewayTimeout
    ];
    return retryableStatusCodes.includes(statusCode);
  }
  exports.isRetryableStatusCode = isRetryableStatusCode;
  function sleep(milliseconds) {
    return __awaiter(this, undefined, undefined, function* () {
      return new Promise((resolve) => setTimeout(resolve, milliseconds));
    });
  }
  function retry(name, method, getStatusCode, maxAttempts = constants_1.DefaultRetryAttempts, delay = constants_1.DefaultRetryDelay, onError = undefined) {
    return __awaiter(this, undefined, undefined, function* () {
      let errorMessage = "";
      let attempt = 1;
      while (attempt <= maxAttempts) {
        let response = undefined;
        let statusCode = undefined;
        let isRetryable = false;
        try {
          response = yield method();
        } catch (error) {
          if (onError) {
            response = onError(error);
          }
          isRetryable = true;
          errorMessage = error.message;
        }
        if (response) {
          statusCode = getStatusCode(response);
          if (!isServerErrorStatusCode(statusCode)) {
            return response;
          }
        }
        if (statusCode) {
          isRetryable = isRetryableStatusCode(statusCode);
          errorMessage = `Cache service responded with ${statusCode}`;
        }
        core.debug(`${name} - Attempt ${attempt} of ${maxAttempts} failed with error: ${errorMessage}`);
        if (!isRetryable) {
          core.debug(`${name} - Error is not retryable`);
          break;
        }
        yield sleep(delay);
        attempt++;
      }
      throw Error(`${name} failed: ${errorMessage}`);
    });
  }
  exports.retry = retry;
  function retryTypedResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay = constants_1.DefaultRetryDelay) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield retry(name, method, (response) => response.statusCode, maxAttempts, delay, (error) => {
        if (error instanceof http_client_1.HttpClientError) {
          return {
            statusCode: error.statusCode,
            result: null,
            headers: {},
            error
          };
        } else {
          return;
        }
      });
    });
  }
  exports.retryTypedResponse = retryTypedResponse;
  function retryHttpClientResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay = constants_1.DefaultRetryDelay) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield retry(name, method, (response) => response.message.statusCode, maxAttempts, delay);
    });
  }
  exports.retryHttpClientResponse = retryHttpClientResponse;
});

// node_modules/@azure/abort-controller/dist/index.js
var require_dist5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var listenersMap = new WeakMap;
  var abortedMap = new WeakMap;

  class AbortSignal {
    constructor() {
      this.onabort = null;
      listenersMap.set(this, []);
      abortedMap.set(this, false);
    }
    get aborted() {
      if (!abortedMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      return abortedMap.get(this);
    }
    static get none() {
      return new AbortSignal;
    }
    addEventListener(_type, listener) {
      if (!listenersMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      const listeners = listenersMap.get(this);
      listeners.push(listener);
    }
    removeEventListener(_type, listener) {
      if (!listenersMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      const listeners = listenersMap.get(this);
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
    dispatchEvent(_event) {
      throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
    }
  }
  function abortSignal(signal) {
    if (signal.aborted) {
      return;
    }
    if (signal.onabort) {
      signal.onabort.call(signal);
    }
    const listeners = listenersMap.get(signal);
    if (listeners) {
      listeners.slice().forEach((listener) => {
        listener.call(signal, { type: "abort" });
      });
    }
    abortedMap.set(signal, true);
  }

  class AbortError extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }

  class AbortController2 {
    constructor(parentSignals) {
      this._signal = new AbortSignal;
      if (!parentSignals) {
        return;
      }
      if (!Array.isArray(parentSignals)) {
        parentSignals = arguments;
      }
      for (const parentSignal of parentSignals) {
        if (parentSignal.aborted) {
          this.abort();
        } else {
          parentSignal.addEventListener("abort", () => {
            this.abort();
          });
        }
      }
    }
    get signal() {
      return this._signal;
    }
    abort() {
      abortSignal(this._signal);
    }
    static timeout(ms) {
      const signal = new AbortSignal;
      const timer = setTimeout(abortSignal, ms, signal);
      if (typeof timer.unref === "function") {
        timer.unref();
      }
      return signal;
    }
  }
  exports.AbortController = AbortController2;
  exports.AbortError = AbortError;
  exports.AbortSignal = AbortSignal;
});

// node_modules/@actions/cache/lib/internal/downloadUtils.js
var require_downloadUtils = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.downloadCacheStorageSDK = exports.downloadCacheHttpClientConcurrent = exports.downloadCacheHttpClient = exports.DownloadProgress = undefined;
  var core = __importStar(require_core());
  var http_client_1 = require_lib();
  var storage_blob_1 = require_dist4();
  var buffer = __importStar(__require("buffer"));
  var fs = __importStar(__require("fs"));
  var stream = __importStar(__require("stream"));
  var util = __importStar(__require("util"));
  var utils = __importStar(require_cacheUtils());
  var constants_1 = require_constants();
  var requestUtils_1 = require_requestUtils();
  var abort_controller_1 = require_dist5();
  function pipeResponseToStream(response, output) {
    return __awaiter(this, undefined, undefined, function* () {
      const pipeline = util.promisify(stream.pipeline);
      yield pipeline(response.message, output);
    });
  }

  class DownloadProgress {
    constructor(contentLength) {
      this.contentLength = contentLength;
      this.segmentIndex = 0;
      this.segmentSize = 0;
      this.segmentOffset = 0;
      this.receivedBytes = 0;
      this.displayedComplete = false;
      this.startTime = Date.now();
    }
    nextSegment(segmentSize) {
      this.segmentOffset = this.segmentOffset + this.segmentSize;
      this.segmentIndex = this.segmentIndex + 1;
      this.segmentSize = segmentSize;
      this.receivedBytes = 0;
      core.debug(`Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`);
    }
    setReceivedBytes(receivedBytes) {
      this.receivedBytes = receivedBytes;
    }
    getTransferredBytes() {
      return this.segmentOffset + this.receivedBytes;
    }
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    display() {
      if (this.displayedComplete) {
        return;
      }
      const transferredBytes = this.segmentOffset + this.receivedBytes;
      const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1);
      const elapsedTime = Date.now() - this.startTime;
      const downloadSpeed = (transferredBytes / (1024 * 1024) / (elapsedTime / 1000)).toFixed(1);
      core.info(`Received ${transferredBytes} of ${this.contentLength} (${percentage}%), ${downloadSpeed} MBs/sec`);
      if (this.isDone()) {
        this.displayedComplete = true;
      }
    }
    onProgress() {
      return (progress) => {
        this.setReceivedBytes(progress.loadedBytes);
      };
    }
    startDisplayTimer(delayInMs = 1000) {
      const displayCallback = () => {
        this.display();
        if (!this.isDone()) {
          this.timeoutHandle = setTimeout(displayCallback, delayInMs);
        }
      };
      this.timeoutHandle = setTimeout(displayCallback, delayInMs);
    }
    stopDisplayTimer() {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = undefined;
      }
      this.display();
    }
  }
  exports.DownloadProgress = DownloadProgress;
  function downloadCacheHttpClient(archiveLocation, archivePath) {
    return __awaiter(this, undefined, undefined, function* () {
      const writeStream = fs.createWriteStream(archivePath);
      const httpClient = new http_client_1.HttpClient("actions/cache");
      const downloadResponse = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCache", () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.get(archiveLocation);
      }));
      downloadResponse.message.socket.setTimeout(constants_1.SocketTimeout, () => {
        downloadResponse.message.destroy();
        core.debug(`Aborting download, socket timed out after ${constants_1.SocketTimeout} ms`);
      });
      yield pipeResponseToStream(downloadResponse, writeStream);
      const contentLengthHeader = downloadResponse.message.headers["content-length"];
      if (contentLengthHeader) {
        const expectedLength = parseInt(contentLengthHeader);
        const actualLength = utils.getArchiveFileSizeInBytes(archivePath);
        if (actualLength !== expectedLength) {
          throw new Error(`Incomplete download. Expected file size: ${expectedLength}, actual file size: ${actualLength}`);
        }
      } else {
        core.debug("Unable to validate download, no Content-Length header");
      }
    });
  }
  exports.downloadCacheHttpClient = downloadCacheHttpClient;
  function downloadCacheHttpClientConcurrent(archiveLocation, archivePath, options) {
    var _a;
    return __awaiter(this, undefined, undefined, function* () {
      const archiveDescriptor = yield fs.promises.open(archivePath, "w");
      const httpClient = new http_client_1.HttpClient("actions/cache", undefined, {
        socketTimeout: options.timeoutInMs,
        keepAlive: true
      });
      try {
        const res = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCacheMetadata", () => __awaiter(this, undefined, undefined, function* () {
          return yield httpClient.request("HEAD", archiveLocation, null, {});
        }));
        const lengthHeader = res.message.headers["content-length"];
        if (lengthHeader === undefined || lengthHeader === null) {
          throw new Error("Content-Length not found on blob response");
        }
        const length = parseInt(lengthHeader);
        if (Number.isNaN(length)) {
          throw new Error(`Could not interpret Content-Length: ${length}`);
        }
        const downloads = [];
        const blockSize = 4 * 1024 * 1024;
        for (let offset = 0;offset < length; offset += blockSize) {
          const count = Math.min(blockSize, length - offset);
          downloads.push({
            offset,
            promiseGetter: () => __awaiter(this, undefined, undefined, function* () {
              return yield downloadSegmentRetry(httpClient, archiveLocation, offset, count);
            })
          });
        }
        downloads.reverse();
        let actives = 0;
        let bytesDownloaded = 0;
        const progress = new DownloadProgress(length);
        progress.startDisplayTimer();
        const progressFn = progress.onProgress();
        const activeDownloads = [];
        let nextDownload;
        const waitAndWrite = () => __awaiter(this, undefined, undefined, function* () {
          const segment = yield Promise.race(Object.values(activeDownloads));
          yield archiveDescriptor.write(segment.buffer, 0, segment.count, segment.offset);
          actives--;
          delete activeDownloads[segment.offset];
          bytesDownloaded += segment.count;
          progressFn({ loadedBytes: bytesDownloaded });
        });
        while (nextDownload = downloads.pop()) {
          activeDownloads[nextDownload.offset] = nextDownload.promiseGetter();
          actives++;
          if (actives >= ((_a = options.downloadConcurrency) !== null && _a !== undefined ? _a : 10)) {
            yield waitAndWrite();
          }
        }
        while (actives > 0) {
          yield waitAndWrite();
        }
      } finally {
        httpClient.dispose();
        yield archiveDescriptor.close();
      }
    });
  }
  exports.downloadCacheHttpClientConcurrent = downloadCacheHttpClientConcurrent;
  function downloadSegmentRetry(httpClient, archiveLocation, offset, count) {
    return __awaiter(this, undefined, undefined, function* () {
      const retries = 5;
      let failures = 0;
      while (true) {
        try {
          const timeout = 30000;
          const result = yield promiseWithTimeout(timeout, downloadSegment(httpClient, archiveLocation, offset, count));
          if (typeof result === "string") {
            throw new Error("downloadSegmentRetry failed due to timeout");
          }
          return result;
        } catch (err) {
          if (failures >= retries) {
            throw err;
          }
          failures++;
        }
      }
    });
  }
  function downloadSegment(httpClient, archiveLocation, offset, count) {
    return __awaiter(this, undefined, undefined, function* () {
      const partRes = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCachePart", () => __awaiter(this, undefined, undefined, function* () {
        return yield httpClient.get(archiveLocation, {
          Range: `bytes=${offset}-${offset + count - 1}`
        });
      }));
      if (!partRes.readBodyBuffer) {
        throw new Error("Expected HttpClientResponse to implement readBodyBuffer");
      }
      return {
        offset,
        count,
        buffer: yield partRes.readBodyBuffer()
      };
    });
  }
  function downloadCacheStorageSDK(archiveLocation, archivePath, options) {
    var _a;
    return __awaiter(this, undefined, undefined, function* () {
      const client = new storage_blob_1.BlockBlobClient(archiveLocation, undefined, {
        retryOptions: {
          tryTimeoutInMs: options.timeoutInMs
        }
      });
      const properties = yield client.getProperties();
      const contentLength = (_a = properties.contentLength) !== null && _a !== undefined ? _a : -1;
      if (contentLength < 0) {
        core.debug("Unable to determine content length, downloading file with http-client...");
        yield downloadCacheHttpClient(archiveLocation, archivePath);
      } else {
        const maxSegmentSize = Math.min(134217728, buffer.constants.MAX_LENGTH);
        const downloadProgress = new DownloadProgress(contentLength);
        const fd = fs.openSync(archivePath, "w");
        try {
          downloadProgress.startDisplayTimer();
          const controller = new abort_controller_1.AbortController;
          const abortSignal = controller.signal;
          while (!downloadProgress.isDone()) {
            const segmentStart = downloadProgress.segmentOffset + downloadProgress.segmentSize;
            const segmentSize = Math.min(maxSegmentSize, contentLength - segmentStart);
            downloadProgress.nextSegment(segmentSize);
            const result = yield promiseWithTimeout(options.segmentTimeoutInMs || 3600000, client.downloadToBuffer(segmentStart, segmentSize, {
              abortSignal,
              concurrency: options.downloadConcurrency,
              onProgress: downloadProgress.onProgress()
            }));
            if (result === "timeout") {
              controller.abort();
              throw new Error("Aborting cache download as the download time exceeded the timeout.");
            } else if (Buffer.isBuffer(result)) {
              fs.writeFileSync(fd, result);
            }
          }
        } finally {
          downloadProgress.stopDisplayTimer();
          fs.closeSync(fd);
        }
      }
    });
  }
  exports.downloadCacheStorageSDK = downloadCacheStorageSDK;
  var promiseWithTimeout = (timeoutMs, promise) => __awaiter(undefined, undefined, undefined, function* () {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve) => {
      timeoutHandle = setTimeout(() => resolve("timeout"), timeoutMs);
    });
    return Promise.race([promise, timeoutPromise]).then((result) => {
      clearTimeout(timeoutHandle);
      return result;
    });
  });
});

// node_modules/@actions/cache/lib/options.js
var require_options = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getDownloadOptions = exports.getUploadOptions = undefined;
  var core = __importStar(require_core());
  function getUploadOptions(copy) {
    const result = {
      useAzureSdk: false,
      uploadConcurrency: 4,
      uploadChunkSize: 32 * 1024 * 1024
    };
    if (copy) {
      if (typeof copy.useAzureSdk === "boolean") {
        result.useAzureSdk = copy.useAzureSdk;
      }
      if (typeof copy.uploadConcurrency === "number") {
        result.uploadConcurrency = copy.uploadConcurrency;
      }
      if (typeof copy.uploadChunkSize === "number") {
        result.uploadChunkSize = copy.uploadChunkSize;
      }
    }
    result.uploadConcurrency = !isNaN(Number(process.env["CACHE_UPLOAD_CONCURRENCY"])) ? Math.min(32, Number(process.env["CACHE_UPLOAD_CONCURRENCY"])) : result.uploadConcurrency;
    result.uploadChunkSize = !isNaN(Number(process.env["CACHE_UPLOAD_CHUNK_SIZE"])) ? Math.min(128 * 1024 * 1024, Number(process.env["CACHE_UPLOAD_CHUNK_SIZE"]) * 1024 * 1024) : result.uploadChunkSize;
    core.debug(`Use Azure SDK: ${result.useAzureSdk}`);
    core.debug(`Upload concurrency: ${result.uploadConcurrency}`);
    core.debug(`Upload chunk size: ${result.uploadChunkSize}`);
    return result;
  }
  exports.getUploadOptions = getUploadOptions;
  function getDownloadOptions(copy) {
    const result = {
      useAzureSdk: false,
      concurrentBlobDownloads: true,
      downloadConcurrency: 8,
      timeoutInMs: 30000,
      segmentTimeoutInMs: 600000,
      lookupOnly: false
    };
    if (copy) {
      if (typeof copy.useAzureSdk === "boolean") {
        result.useAzureSdk = copy.useAzureSdk;
      }
      if (typeof copy.concurrentBlobDownloads === "boolean") {
        result.concurrentBlobDownloads = copy.concurrentBlobDownloads;
      }
      if (typeof copy.downloadConcurrency === "number") {
        result.downloadConcurrency = copy.downloadConcurrency;
      }
      if (typeof copy.timeoutInMs === "number") {
        result.timeoutInMs = copy.timeoutInMs;
      }
      if (typeof copy.segmentTimeoutInMs === "number") {
        result.segmentTimeoutInMs = copy.segmentTimeoutInMs;
      }
      if (typeof copy.lookupOnly === "boolean") {
        result.lookupOnly = copy.lookupOnly;
      }
    }
    const segmentDownloadTimeoutMins = process.env["SEGMENT_DOWNLOAD_TIMEOUT_MINS"];
    if (segmentDownloadTimeoutMins && !isNaN(Number(segmentDownloadTimeoutMins)) && isFinite(Number(segmentDownloadTimeoutMins))) {
      result.segmentTimeoutInMs = Number(segmentDownloadTimeoutMins) * 60 * 1000;
    }
    core.debug(`Use Azure SDK: ${result.useAzureSdk}`);
    core.debug(`Download concurrency: ${result.downloadConcurrency}`);
    core.debug(`Request timeout (ms): ${result.timeoutInMs}`);
    core.debug(`Cache segment download timeout mins env var: ${process.env["SEGMENT_DOWNLOAD_TIMEOUT_MINS"]}`);
    core.debug(`Segment download timeout (ms): ${result.segmentTimeoutInMs}`);
    core.debug(`Lookup only: ${result.lookupOnly}`);
    return result;
  }
  exports.getDownloadOptions = getDownloadOptions;
});

// node_modules/@actions/cache/lib/internal/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCacheServiceURL = exports.getCacheServiceVersion = exports.isGhes = undefined;
  function isGhes() {
    const ghUrl = new URL(process.env["GITHUB_SERVER_URL"] || "https://github.com");
    const hostname = ghUrl.hostname.trimEnd().toUpperCase();
    const isGitHubHost = hostname === "GITHUB.COM";
    const isGheHost = hostname.endsWith(".GHE.COM");
    const isLocalHost = hostname.endsWith(".LOCALHOST");
    return !isGitHubHost && !isGheHost && !isLocalHost;
  }
  exports.isGhes = isGhes;
  function getCacheServiceVersion() {
    if (isGhes())
      return "v1";
    return process.env["ACTIONS_CACHE_SERVICE_V2"] ? "v2" : "v1";
  }
  exports.getCacheServiceVersion = getCacheServiceVersion;
  function getCacheServiceURL() {
    const version = getCacheServiceVersion();
    switch (version) {
      case "v1":
        return process.env["ACTIONS_CACHE_URL"] || process.env["ACTIONS_RESULTS_URL"] || "";
      case "v2":
        return process.env["ACTIONS_RESULTS_URL"] || "";
      default:
        throw new Error(`Unsupported cache service version: ${version}`);
    }
  }
  exports.getCacheServiceURL = getCacheServiceURL;
});

// node_modules/@actions/cache/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "@actions/cache",
    version: "4.0.0",
    preview: true,
    description: "Actions cache lib",
    keywords: [
      "github",
      "actions",
      "cache"
    ],
    homepage: "https://github.com/actions/toolkit/tree/main/packages/cache",
    license: "MIT",
    main: "lib/cache.js",
    types: "lib/cache.d.ts",
    directories: {
      lib: "lib",
      test: "__tests__"
    },
    files: [
      "lib",
      "!.DS_Store"
    ],
    publishConfig: {
      access: "public"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/actions/toolkit.git",
      directory: "packages/cache"
    },
    scripts: {
      "audit-moderate": "npm install && npm audit --json --audit-level=moderate > audit.json",
      test: 'echo "Error: run tests from root" && exit 1',
      tsc: "tsc"
    },
    bugs: {
      url: "https://github.com/actions/toolkit/issues"
    },
    dependencies: {
      "@actions/core": "^1.11.1",
      "@actions/exec": "^1.0.1",
      "@actions/glob": "^0.1.0",
      "@actions/http-client": "^2.1.1",
      "@actions/io": "^1.0.1",
      "@azure/abort-controller": "^1.1.0",
      "@azure/ms-rest-js": "^2.6.0",
      "@azure/storage-blob": "^12.13.0",
      "@protobuf-ts/plugin": "^2.9.4",
      semver: "^6.3.1",
      "twirp-ts": "^2.5.0"
    },
    devDependencies: {
      "@types/semver": "^6.0.0",
      typescript: "^5.2.2"
    }
  };
});

// node_modules/@actions/cache/lib/internal/shared/user-agent.js
var require_user_agent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentString = undefined;
  var packageJson = require_package();
  function getUserAgentString() {
    return `@actions/cache-${packageJson.version}`;
  }
  exports.getUserAgentString = getUserAgentString;
});

// node_modules/@actions/cache/lib/internal/cacheHttpClient.js
var require_cacheHttpClient = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.saveCache = exports.reserveCache = exports.downloadCache = exports.getCacheEntry = undefined;
  var core = __importStar(require_core());
  var http_client_1 = require_lib();
  var auth_1 = require_auth();
  var fs = __importStar(__require("fs"));
  var url_1 = __require("url");
  var utils = __importStar(require_cacheUtils());
  var uploadUtils_1 = require_uploadUtils();
  var downloadUtils_1 = require_downloadUtils();
  var options_1 = require_options();
  var requestUtils_1 = require_requestUtils();
  var config_1 = require_config();
  var user_agent_1 = require_user_agent();
  function getCacheApiUrl(resource) {
    const baseUrl = (0, config_1.getCacheServiceURL)();
    if (!baseUrl) {
      throw new Error("Cache Service Url not found, unable to restore cache.");
    }
    const url = `${baseUrl}_apis/artifactcache/${resource}`;
    core.debug(`Resource Url: ${url}`);
    return url;
  }
  function createAcceptHeader(type, apiVersion) {
    return `${type};api-version=${apiVersion}`;
  }
  function getRequestOptions() {
    const requestOptions = {
      headers: {
        Accept: createAcceptHeader("application/json", "6.0-preview.1")
      }
    };
    return requestOptions;
  }
  function createHttpClient() {
    const token = process.env["ACTIONS_RUNTIME_TOKEN"] || "";
    const bearerCredentialHandler = new auth_1.BearerCredentialHandler(token);
    return new http_client_1.HttpClient((0, user_agent_1.getUserAgentString)(), [bearerCredentialHandler], getRequestOptions());
  }
  function getCacheEntry(keys, paths, options) {
    return __awaiter(this, undefined, undefined, function* () {
      const httpClient = createHttpClient();
      const version = utils.getCacheVersion(paths, options === null || options === undefined ? undefined : options.compressionMethod, options === null || options === undefined ? undefined : options.enableCrossOsArchive);
      const resource = `cache?keys=${encodeURIComponent(keys.join(","))}&version=${version}`;
      const response = yield (0, requestUtils_1.retryTypedResponse)("getCacheEntry", () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.getJson(getCacheApiUrl(resource));
      }));
      if (response.statusCode === 204) {
        if (core.isDebug()) {
          yield printCachesListForDiagnostics(keys[0], httpClient, version);
        }
        return null;
      }
      if (!(0, requestUtils_1.isSuccessStatusCode)(response.statusCode)) {
        throw new Error(`Cache service responded with ${response.statusCode}`);
      }
      const cacheResult = response.result;
      const cacheDownloadUrl = cacheResult === null || cacheResult === undefined ? undefined : cacheResult.archiveLocation;
      if (!cacheDownloadUrl) {
        throw new Error("Cache not found.");
      }
      core.setSecret(cacheDownloadUrl);
      core.debug(`Cache Result:`);
      core.debug(JSON.stringify(cacheResult));
      return cacheResult;
    });
  }
  exports.getCacheEntry = getCacheEntry;
  function printCachesListForDiagnostics(key, httpClient, version) {
    return __awaiter(this, undefined, undefined, function* () {
      const resource = `caches?key=${encodeURIComponent(key)}`;
      const response = yield (0, requestUtils_1.retryTypedResponse)("listCache", () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.getJson(getCacheApiUrl(resource));
      }));
      if (response.statusCode === 200) {
        const cacheListResult = response.result;
        const totalCount = cacheListResult === null || cacheListResult === undefined ? undefined : cacheListResult.totalCount;
        if (totalCount && totalCount > 0) {
          core.debug(`No matching cache found for cache key '${key}', version '${version} and scope ${process.env["GITHUB_REF"]}. There exist one or more cache(s) with similar key but they have different version or scope. See more info on cache matching here: https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key 
Other caches with similar key:`);
          for (const cacheEntry of (cacheListResult === null || cacheListResult === undefined ? undefined : cacheListResult.artifactCaches) || []) {
            core.debug(`Cache Key: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.cacheKey}, Cache Version: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.cacheVersion}, Cache Scope: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.scope}, Cache Created: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.creationTime}`);
          }
        }
      }
    });
  }
  function downloadCache(archiveLocation, archivePath, options) {
    return __awaiter(this, undefined, undefined, function* () {
      const archiveUrl = new url_1.URL(archiveLocation);
      const downloadOptions = (0, options_1.getDownloadOptions)(options);
      if (archiveUrl.hostname.endsWith(".blob.core.windows.net")) {
        if (downloadOptions.useAzureSdk) {
          yield (0, downloadUtils_1.downloadCacheStorageSDK)(archiveLocation, archivePath, downloadOptions);
        } else if (downloadOptions.concurrentBlobDownloads) {
          yield (0, downloadUtils_1.downloadCacheHttpClientConcurrent)(archiveLocation, archivePath, downloadOptions);
        } else {
          yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
        }
      } else {
        yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
      }
    });
  }
  exports.downloadCache = downloadCache;
  function reserveCache(key, paths, options) {
    return __awaiter(this, undefined, undefined, function* () {
      const httpClient = createHttpClient();
      const version = utils.getCacheVersion(paths, options === null || options === undefined ? undefined : options.compressionMethod, options === null || options === undefined ? undefined : options.enableCrossOsArchive);
      const reserveCacheRequest = {
        key,
        version,
        cacheSize: options === null || options === undefined ? undefined : options.cacheSize
      };
      const response = yield (0, requestUtils_1.retryTypedResponse)("reserveCache", () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.postJson(getCacheApiUrl("caches"), reserveCacheRequest);
      }));
      return response;
    });
  }
  exports.reserveCache = reserveCache;
  function getContentRange(start, end) {
    return `bytes ${start}-${end}/*`;
  }
  function uploadChunk(httpClient, resourceUrl, openStream, start, end) {
    return __awaiter(this, undefined, undefined, function* () {
      core.debug(`Uploading chunk of size ${end - start + 1} bytes at offset ${start} with content range: ${getContentRange(start, end)}`);
      const additionalHeaders = {
        "Content-Type": "application/octet-stream",
        "Content-Range": getContentRange(start, end)
      };
      const uploadChunkResponse = yield (0, requestUtils_1.retryHttpClientResponse)(`uploadChunk (start: ${start}, end: ${end})`, () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.sendStream("PATCH", resourceUrl, openStream(), additionalHeaders);
      }));
      if (!(0, requestUtils_1.isSuccessStatusCode)(uploadChunkResponse.message.statusCode)) {
        throw new Error(`Cache service responded with ${uploadChunkResponse.message.statusCode} during upload chunk.`);
      }
    });
  }
  function uploadFile(httpClient, cacheId, archivePath, options) {
    return __awaiter(this, undefined, undefined, function* () {
      const fileSize = utils.getArchiveFileSizeInBytes(archivePath);
      const resourceUrl = getCacheApiUrl(`caches/${cacheId.toString()}`);
      const fd = fs.openSync(archivePath, "r");
      const uploadOptions = (0, options_1.getUploadOptions)(options);
      const concurrency = utils.assertDefined("uploadConcurrency", uploadOptions.uploadConcurrency);
      const maxChunkSize = utils.assertDefined("uploadChunkSize", uploadOptions.uploadChunkSize);
      const parallelUploads = [...new Array(concurrency).keys()];
      core.debug("Awaiting all uploads");
      let offset = 0;
      try {
        yield Promise.all(parallelUploads.map(() => __awaiter(this, undefined, undefined, function* () {
          while (offset < fileSize) {
            const chunkSize = Math.min(fileSize - offset, maxChunkSize);
            const start = offset;
            const end = offset + chunkSize - 1;
            offset += maxChunkSize;
            yield uploadChunk(httpClient, resourceUrl, () => fs.createReadStream(archivePath, {
              fd,
              start,
              end,
              autoClose: false
            }).on("error", (error) => {
              throw new Error(`Cache upload failed because file read failed with ${error.message}`);
            }), start, end);
          }
        })));
      } finally {
        fs.closeSync(fd);
      }
      return;
    });
  }
  function commitCache(httpClient, cacheId, filesize) {
    return __awaiter(this, undefined, undefined, function* () {
      const commitCacheRequest = { size: filesize };
      return yield (0, requestUtils_1.retryTypedResponse)("commitCache", () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.postJson(getCacheApiUrl(`caches/${cacheId.toString()}`), commitCacheRequest);
      }));
    });
  }
  function saveCache(cacheId, archivePath, signedUploadURL, options) {
    return __awaiter(this, undefined, undefined, function* () {
      const uploadOptions = (0, options_1.getUploadOptions)(options);
      if (uploadOptions.useAzureSdk) {
        if (!signedUploadURL) {
          throw new Error("Azure Storage SDK can only be used when a signed URL is provided.");
        }
        yield (0, uploadUtils_1.uploadCacheArchiveSDK)(signedUploadURL, archivePath, options);
      } else {
        const httpClient = createHttpClient();
        core.debug("Upload cache");
        yield uploadFile(httpClient, cacheId, archivePath, options);
        core.debug("Commiting cache");
        const cacheSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.info(`Cache Size: ~${Math.round(cacheSize / (1024 * 1024))} MB (${cacheSize} B)`);
        const commitCacheResponse = yield commitCache(httpClient, cacheId, cacheSize);
        if (!(0, requestUtils_1.isSuccessStatusCode)(commitCacheResponse.statusCode)) {
          throw new Error(`Cache service responded with ${commitCacheResponse.statusCode} during commit cache.`);
        }
        core.info("Cache saved successfully");
      }
    });
  }
  exports.saveCache = saveCache;
});

// node_modules/twirp-ts/build/twirp/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/twirp-ts/build/twirp/hooks.js
var require_hooks = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isHook = exports.chainHooks = undefined;
  function chainHooks(...hooks) {
    if (hooks.length === 0) {
      return null;
    }
    if (hooks.length === 1) {
      return hooks[0];
    }
    const serverHook = {
      requestReceived(ctx) {
        return __awaiter(this, undefined, undefined, function* () {
          for (const hook of hooks) {
            if (!hook.requestReceived) {
              continue;
            }
            yield hook.requestReceived(ctx);
          }
        });
      },
      requestPrepared(ctx) {
        return __awaiter(this, undefined, undefined, function* () {
          for (const hook of hooks) {
            if (!hook.requestPrepared) {
              continue;
            }
            console.warn("hook requestPrepared is deprecated and will be removed in the next release. " + "Please use responsePrepared instead.");
            yield hook.requestPrepared(ctx);
          }
        });
      },
      responsePrepared(ctx) {
        return __awaiter(this, undefined, undefined, function* () {
          for (const hook of hooks) {
            if (!hook.responsePrepared) {
              continue;
            }
            yield hook.responsePrepared(ctx);
          }
        });
      },
      requestSent(ctx) {
        return __awaiter(this, undefined, undefined, function* () {
          for (const hook of hooks) {
            if (!hook.requestSent) {
              continue;
            }
            console.warn("hook requestSent is deprecated and will be removed in the next release. " + "Please use responseSent instead.");
            yield hook.requestSent(ctx);
          }
        });
      },
      responseSent(ctx) {
        return __awaiter(this, undefined, undefined, function* () {
          for (const hook of hooks) {
            if (!hook.responseSent) {
              continue;
            }
            yield hook.responseSent(ctx);
          }
        });
      },
      requestRouted(ctx) {
        return __awaiter(this, undefined, undefined, function* () {
          for (const hook of hooks) {
            if (!hook.requestRouted) {
              continue;
            }
            yield hook.requestRouted(ctx);
          }
        });
      },
      error(ctx, err) {
        return __awaiter(this, undefined, undefined, function* () {
          for (const hook of hooks) {
            if (!hook.error) {
              continue;
            }
            yield hook.error(ctx, err);
          }
        });
      }
    };
    return serverHook;
  }
  exports.chainHooks = chainHooks;
  function isHook(object) {
    return "requestReceived" in object || "requestPrepared" in object || "requestSent" in object || "requestRouted" in object || "responsePrepared" in object || "responseSent" in object || "error" in object;
  }
  exports.isHook = isHook;
});

// node_modules/twirp-ts/build/twirp/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidErrorCode = exports.httpStatusFromErrorCode = exports.TwirpErrorCode = exports.BadRouteError = exports.InternalServerErrorWith = exports.InternalServerError = exports.RequiredArgumentError = exports.InvalidArgumentError = exports.NotFoundError = exports.TwirpError = undefined;

  class TwirpError extends Error {
    constructor(code, msg) {
      super(msg);
      this.code = TwirpErrorCode.Internal;
      this.meta = {};
      this.code = code;
      this.msg = msg;
      Object.setPrototypeOf(this, TwirpError.prototype);
    }
    withMeta(key, value) {
      this.meta[key] = value;
      return this;
    }
    getMeta(key) {
      return this.meta[key] || "";
    }
    withCause(err, addMeta = false) {
      this._originalCause = err;
      if (addMeta) {
        this.withMeta("cause", err.message);
      }
      return this;
    }
    cause() {
      return this._originalCause;
    }
    toJSON() {
      try {
        return JSON.stringify({
          code: this.code,
          msg: this.msg,
          meta: this.meta
        });
      } catch (e) {
        return `{"code": "internal", "msg": "There was an error but it could not be serialized into JSON"}`;
      }
    }
    static fromObject(obj) {
      const code = obj["code"] || TwirpErrorCode.Unknown;
      const msg = obj["msg"] || "unknown";
      const error = new TwirpError(code, msg);
      if (obj["meta"]) {
        Object.keys(obj["meta"]).forEach((key) => {
          error.withMeta(key, obj["meta"][key]);
        });
      }
      return error;
    }
  }
  exports.TwirpError = TwirpError;

  class NotFoundError extends TwirpError {
    constructor(msg) {
      super(TwirpErrorCode.NotFound, msg);
    }
  }
  exports.NotFoundError = NotFoundError;

  class InvalidArgumentError extends TwirpError {
    constructor(argument, validationMsg) {
      super(TwirpErrorCode.InvalidArgument, argument + " " + validationMsg);
      this.withMeta("argument", argument);
    }
  }
  exports.InvalidArgumentError = InvalidArgumentError;

  class RequiredArgumentError extends InvalidArgumentError {
    constructor(argument) {
      super(argument, "is required");
    }
  }
  exports.RequiredArgumentError = RequiredArgumentError;

  class InternalServerError extends TwirpError {
    constructor(msg) {
      super(TwirpErrorCode.Internal, msg);
    }
  }
  exports.InternalServerError = InternalServerError;

  class InternalServerErrorWith extends InternalServerError {
    constructor(err) {
      super(err.message);
      this.withMeta("cause", err.name);
      this.withCause(err);
    }
  }
  exports.InternalServerErrorWith = InternalServerErrorWith;

  class BadRouteError extends TwirpError {
    constructor(msg, method, url) {
      super(TwirpErrorCode.BadRoute, msg);
      this.withMeta("twirp_invalid_route", method + " " + url);
    }
  }
  exports.BadRouteError = BadRouteError;
  var TwirpErrorCode;
  (function(TwirpErrorCode2) {
    TwirpErrorCode2["Canceled"] = "canceled";
    TwirpErrorCode2["Unknown"] = "unknown";
    TwirpErrorCode2["InvalidArgument"] = "invalid_argument";
    TwirpErrorCode2["Malformed"] = "malformed";
    TwirpErrorCode2["DeadlineExceeded"] = "deadline_exceeded";
    TwirpErrorCode2["NotFound"] = "not_found";
    TwirpErrorCode2["BadRoute"] = "bad_route";
    TwirpErrorCode2["AlreadyExists"] = "already_exists";
    TwirpErrorCode2["PermissionDenied"] = "permission_denied";
    TwirpErrorCode2["Unauthenticated"] = "unauthenticated";
    TwirpErrorCode2["ResourceExhausted"] = "resource_exhausted";
    TwirpErrorCode2["FailedPrecondition"] = "failed_precondition";
    TwirpErrorCode2["Aborted"] = "aborted";
    TwirpErrorCode2["OutOfRange"] = "out_of_range";
    TwirpErrorCode2["Unimplemented"] = "unimplemented";
    TwirpErrorCode2["Internal"] = "internal";
    TwirpErrorCode2["Unavailable"] = "unavailable";
    TwirpErrorCode2["DataLoss"] = "data_loss";
  })(TwirpErrorCode = exports.TwirpErrorCode || (exports.TwirpErrorCode = {}));
  function httpStatusFromErrorCode(code) {
    switch (code) {
      case TwirpErrorCode.Canceled:
        return 408;
      case TwirpErrorCode.Unknown:
        return 500;
      case TwirpErrorCode.InvalidArgument:
        return 400;
      case TwirpErrorCode.Malformed:
        return 400;
      case TwirpErrorCode.DeadlineExceeded:
        return 408;
      case TwirpErrorCode.NotFound:
        return 404;
      case TwirpErrorCode.BadRoute:
        return 404;
      case TwirpErrorCode.AlreadyExists:
        return 409;
      case TwirpErrorCode.PermissionDenied:
        return 403;
      case TwirpErrorCode.Unauthenticated:
        return 401;
      case TwirpErrorCode.ResourceExhausted:
        return 429;
      case TwirpErrorCode.FailedPrecondition:
        return 412;
      case TwirpErrorCode.Aborted:
        return 409;
      case TwirpErrorCode.OutOfRange:
        return 400;
      case TwirpErrorCode.Unimplemented:
        return 501;
      case TwirpErrorCode.Internal:
        return 500;
      case TwirpErrorCode.Unavailable:
        return 503;
      case TwirpErrorCode.DataLoss:
        return 500;
      default:
        return 0;
    }
  }
  exports.httpStatusFromErrorCode = httpStatusFromErrorCode;
  function isValidErrorCode(code) {
    return httpStatusFromErrorCode(code) != 0;
  }
  exports.isValidErrorCode = isValidErrorCode;
});

// node_modules/twirp-ts/build/twirp/request.js
var require_request = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseTwirpPath = exports.getRequestData = exports.validateRequest = exports.getContentType = exports.TwirpContentType = undefined;
  var errors_1 = require_errors2();
  var TwirpContentType;
  (function(TwirpContentType2) {
    TwirpContentType2[TwirpContentType2["Protobuf"] = 0] = "Protobuf";
    TwirpContentType2[TwirpContentType2["JSON"] = 1] = "JSON";
    TwirpContentType2[TwirpContentType2["Unknown"] = 2] = "Unknown";
  })(TwirpContentType = exports.TwirpContentType || (exports.TwirpContentType = {}));
  function getContentType(mimeType) {
    switch (mimeType) {
      case "application/protobuf":
        return TwirpContentType.Protobuf;
      case "application/json":
        return TwirpContentType.JSON;
      default:
        return TwirpContentType.Unknown;
    }
  }
  exports.getContentType = getContentType;
  function validateRequest(ctx, request, pathPrefix) {
    if (request.method !== "POST") {
      const msg = `unsupported method ${request.method} (only POST is allowed)`;
      throw new errors_1.BadRouteError(msg, request.method || "", request.url || "");
    }
    const path = parseTwirpPath(request.url || "");
    if (path.pkgService !== (ctx.packageName ? ctx.packageName + "." : "") + ctx.serviceName) {
      const msg = `no handler for path ${request.url}`;
      throw new errors_1.BadRouteError(msg, request.method || "", request.url || "");
    }
    if (path.prefix !== pathPrefix) {
      const msg = `invalid path prefix ${path.prefix}, expected ${pathPrefix}, on path ${request.url}`;
      throw new errors_1.BadRouteError(msg, request.method || "", request.url || "");
    }
    const mimeContentType = request.headers["content-type"] || "";
    if (ctx.contentType === TwirpContentType.Unknown) {
      const msg = `unexpected Content-Type: ${request.headers["content-type"]}`;
      throw new errors_1.BadRouteError(msg, request.method || "", request.url || "");
    }
    return Object.assign(Object.assign({}, path), { mimeContentType, contentType: ctx.contentType });
  }
  exports.validateRequest = validateRequest;
  function getRequestData(req) {
    return new Promise((resolve, reject) => {
      const reqWithRawBody = req;
      if (reqWithRawBody.rawBody instanceof Buffer) {
        resolve(reqWithRawBody.rawBody);
        return;
      }
      const chunks = [];
      req.on("data", (chunk) => chunks.push(chunk));
      req.on("end", () => __awaiter(this, undefined, undefined, function* () {
        const data = Buffer.concat(chunks);
        resolve(data);
      }));
      req.on("error", (err) => {
        if (req.aborted) {
          reject(new errors_1.TwirpError(errors_1.TwirpErrorCode.DeadlineExceeded, "failed to read request: deadline exceeded"));
        } else {
          reject(new errors_1.TwirpError(errors_1.TwirpErrorCode.Malformed, err.message).withCause(err));
        }
      });
      req.on("close", () => {
        reject(new errors_1.TwirpError(errors_1.TwirpErrorCode.Canceled, "failed to read request: context canceled"));
      });
    });
  }
  exports.getRequestData = getRequestData;
  function parseTwirpPath(path) {
    const parts = path.split("/");
    if (parts.length < 2) {
      return {
        pkgService: "",
        method: "",
        prefix: ""
      };
    }
    return {
      method: parts[parts.length - 1],
      pkgService: parts[parts.length - 2],
      prefix: parts.slice(0, parts.length - 2).join("/")
    };
  }
  exports.parseTwirpPath = parseTwirpPath;
});

// node_modules/twirp-ts/build/twirp/server.js
var require_server = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeError = exports.TwirpServer = undefined;
  var hooks_1 = require_hooks();
  var request_1 = require_request();
  var errors_1 = require_errors2();

  class TwirpServer {
    constructor(options) {
      this.pathPrefix = "/twirp";
      this.hooks = [];
      this.interceptors = [];
      this.packageName = options.packageName;
      this.serviceName = options.serviceName;
      this.methodList = options.methodList;
      this.matchRoute = options.matchRoute;
      this.service = options.service;
    }
    get prefix() {
      return this.pathPrefix;
    }
    httpHandler(options) {
      return (req, resp) => {
        if ((options === null || options === undefined ? undefined : options.prefix) !== undefined) {
          this.withPrefix(options.prefix);
        }
        return this._httpHandler(req, resp);
      };
    }
    use(...middlewares) {
      middlewares.forEach((middleware) => {
        if (hooks_1.isHook(middleware)) {
          this.hooks.push(middleware);
          return this;
        }
        this.interceptors.push(middleware);
      });
      return this;
    }
    withPrefix(prefix) {
      if (prefix === false) {
        this.pathPrefix = "";
      } else {
        this.pathPrefix = prefix;
      }
      return this;
    }
    matchingPath() {
      const baseRegex = this.baseURI().replace(/\./g, "\\.");
      return new RegExp(`${baseRegex}/(${this.methodList.join("|")})`);
    }
    baseURI() {
      return `${this.pathPrefix}/${this.packageName ? this.packageName + "." : ""}${this.serviceName}`;
    }
    createContext(req, res) {
      return {
        packageName: this.packageName,
        serviceName: this.serviceName,
        methodName: "",
        contentType: request_1.getContentType(req.headers["content-type"]),
        req,
        res
      };
    }
    _httpHandler(req, resp) {
      return __awaiter(this, undefined, undefined, function* () {
        const ctx = this.createContext(req, resp);
        try {
          yield this.invokeHook("requestReceived", ctx);
          const { method, mimeContentType } = request_1.validateRequest(ctx, req, this.pathPrefix || "");
          const handler = this.matchRoute(method, {
            onMatch: (ctx2) => {
              return this.invokeHook("requestRouted", ctx2);
            },
            onNotFound: () => {
              const msg = `no handler for path ${req.url}`;
              throw new errors_1.BadRouteError(msg, req.method || "", req.url || "");
            }
          });
          const body = yield request_1.getRequestData(req);
          const response = yield handler(ctx, this.service, body, this.interceptors);
          yield Promise.all([
            this.invokeHook("responsePrepared", ctx),
            this.invokeHook("requestPrepared", ctx)
          ]);
          resp.statusCode = 200;
          resp.setHeader("Content-Type", mimeContentType);
          resp.end(response);
        } catch (e) {
          yield this.invokeHook("error", ctx, mustBeTwirpError(e));
          if (!resp.headersSent) {
            writeError(resp, e);
          }
        } finally {
          yield Promise.all([
            this.invokeHook("responseSent", ctx),
            this.invokeHook("requestSent", ctx)
          ]);
        }
      });
    }
    invokeHook(hookName, ctx, err) {
      return __awaiter(this, undefined, undefined, function* () {
        if (this.hooks.length === 0) {
          return;
        }
        const chainedHooks = hooks_1.chainHooks(...this.hooks);
        const hook = chainedHooks === null || chainedHooks === undefined ? undefined : chainedHooks[hookName];
        if (hook) {
          yield hook(ctx, err || new errors_1.InternalServerError("internal server error"));
        }
      });
    }
  }
  exports.TwirpServer = TwirpServer;
  function writeError(res, error) {
    const twirpError = mustBeTwirpError(error);
    res.setHeader("Content-Type", "application/json");
    res.statusCode = errors_1.httpStatusFromErrorCode(twirpError.code);
    res.end(twirpError.toJSON());
  }
  exports.writeError = writeError;
  function mustBeTwirpError(err) {
    if (err instanceof errors_1.TwirpError) {
      return err;
    }
    return new errors_1.InternalServerErrorWith(err);
  }
});

// node_modules/twirp-ts/build/twirp/interceptors.js
var require_interceptors = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chainInterceptors = undefined;
  function chainInterceptors(...interceptors) {
    if (interceptors.length === 0) {
      return;
    }
    if (interceptors.length === 1) {
      return interceptors[0];
    }
    const first = interceptors[0];
    return (ctx, request, handler) => __awaiter(this, undefined, undefined, function* () {
      let next = handler;
      for (let i = interceptors.length - 1;i > 0; i--) {
        next = ((next2) => (ctx2, typedRequest) => {
          return interceptors[i](ctx2, typedRequest, next2);
        })(next);
      }
      return first(ctx, request, next);
    });
  }
  exports.chainInterceptors = chainInterceptors;
});

// node_modules/dot-object/index.js
var require_dot_object = __commonJS((exports, module) => {
  function _process(v, mod) {
    var i;
    var r;
    if (typeof mod === "function") {
      r = mod(v);
      if (r !== undefined) {
        v = r;
      }
    } else if (Array.isArray(mod)) {
      for (i = 0;i < mod.length; i++) {
        r = mod[i](v);
        if (r !== undefined) {
          v = r;
        }
      }
    }
    return v;
  }
  function parseKey(key, val) {
    if (key[0] === "-" && Array.isArray(val) && /^-\d+$/.test(key)) {
      return val.length + parseInt(key, 10);
    }
    return key;
  }
  function isIndex(k) {
    return /^\d+$/.test(k);
  }
  function isObject(val) {
    return Object.prototype.toString.call(val) === "[object Object]";
  }
  function isArrayOrObject(val) {
    return Object(val) === val;
  }
  function isEmptyObject(val) {
    return Object.keys(val).length === 0;
  }
  var blacklist = ["__proto__", "prototype", "constructor"];
  var blacklistFilter = function(part) {
    return blacklist.indexOf(part) === -1;
  };
  function parsePath(path, sep) {
    if (path.indexOf("[") >= 0) {
      path = path.replace(/\[/g, sep).replace(/]/g, "");
    }
    var parts = path.split(sep);
    var check = parts.filter(blacklistFilter);
    if (check.length !== parts.length) {
      throw Error("Refusing to update blacklisted property " + path);
    }
    return parts;
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function DotObject(separator, override, useArray, useBrackets) {
    if (!(this instanceof DotObject)) {
      return new DotObject(separator, override, useArray, useBrackets);
    }
    if (typeof override === "undefined")
      override = false;
    if (typeof useArray === "undefined")
      useArray = true;
    if (typeof useBrackets === "undefined")
      useBrackets = true;
    this.separator = separator || ".";
    this.override = override;
    this.useArray = useArray;
    this.useBrackets = useBrackets;
    this.keepArray = false;
    this.cleanup = [];
  }
  var dotDefault = new DotObject(".", false, true, true);
  function wrap(method) {
    return function() {
      return dotDefault[method].apply(dotDefault, arguments);
    };
  }
  DotObject.prototype._fill = function(a, obj, v, mod) {
    var k = a.shift();
    if (a.length > 0) {
      obj[k] = obj[k] || (this.useArray && isIndex(a[0]) ? [] : {});
      if (!isArrayOrObject(obj[k])) {
        if (this.override) {
          obj[k] = {};
        } else {
          if (!(isArrayOrObject(v) && isEmptyObject(v))) {
            throw new Error("Trying to redefine `" + k + "` which is a " + typeof obj[k]);
          }
          return;
        }
      }
      this._fill(a, obj[k], v, mod);
    } else {
      if (!this.override && isArrayOrObject(obj[k]) && !isEmptyObject(obj[k])) {
        if (!(isArrayOrObject(v) && isEmptyObject(v))) {
          throw new Error("Trying to redefine non-empty obj['" + k + "']");
        }
        return;
      }
      obj[k] = _process(v, mod);
    }
  };
  DotObject.prototype.object = function(obj, mods) {
    var self2 = this;
    Object.keys(obj).forEach(function(k) {
      var mod = mods === undefined ? null : mods[k];
      var ok = parsePath(k, self2.separator).join(self2.separator);
      if (ok.indexOf(self2.separator) !== -1) {
        self2._fill(ok.split(self2.separator), obj, obj[k], mod);
        delete obj[k];
      } else {
        obj[k] = _process(obj[k], mod);
      }
    });
    return obj;
  };
  DotObject.prototype.str = function(path, v, obj, mod) {
    var ok = parsePath(path, this.separator).join(this.separator);
    if (path.indexOf(this.separator) !== -1) {
      this._fill(ok.split(this.separator), obj, v, mod);
    } else {
      obj[path] = _process(v, mod);
    }
    return obj;
  };
  DotObject.prototype.pick = function(path, obj, remove, reindexArray) {
    var i;
    var keys;
    var val;
    var key;
    var cp;
    keys = parsePath(path, this.separator);
    for (i = 0;i < keys.length; i++) {
      key = parseKey(keys[i], obj);
      if (obj && typeof obj === "object" && key in obj) {
        if (i === keys.length - 1) {
          if (remove) {
            val = obj[key];
            if (reindexArray && Array.isArray(obj)) {
              obj.splice(key, 1);
            } else {
              delete obj[key];
            }
            if (Array.isArray(obj)) {
              cp = keys.slice(0, -1).join(".");
              if (this.cleanup.indexOf(cp) === -1) {
                this.cleanup.push(cp);
              }
            }
            return val;
          } else {
            return obj[key];
          }
        } else {
          obj = obj[key];
        }
      } else {
        return;
      }
    }
    if (remove && Array.isArray(obj)) {
      obj = obj.filter(function(n) {
        return n !== undefined;
      });
    }
    return obj;
  };
  DotObject.prototype.delete = function(path, obj) {
    return this.remove(path, obj, true);
  };
  DotObject.prototype.remove = function(path, obj, reindexArray) {
    var i;
    this.cleanup = [];
    if (Array.isArray(path)) {
      for (i = 0;i < path.length; i++) {
        this.pick(path[i], obj, true, reindexArray);
      }
      if (!reindexArray) {
        this._cleanup(obj);
      }
      return obj;
    } else {
      return this.pick(path, obj, true, reindexArray);
    }
  };
  DotObject.prototype._cleanup = function(obj) {
    var ret;
    var i;
    var keys;
    var root;
    if (this.cleanup.length) {
      for (i = 0;i < this.cleanup.length; i++) {
        keys = this.cleanup[i].split(".");
        root = keys.splice(0, -1).join(".");
        ret = root ? this.pick(root, obj) : obj;
        ret = ret[keys[0]].filter(function(v) {
          return v !== undefined;
        });
        this.set(this.cleanup[i], ret, obj);
      }
      this.cleanup = [];
    }
  };
  DotObject.prototype.del = DotObject.prototype.remove;
  DotObject.prototype.move = function(source, target, obj, mods, merge) {
    if (typeof mods === "function" || Array.isArray(mods)) {
      this.set(target, _process(this.pick(source, obj, true), mods), obj, merge);
    } else {
      merge = mods;
      this.set(target, this.pick(source, obj, true), obj, merge);
    }
    return obj;
  };
  DotObject.prototype.transfer = function(source, target, obj1, obj2, mods, merge) {
    if (typeof mods === "function" || Array.isArray(mods)) {
      this.set(target, _process(this.pick(source, obj1, true), mods), obj2, merge);
    } else {
      merge = mods;
      this.set(target, this.pick(source, obj1, true), obj2, merge);
    }
    return obj2;
  };
  DotObject.prototype.copy = function(source, target, obj1, obj2, mods, merge) {
    if (typeof mods === "function" || Array.isArray(mods)) {
      this.set(target, _process(JSON.parse(JSON.stringify(this.pick(source, obj1, false))), mods), obj2, merge);
    } else {
      merge = mods;
      this.set(target, this.pick(source, obj1, false), obj2, merge);
    }
    return obj2;
  };
  DotObject.prototype.set = function(path, val, obj, merge) {
    var i;
    var k;
    var keys;
    var key;
    if (typeof val === "undefined") {
      return obj;
    }
    keys = parsePath(path, this.separator);
    for (i = 0;i < keys.length; i++) {
      key = keys[i];
      if (i === keys.length - 1) {
        if (merge && isObject(val) && isObject(obj[key])) {
          for (k in val) {
            if (hasOwnProperty.call(val, k)) {
              obj[key][k] = val[k];
            }
          }
        } else if (merge && Array.isArray(obj[key]) && Array.isArray(val)) {
          for (var j = 0;j < val.length; j++) {
            obj[keys[i]].push(val[j]);
          }
        } else {
          obj[key] = val;
        }
      } else if (!hasOwnProperty.call(obj, key) || !isObject(obj[key]) && !Array.isArray(obj[key])) {
        if (/^\d+$/.test(keys[i + 1])) {
          obj[key] = [];
        } else {
          obj[key] = {};
        }
      }
      obj = obj[key];
    }
    return obj;
  };
  DotObject.prototype.transform = function(recipe, obj, tgt) {
    obj = obj || {};
    tgt = tgt || {};
    Object.keys(recipe).forEach(function(key) {
      this.set(recipe[key], this.pick(key, obj), tgt);
    }.bind(this));
    return tgt;
  };
  DotObject.prototype.dot = function(obj, tgt, path) {
    tgt = tgt || {};
    path = path || [];
    var isArray = Array.isArray(obj);
    Object.keys(obj).forEach(function(key) {
      var index = isArray && this.useBrackets ? "[" + key + "]" : key;
      if (isArrayOrObject(obj[key]) && (isObject(obj[key]) && !isEmptyObject(obj[key]) || Array.isArray(obj[key]) && !this.keepArray && obj[key].length !== 0)) {
        if (isArray && this.useBrackets) {
          var previousKey = path[path.length - 1] || "";
          return this.dot(obj[key], tgt, path.slice(0, -1).concat(previousKey + index));
        } else {
          return this.dot(obj[key], tgt, path.concat(index));
        }
      } else {
        if (isArray && this.useBrackets) {
          tgt[path.join(this.separator).concat("[" + key + "]")] = obj[key];
        } else {
          tgt[path.concat(index).join(this.separator)] = obj[key];
        }
      }
    }.bind(this));
    return tgt;
  };
  DotObject.pick = wrap("pick");
  DotObject.move = wrap("move");
  DotObject.transfer = wrap("transfer");
  DotObject.transform = wrap("transform");
  DotObject.copy = wrap("copy");
  DotObject.object = wrap("object");
  DotObject.str = wrap("str");
  DotObject.set = wrap("set");
  DotObject.delete = wrap("delete");
  DotObject.del = DotObject.remove = wrap("remove");
  DotObject.dot = wrap("dot");
  ["override", "overwrite"].forEach(function(prop) {
    Object.defineProperty(DotObject, prop, {
      get: function() {
        return dotDefault.override;
      },
      set: function(val) {
        dotDefault.override = !!val;
      }
    });
  });
  ["useArray", "keepArray", "useBrackets"].forEach(function(prop) {
    Object.defineProperty(DotObject, prop, {
      get: function() {
        return dotDefault[prop];
      },
      set: function(val) {
        dotDefault[prop] = val;
      }
    });
  });
  DotObject._process = _process;
  module.exports = DotObject;
});

// node_modules/twirp-ts/build/twirp/http.client.js
var require_http_client = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FetchRPC = exports.wrapErrorResponseToTwirpError = exports.NodeHttpRPC = undefined;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  var url_1 = __require("url");
  var errors_1 = require_errors2();
  var NodeHttpRPC = (options) => ({
    request(service, method, contentType, data) {
      let client;
      return new Promise((resolve, rejected) => {
        const responseChunks = [];
        const requestData = contentType === "application/protobuf" ? Buffer.from(data) : JSON.stringify(data);
        const url = new url_1.URL(options.baseUrl);
        const isHttps = url.protocol === "https:";
        if (isHttps) {
          client = https;
        } else {
          client = http;
        }
        const prefix = url.pathname !== "/" ? url.pathname : "";
        const req = client.request(Object.assign(Object.assign({}, options ? options : {}), { method: "POST", protocol: url.protocol, host: url.hostname, port: url.port ? url.port : isHttps ? 443 : 80, path: `${prefix}/${service}/${method}`, headers: Object.assign(Object.assign({}, options.headers ? options.headers : {}), { "Content-Type": contentType, "Content-Length": contentType === "application/protobuf" ? Buffer.byteLength(requestData) : Buffer.from(requestData).byteLength }) }), (res) => {
          res.on("data", (chunk) => responseChunks.push(chunk));
          res.on("end", () => {
            const data2 = Buffer.concat(responseChunks);
            if (res.statusCode != 200) {
              rejected(wrapErrorResponseToTwirpError(data2.toString()));
            } else {
              if (contentType === "application/json") {
                resolve(JSON.parse(data2.toString()));
              } else {
                resolve(data2);
              }
            }
          });
          res.on("error", (err) => {
            rejected(err);
          });
        }).on("error", (err) => {
          rejected(err);
        });
        req.end(requestData);
      });
    }
  });
  exports.NodeHttpRPC = NodeHttpRPC;
  function wrapErrorResponseToTwirpError(errorResponse) {
    return errors_1.TwirpError.fromObject(JSON.parse(errorResponse));
  }
  exports.wrapErrorResponseToTwirpError = wrapErrorResponseToTwirpError;
  var FetchRPC = (options) => ({
    request(service, method, contentType, data) {
      return __awaiter(this, undefined, undefined, function* () {
        const headers = new Headers(options.headers);
        headers.set("content-type", contentType);
        const response = yield fetch(`${options.baseUrl}/${service}/${method}`, Object.assign(Object.assign({}, options), { method: "POST", headers, body: data instanceof Uint8Array ? data : JSON.stringify(data) }));
        if (response.status === 200) {
          if (contentType === "application/json") {
            return yield response.json();
          }
          return new Uint8Array(yield response.arrayBuffer());
        }
        throw errors_1.TwirpError.fromObject(yield response.json());
      });
    }
  });
  exports.FetchRPC = FetchRPC;
});

// node_modules/twirp-ts/build/twirp/gateway.js
var require_gateway = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest = exports && exports.__rest || function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Gateway = exports.Pattern = undefined;
  var querystring_1 = __require("querystring");
  var dotObject = __importStar(require_dot_object());
  var request_1 = require_request();
  var errors_1 = require_errors2();
  var http_client_1 = require_http_client();
  var server_1 = require_server();
  var Pattern;
  (function(Pattern2) {
    Pattern2["POST"] = "post";
    Pattern2["GET"] = "get";
    Pattern2["PATCH"] = "patch";
    Pattern2["PUT"] = "put";
    Pattern2["DELETE"] = "delete";
  })(Pattern = exports.Pattern || (exports.Pattern = {}));

  class Gateway {
    constructor(routes) {
      this.routes = routes;
    }
    twirpRewrite(prefix = "/twirp") {
      return (req, resp, next) => {
        this.rewrite(req, resp, prefix).then(() => next()).catch((e) => {
          if (e instanceof errors_1.TwirpError) {
            if (e.code !== errors_1.TwirpErrorCode.NotFound) {
              server_1.writeError(resp, e);
            } else {
              next();
            }
          }
        });
      };
    }
    rewrite(req, resp, prefix = "/twirp") {
      return __awaiter(this, undefined, undefined, function* () {
        const [match, route] = this.matchRoute(req);
        const body = yield this.prepareTwirpBody(req, match, route);
        const twirpUrl = `${prefix}/${route.packageName}.${route.serviceName}/${route.methodName}`;
        req.url = twirpUrl;
        req.originalUrl = twirpUrl;
        req.method = "POST";
        req.headers["content-type"] = "application/json";
        req.rawBody = Buffer.from(JSON.stringify(body));
        if (route.responseBodyKey) {
          const endFn = resp.end.bind(resp);
          resp.end = function(chunk) {
            if (resp.statusCode === 200) {
              endFn(`{ "${route.responseBodyKey}": ${chunk} }`);
            } else {
              endFn(chunk);
            }
          };
        }
      });
    }
    reverseProxy(httpClientOption) {
      const client = http_client_1.NodeHttpRPC(httpClientOption);
      return (req, res) => __awaiter(this, undefined, undefined, function* () {
        try {
          const [match, route] = this.matchRoute(req);
          const body = yield this.prepareTwirpBody(req, match, route);
          const response = yield client.request(`${route.packageName}.${route.serviceName}`, route.methodName, "application/json", body);
          res.statusCode = 200;
          res.setHeader("content-type", "application/json");
          let jsonResponse;
          if (route.responseBodyKey) {
            jsonResponse = JSON.stringify({ [route.responseBodyKey]: response });
          } else {
            jsonResponse = JSON.stringify(response);
          }
          res.end(jsonResponse);
        } catch (e) {
          server_1.writeError(res, e);
        }
      });
    }
    prepareTwirpBody(req, match, route) {
      return __awaiter(this, undefined, undefined, function* () {
        const _a = match.params, { query_string } = _a, params = __rest(_a, ["query_string"]);
        let requestBody = Object.assign({}, params);
        if (query_string && route.bodyKey !== "*") {
          const queryParams = this.parseQueryString(query_string);
          requestBody = Object.assign(Object.assign({}, queryParams), requestBody);
        }
        let body = {};
        if (route.bodyKey) {
          const data = yield request_1.getRequestData(req);
          try {
            const jsonBody = JSON.parse(data.toString() || "{}");
            if (route.bodyKey === "*") {
              body = jsonBody;
            } else {
              body[route.bodyKey] = jsonBody;
            }
          } catch (e) {
            const msg = "the json request could not be decoded";
            throw new errors_1.TwirpError(errors_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
          }
        }
        return Object.assign(Object.assign({}, body), requestBody);
      });
    }
    matchRoute(req) {
      var _a;
      const httpMethod = (_a = req.method) === null || _a === undefined ? undefined : _a.toLowerCase();
      if (!httpMethod) {
        throw new errors_1.BadRouteError(`method not allowed`, req.method || "", req.url || "");
      }
      const routes = this.routes[httpMethod];
      for (const route of routes) {
        const match = route.matcher(req.url || "/");
        if (match) {
          return [match, route];
        }
      }
      throw new errors_1.NotFoundError(`url ${req.url} not found`);
    }
    parseQueryString(queryString) {
      const queryParams = querystring_1.parse(queryString.replace("?", ""));
      return dotObject.object(queryParams);
    }
  }
  exports.Gateway = Gateway;
});

// node_modules/twirp-ts/build/twirp/index.js
var require_twirp = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TwirpContentType = undefined;
  __exportStar(require_context(), exports);
  __exportStar(require_server(), exports);
  __exportStar(require_interceptors(), exports);
  __exportStar(require_hooks(), exports);
  __exportStar(require_errors2(), exports);
  __exportStar(require_gateway(), exports);
  __exportStar(require_http_client(), exports);
  var request_1 = require_request();
  Object.defineProperty(exports, "TwirpContentType", { enumerable: true, get: function() {
    return request_1.TwirpContentType;
  } });
});

// node_modules/@protobuf-ts/runtime/build/commonjs/json-typings.js
var require_json_typings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isJsonObject = exports.typeofJsonValue = undefined;
  function typeofJsonValue(value) {
    let t = typeof value;
    if (t == "object") {
      if (Array.isArray(value))
        return "array";
      if (value === null)
        return "null";
    }
    return t;
  }
  exports.typeofJsonValue = typeofJsonValue;
  function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
  }
  exports.isJsonObject = isJsonObject;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/base64.js
var require_base642 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.base64encode = exports.base64decode = undefined;
  var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  var decTable = [];
  for (let i = 0;i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
  decTable[45] = encTable.indexOf("+");
  decTable[95] = encTable.indexOf("/");
  function base64decode(base64Str) {
    let es = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=")
      es -= 2;
    else if (base64Str[base64Str.length - 1] == "=")
      es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
    for (let i = 0;i < base64Str.length; i++) {
      b = decTable[base64Str.charCodeAt(i)];
      if (b === undefined) {
        switch (base64Str[i]) {
          case "=":
            groupPos = 0;
          case `
`:
          case "\r":
          case "\t":
          case " ":
            continue;
          default:
            throw Error(`invalid base64 string.`);
        }
      }
      switch (groupPos) {
        case 0:
          p = b;
          groupPos = 1;
          break;
        case 1:
          bytes[bytePos++] = p << 2 | (b & 48) >> 4;
          p = b;
          groupPos = 2;
          break;
        case 2:
          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
          p = b;
          groupPos = 3;
          break;
        case 3:
          bytes[bytePos++] = (p & 3) << 6 | b;
          groupPos = 0;
          break;
      }
    }
    if (groupPos == 1)
      throw Error(`invalid base64 string.`);
    return bytes.subarray(0, bytePos);
  }
  exports.base64decode = base64decode;
  function base64encode(bytes) {
    let base64 = "", groupPos = 0, b, p = 0;
    for (let i = 0;i < bytes.length; i++) {
      b = bytes[i];
      switch (groupPos) {
        case 0:
          base64 += encTable[b >> 2];
          p = (b & 3) << 4;
          groupPos = 1;
          break;
        case 1:
          base64 += encTable[p | b >> 4];
          p = (b & 15) << 2;
          groupPos = 2;
          break;
        case 2:
          base64 += encTable[p | b >> 6];
          base64 += encTable[b & 63];
          groupPos = 0;
          break;
      }
    }
    if (groupPos) {
      base64 += encTable[p];
      base64 += "=";
      if (groupPos == 1)
        base64 += "=";
    }
    return base64;
  }
  exports.base64encode = base64encode;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/protobufjs-utf8.js
var require_protobufjs_utf8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.utf8read = undefined;
  var fromCharCodes = (chunk) => String.fromCharCode.apply(String, chunk);
  function utf8read(bytes) {
    if (bytes.length < 1)
      return "";
    let pos = 0, parts = [], chunk = [], i = 0, t;
    let len = bytes.length;
    while (pos < len) {
      t = bytes[pos++];
      if (t < 128)
        chunk[i++] = t;
      else if (t > 191 && t < 224)
        chunk[i++] = (t & 31) << 6 | bytes[pos++] & 63;
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (bytes[pos++] & 63) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63) - 65536;
        chunk[i++] = 55296 + (t >> 10);
        chunk[i++] = 56320 + (t & 1023);
      } else
        chunk[i++] = (t & 15) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63;
      if (i > 8191) {
        parts.push(fromCharCodes(chunk));
        i = 0;
      }
    }
    if (parts.length) {
      if (i)
        parts.push(fromCharCodes(chunk.slice(0, i)));
      return parts.join("");
    }
    return fromCharCodes(chunk.slice(0, i));
  }
  exports.utf8read = utf8read;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-format-contract.js
var require_binary_format_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WireType = exports.mergeBinaryOptions = exports.UnknownFieldHandler = undefined;
  var UnknownFieldHandler;
  (function(UnknownFieldHandler2) {
    UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
    UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
      let container = is(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
      container.push({ no: fieldNo, wireType, data });
    };
    UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
      for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
        writer.tag(no, wireType).raw(data);
    };
    UnknownFieldHandler2.list = (message, fieldNo) => {
      if (is(message)) {
        let all = message[UnknownFieldHandler2.symbol];
        return fieldNo ? all.filter((uf) => uf.no == fieldNo) : all;
      }
      return [];
    };
    UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
    const is = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
  })(UnknownFieldHandler = exports.UnknownFieldHandler || (exports.UnknownFieldHandler = {}));
  function mergeBinaryOptions(a, b) {
    return Object.assign(Object.assign({}, a), b);
  }
  exports.mergeBinaryOptions = mergeBinaryOptions;
  var WireType;
  (function(WireType2) {
    WireType2[WireType2["Varint"] = 0] = "Varint";
    WireType2[WireType2["Bit64"] = 1] = "Bit64";
    WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
    WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
    WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
    WireType2[WireType2["Bit32"] = 5] = "Bit32";
  })(WireType = exports.WireType || (exports.WireType = {}));
});

// node_modules/@protobuf-ts/runtime/build/commonjs/goog-varint.js
var require_goog_varint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.varint32read = exports.varint32write = exports.int64toString = exports.int64fromString = exports.varint64write = exports.varint64read = undefined;
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0;shift < 28; shift += 7) {
      let b = this.buf[this.pos++];
      lowBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3;shift <= 31; shift += 7) {
      let b = this.buf[this.pos++];
      highBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  exports.varint64read = varint64read;
  function varint64write(lo, hi, bytes) {
    for (let i = 0;i < 28; i = i + 7) {
      const shift = lo >>> i;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i = 3;i < 31; i = i + 7) {
      const shift = hi >>> i;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  exports.varint64write = varint64write;
  var TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
  function int64fromString(dec) {
    let minus = dec[0] == "-";
    if (minus)
      dec = dec.slice(1);
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return [minus, lowBits, highBits];
  }
  exports.int64fromString = int64fromString;
  function int64toString(bitsLow, bitsHigh) {
    if (bitsHigh >>> 0 <= 2097151) {
      return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
    }
    let low = bitsLow & 16777215;
    let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
    let high = bitsHigh >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    let base = 1e7;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
      let partial = digit1e7 ? String(digit1e7) : "";
      if (needLeadingZeros) {
        return "0000000".slice(partial.length) + partial;
      }
      return partial;
    }
    return decimalFrom1e7(digitC, 0) + decimalFrom1e7(digitB, digitC) + decimalFrom1e7(digitA, 1);
  }
  exports.int64toString = int64toString;
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i = 0;i < 9; i++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  exports.varint32write = varint32write;
  function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 127;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 7;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 14;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 21;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 15) << 28;
    for (let readBytes = 5;(b & 128) !== 0 && readBytes < 10; readBytes++)
      b = this.buf[this.pos++];
    if ((b & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
  }
  exports.varint32read = varint32read;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/pb-long.js
var require_pb_long = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PbLong = exports.PbULong = exports.detectBi = undefined;
  var goog_varint_1 = require_goog_varint();
  var BI;
  function detectBi() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = globalThis.BigInt !== undefined && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
    BI = ok ? {
      MIN: BigInt("-9223372036854775808"),
      MAX: BigInt("9223372036854775807"),
      UMIN: BigInt("0"),
      UMAX: BigInt("18446744073709551615"),
      C: BigInt,
      V: dv
    } : undefined;
  }
  exports.detectBi = detectBi;
  detectBi();
  function assertBi(bi) {
    if (!bi)
      throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
  }
  var RE_DECIMAL_STR = /^-?[0-9]+$/;
  var TWO_PWR_32_DBL = 4294967296;
  var HALF_2_PWR_32 = 2147483648;

  class SharedPbLong {
    constructor(lo, hi) {
      this.lo = lo | 0;
      this.hi = hi | 0;
    }
    isZero() {
      return this.lo == 0 && this.hi == 0;
    }
    toNumber() {
      let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
      if (!Number.isSafeInteger(result))
        throw new Error("cannot convert to safe number");
      return result;
    }
  }

  class PbULong extends SharedPbLong {
    static from(value) {
      if (BI)
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            if (value == "")
              throw new Error("string is no integer");
            value = BI.C(value);
          case "number":
            if (value === 0)
              return this.ZERO;
            value = BI.C(value);
          case "bigint":
            if (!value)
              return this.ZERO;
            if (value < BI.UMIN)
              throw new Error("signed value for ulong");
            if (value > BI.UMAX)
              throw new Error("ulong too large");
            BI.V.setBigUint64(0, value, true);
            return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
        }
      else
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            value = value.trim();
            if (!RE_DECIMAL_STR.test(value))
              throw new Error("string is no integer");
            let [minus, lo, hi] = goog_varint_1.int64fromString(value);
            if (minus)
              throw new Error("signed value for ulong");
            return new PbULong(lo, hi);
          case "number":
            if (value == 0)
              return this.ZERO;
            if (!Number.isSafeInteger(value))
              throw new Error("number is no integer");
            if (value < 0)
              throw new Error("signed value for ulong");
            return new PbULong(value, value / TWO_PWR_32_DBL);
        }
      throw new Error("unknown value " + typeof value);
    }
    toString() {
      return BI ? this.toBigInt().toString() : goog_varint_1.int64toString(this.lo, this.hi);
    }
    toBigInt() {
      assertBi(BI);
      BI.V.setInt32(0, this.lo, true);
      BI.V.setInt32(4, this.hi, true);
      return BI.V.getBigUint64(0, true);
    }
  }
  exports.PbULong = PbULong;
  PbULong.ZERO = new PbULong(0, 0);

  class PbLong extends SharedPbLong {
    static from(value) {
      if (BI)
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            if (value == "")
              throw new Error("string is no integer");
            value = BI.C(value);
          case "number":
            if (value === 0)
              return this.ZERO;
            value = BI.C(value);
          case "bigint":
            if (!value)
              return this.ZERO;
            if (value < BI.MIN)
              throw new Error("signed long too small");
            if (value > BI.MAX)
              throw new Error("signed long too large");
            BI.V.setBigInt64(0, value, true);
            return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
        }
      else
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            value = value.trim();
            if (!RE_DECIMAL_STR.test(value))
              throw new Error("string is no integer");
            let [minus, lo, hi] = goog_varint_1.int64fromString(value);
            if (minus) {
              if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0)
                throw new Error("signed long too small");
            } else if (hi >= HALF_2_PWR_32)
              throw new Error("signed long too large");
            let pbl = new PbLong(lo, hi);
            return minus ? pbl.negate() : pbl;
          case "number":
            if (value == 0)
              return this.ZERO;
            if (!Number.isSafeInteger(value))
              throw new Error("number is no integer");
            return value > 0 ? new PbLong(value, value / TWO_PWR_32_DBL) : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
        }
      throw new Error("unknown value " + typeof value);
    }
    isNegative() {
      return (this.hi & HALF_2_PWR_32) !== 0;
    }
    negate() {
      let hi = ~this.hi, lo = this.lo;
      if (lo)
        lo = ~lo + 1;
      else
        hi += 1;
      return new PbLong(lo, hi);
    }
    toString() {
      if (BI)
        return this.toBigInt().toString();
      if (this.isNegative()) {
        let n = this.negate();
        return "-" + goog_varint_1.int64toString(n.lo, n.hi);
      }
      return goog_varint_1.int64toString(this.lo, this.hi);
    }
    toBigInt() {
      assertBi(BI);
      BI.V.setInt32(0, this.lo, true);
      BI.V.setInt32(4, this.hi, true);
      return BI.V.getBigInt64(0, true);
    }
  }
  exports.PbLong = PbLong;
  PbLong.ZERO = new PbLong(0, 0);
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-reader.js
var require_binary_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BinaryReader = exports.binaryReadOptions = undefined;
  var binary_format_contract_1 = require_binary_format_contract();
  var pb_long_1 = require_pb_long();
  var goog_varint_1 = require_goog_varint();
  var defaultsRead = {
    readUnknownField: true,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
  }
  exports.binaryReadOptions = binaryReadOptions;

  class BinaryReader {
    constructor(buf, textDecoder) {
      this.varint64 = goog_varint_1.varint64read;
      this.uint32 = goog_varint_1.varint32read;
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder = textDecoder !== null && textDecoder !== undefined ? textDecoder : new TextDecoder("utf-8", {
        fatal: true,
        ignoreBOM: true
      });
    }
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    skip(wireType) {
      let start = this.pos;
      switch (wireType) {
        case binary_format_contract_1.WireType.Varint:
          while (this.buf[this.pos++] & 128) {
          }
          break;
        case binary_format_contract_1.WireType.Bit64:
          this.pos += 4;
        case binary_format_contract_1.WireType.Bit32:
          this.pos += 4;
          break;
        case binary_format_contract_1.WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case binary_format_contract_1.WireType.StartGroup:
          let t;
          while ((t = this.tag()[1]) !== binary_format_contract_1.WireType.EndGroup) {
            this.skip(t);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    assertBounds() {
      if (this.pos > this.len)
        throw new RangeError("premature EOF");
    }
    int32() {
      return this.uint32() | 0;
    }
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    int64() {
      return new pb_long_1.PbLong(...this.varint64());
    }
    uint64() {
      return new pb_long_1.PbULong(...this.varint64());
    }
    sint64() {
      let [lo, hi] = this.varint64();
      let s = -(lo & 1);
      lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
      hi = hi >>> 1 ^ s;
      return new pb_long_1.PbLong(lo, hi);
    }
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    fixed64() {
      return new pb_long_1.PbULong(this.sfixed32(), this.sfixed32());
    }
    sfixed64() {
      return new pb_long_1.PbLong(this.sfixed32(), this.sfixed32());
    }
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    bytes() {
      let len = this.uint32();
      let start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  }
  exports.BinaryReader = BinaryReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/assert.js
var require_assert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertFloat32 = exports.assertUInt32 = exports.assertInt32 = exports.assertNever = exports.assert = undefined;
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  exports.assert = assert;
  function assertNever(value, msg) {
    throw new Error(msg !== null && msg !== undefined ? msg : "Unexpected object: " + value);
  }
  exports.assertNever = assertNever;
  var FLOAT32_MAX = 340282346638528860000000000000000000000;
  var FLOAT32_MIN = -340282346638528860000000000000000000000;
  var UINT32_MAX = 4294967295;
  var INT32_MAX = 2147483647;
  var INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  exports.assertInt32 = assertInt32;
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  exports.assertUInt32 = assertUInt32;
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }
  exports.assertFloat32 = assertFloat32;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-writer.js
var require_binary_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BinaryWriter = exports.binaryWriteOptions = undefined;
  var pb_long_1 = require_pb_long();
  var goog_varint_1 = require_goog_varint();
  var assert_1 = require_assert();
  var defaultsWrite = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter
  };
  function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
  }
  exports.binaryWriteOptions = binaryWriteOptions;

  class BinaryWriter {
    constructor(textEncoder) {
      this.stack = [];
      this.textEncoder = textEncoder !== null && textEncoder !== undefined ? textEncoder : new TextEncoder;
      this.chunks = [];
      this.buf = [];
    }
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i = 0;i < this.chunks.length; i++)
        len += this.chunks[i].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i = 0;i < this.chunks.length; i++) {
        bytes.set(this.chunks[i], offset);
        offset += this.chunks[i].length;
      }
      this.chunks = [];
      return bytes;
    }
    fork() {
      this.stack.push({ chunks: this.chunks, buf: this.buf });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    join() {
      let chunk = this.finish();
      let prev = this.stack.pop();
      if (!prev)
        throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    uint32(value) {
      assert_1.assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    int32(value) {
      assert_1.assertInt32(value);
      goog_varint_1.varint32write(value, this.buf);
      return this;
    }
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    float(value) {
      assert_1.assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    fixed32(value) {
      assert_1.assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    sfixed32(value) {
      assert_1.assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    sint32(value) {
      assert_1.assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      goog_varint_1.varint32write(value, this.buf);
      return this;
    }
    sfixed64(value) {
      let chunk = new Uint8Array(8);
      let view = new DataView(chunk.buffer);
      let long = pb_long_1.PbLong.from(value);
      view.setInt32(0, long.lo, true);
      view.setInt32(4, long.hi, true);
      return this.raw(chunk);
    }
    fixed64(value) {
      let chunk = new Uint8Array(8);
      let view = new DataView(chunk.buffer);
      let long = pb_long_1.PbULong.from(value);
      view.setInt32(0, long.lo, true);
      view.setInt32(4, long.hi, true);
      return this.raw(chunk);
    }
    int64(value) {
      let long = pb_long_1.PbLong.from(value);
      goog_varint_1.varint64write(long.lo, long.hi, this.buf);
      return this;
    }
    sint64(value) {
      let long = pb_long_1.PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi = (long.hi << 1 | long.lo >>> 31) ^ sign;
      goog_varint_1.varint64write(lo, hi, this.buf);
      return this;
    }
    uint64(value) {
      let long = pb_long_1.PbULong.from(value);
      goog_varint_1.varint64write(long.lo, long.hi, this.buf);
      return this;
    }
  }
  exports.BinaryWriter = BinaryWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/json-format-contract.js
var require_json_format_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeJsonOptions = exports.jsonWriteOptions = exports.jsonReadOptions = undefined;
  var defaultsWrite = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
  };
  var defaultsRead = {
    ignoreUnknownFields: false
  };
  function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
  }
  exports.jsonReadOptions = jsonReadOptions;
  function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
  }
  exports.jsonWriteOptions = jsonWriteOptions;
  function mergeJsonOptions(a, b) {
    var _a, _b;
    let c = Object.assign(Object.assign({}, a), b);
    c.typeRegistry = [...(_a = a === null || a === undefined ? undefined : a.typeRegistry) !== null && _a !== undefined ? _a : [], ...(_b = b === null || b === undefined ? undefined : b.typeRegistry) !== null && _b !== undefined ? _b : []];
    return c;
  }
  exports.mergeJsonOptions = mergeJsonOptions;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/message-type-contract.js
var require_message_type_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MESSAGE_TYPE = undefined;
  exports.MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");
});

// node_modules/@protobuf-ts/runtime/build/commonjs/lower-camel-case.js
var require_lower_camel_case = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lowerCamelCase = undefined;
  function lowerCamelCase(snakeCase) {
    let capNext = false;
    const sb = [];
    for (let i = 0;i < snakeCase.length; i++) {
      let next = snakeCase.charAt(i);
      if (next == "_") {
        capNext = true;
      } else if (/\d/.test(next)) {
        sb.push(next);
        capNext = true;
      } else if (capNext) {
        sb.push(next.toUpperCase());
        capNext = false;
      } else if (i == 0) {
        sb.push(next.toLowerCase());
      } else {
        sb.push(next);
      }
    }
    return sb.join("");
  }
  exports.lowerCamelCase = lowerCamelCase;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-info.js
var require_reflection_info = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readMessageOption = exports.readFieldOption = exports.readFieldOptions = exports.normalizeFieldInfo = exports.RepeatType = exports.LongType = exports.ScalarType = undefined;
  var lower_camel_case_1 = require_lower_camel_case();
  var ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
    ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
    ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
    ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
    ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
    ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
    ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
    ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
    ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
    ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
    ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
    ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
    ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
    ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
    ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
  })(ScalarType = exports.ScalarType || (exports.ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
    LongType2[LongType2["STRING"] = 1] = "STRING";
    LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
  })(LongType = exports.LongType || (exports.LongType = {}));
  var RepeatType;
  (function(RepeatType2) {
    RepeatType2[RepeatType2["NO"] = 0] = "NO";
    RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
    RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
  })(RepeatType = exports.RepeatType || (exports.RepeatType = {}));
  function normalizeFieldInfo(field) {
    var _a, _b, _c, _d;
    field.localName = (_a = field.localName) !== null && _a !== undefined ? _a : lower_camel_case_1.lowerCamelCase(field.name);
    field.jsonName = (_b = field.jsonName) !== null && _b !== undefined ? _b : lower_camel_case_1.lowerCamelCase(field.name);
    field.repeat = (_c = field.repeat) !== null && _c !== undefined ? _c : RepeatType.NO;
    field.opt = (_d = field.opt) !== null && _d !== undefined ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
    return field;
  }
  exports.normalizeFieldInfo = normalizeFieldInfo;
  function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === undefined ? undefined : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
  }
  exports.readFieldOptions = readFieldOptions;
  function readFieldOption(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === undefined ? undefined : _a.options;
    if (!options) {
      return;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readFieldOption = readFieldOption;
  function readMessageOption(messageType, extensionName, extensionType) {
    const options = messageType.options;
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readMessageOption = readMessageOption;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/oneof.js
var require_oneof = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSelectedOneofValue = exports.clearOneofValue = exports.setUnknownOneofValue = exports.setOneofValue = exports.getOneofValue = exports.isOneofGroup = undefined;
  function isOneofGroup(any) {
    if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
      return false;
    }
    switch (typeof any.oneofKind) {
      case "string":
        if (any[any.oneofKind] === undefined)
          return false;
        return Object.keys(any).length == 2;
      case "undefined":
        return Object.keys(any).length == 1;
      default:
        return false;
    }
  }
  exports.isOneofGroup = isOneofGroup;
  function getOneofValue(oneof, kind) {
    return oneof[kind];
  }
  exports.getOneofValue = getOneofValue;
  function setOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
      delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined) {
      oneof[kind] = value;
    }
  }
  exports.setOneofValue = setOneofValue;
  function setUnknownOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
      delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined && kind !== undefined) {
      oneof[kind] = value;
    }
  }
  exports.setUnknownOneofValue = setUnknownOneofValue;
  function clearOneofValue(oneof) {
    if (oneof.oneofKind !== undefined) {
      delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = undefined;
  }
  exports.clearOneofValue = clearOneofValue;
  function getSelectedOneofValue(oneof) {
    if (oneof.oneofKind === undefined) {
      return;
    }
    return oneof[oneof.oneofKind];
  }
  exports.getSelectedOneofValue = getSelectedOneofValue;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-type-check.js
var require_reflection_type_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionTypeCheck = undefined;
  var reflection_info_1 = require_reflection_info();
  var oneof_1 = require_oneof();

  class ReflectionTypeCheck {
    constructor(info) {
      var _a;
      this.fields = (_a = info.fields) !== null && _a !== undefined ? _a : [];
    }
    prepare() {
      if (this.data)
        return;
      const req = [], known = [], oneofs = [];
      for (let field of this.fields) {
        if (field.oneof) {
          if (!oneofs.includes(field.oneof)) {
            oneofs.push(field.oneof);
            req.push(field.oneof);
            known.push(field.oneof);
          }
        } else {
          known.push(field.localName);
          switch (field.kind) {
            case "scalar":
            case "enum":
              if (!field.opt || field.repeat)
                req.push(field.localName);
              break;
            case "message":
              if (field.repeat)
                req.push(field.localName);
              break;
            case "map":
              req.push(field.localName);
              break;
          }
        }
      }
      this.data = { req, known, oneofs: Object.values(oneofs) };
    }
    is(message, depth, allowExcessProperties = false) {
      if (depth < 0)
        return true;
      if (message === null || message === undefined || typeof message != "object")
        return false;
      this.prepare();
      let keys = Object.keys(message), data = this.data;
      if (keys.length < data.req.length || data.req.some((n) => !keys.includes(n)))
        return false;
      if (!allowExcessProperties) {
        if (keys.some((k) => !data.known.includes(k)))
          return false;
      }
      if (depth < 1) {
        return true;
      }
      for (const name of data.oneofs) {
        const group = message[name];
        if (!oneof_1.isOneofGroup(group))
          return false;
        if (group.oneofKind === undefined)
          continue;
        const field = this.fields.find((f) => f.localName === group.oneofKind);
        if (!field)
          return false;
        if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
          return false;
      }
      for (const field of this.fields) {
        if (field.oneof !== undefined)
          continue;
        if (!this.field(message[field.localName], field, allowExcessProperties, depth))
          return false;
      }
      return true;
    }
    field(arg, field, allowExcessProperties, depth) {
      let repeated = field.repeat;
      switch (field.kind) {
        case "scalar":
          if (arg === undefined)
            return field.opt;
          if (repeated)
            return this.scalars(arg, field.T, depth, field.L);
          return this.scalar(arg, field.T, field.L);
        case "enum":
          if (arg === undefined)
            return field.opt;
          if (repeated)
            return this.scalars(arg, reflection_info_1.ScalarType.INT32, depth);
          return this.scalar(arg, reflection_info_1.ScalarType.INT32);
        case "message":
          if (arg === undefined)
            return true;
          if (repeated)
            return this.messages(arg, field.T(), allowExcessProperties, depth);
          return this.message(arg, field.T(), allowExcessProperties, depth);
        case "map":
          if (typeof arg != "object" || arg === null)
            return false;
          if (depth < 2)
            return true;
          if (!this.mapKeys(arg, field.K, depth))
            return false;
          switch (field.V.kind) {
            case "scalar":
              return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
            case "enum":
              return this.scalars(Object.values(arg), reflection_info_1.ScalarType.INT32, depth);
            case "message":
              return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
          }
          break;
      }
      return true;
    }
    message(arg, type, allowExcessProperties, depth) {
      if (allowExcessProperties) {
        return type.isAssignable(arg, depth);
      }
      return type.is(arg, depth);
    }
    messages(arg, type, allowExcessProperties, depth) {
      if (!Array.isArray(arg))
        return false;
      if (depth < 2)
        return true;
      if (allowExcessProperties) {
        for (let i = 0;i < arg.length && i < depth; i++)
          if (!type.isAssignable(arg[i], depth - 1))
            return false;
      } else {
        for (let i = 0;i < arg.length && i < depth; i++)
          if (!type.is(arg[i], depth - 1))
            return false;
      }
      return true;
    }
    scalar(arg, type, longType) {
      let argType = typeof arg;
      switch (type) {
        case reflection_info_1.ScalarType.UINT64:
        case reflection_info_1.ScalarType.FIXED64:
        case reflection_info_1.ScalarType.INT64:
        case reflection_info_1.ScalarType.SFIXED64:
        case reflection_info_1.ScalarType.SINT64:
          switch (longType) {
            case reflection_info_1.LongType.BIGINT:
              return argType == "bigint";
            case reflection_info_1.LongType.NUMBER:
              return argType == "number" && !isNaN(arg);
            default:
              return argType == "string";
          }
        case reflection_info_1.ScalarType.BOOL:
          return argType == "boolean";
        case reflection_info_1.ScalarType.STRING:
          return argType == "string";
        case reflection_info_1.ScalarType.BYTES:
          return arg instanceof Uint8Array;
        case reflection_info_1.ScalarType.DOUBLE:
        case reflection_info_1.ScalarType.FLOAT:
          return argType == "number" && !isNaN(arg);
        default:
          return argType == "number" && Number.isInteger(arg);
      }
    }
    scalars(arg, type, depth, longType) {
      if (!Array.isArray(arg))
        return false;
      if (depth < 2)
        return true;
      if (Array.isArray(arg)) {
        for (let i = 0;i < arg.length && i < depth; i++)
          if (!this.scalar(arg[i], type, longType))
            return false;
      }
      return true;
    }
    mapKeys(map, type, depth) {
      let keys = Object.keys(map);
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
        case reflection_info_1.ScalarType.UINT32:
          return this.scalars(keys.slice(0, depth).map((k) => parseInt(k)), type, depth);
        case reflection_info_1.ScalarType.BOOL:
          return this.scalars(keys.slice(0, depth).map((k) => k == "true" ? true : k == "false" ? false : k), type, depth);
        default:
          return this.scalars(keys, type, depth, reflection_info_1.LongType.STRING);
      }
    }
  }
  exports.ReflectionTypeCheck = ReflectionTypeCheck;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-long-convert.js
var require_reflection_long_convert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionLongConvert = undefined;
  var reflection_info_1 = require_reflection_info();
  function reflectionLongConvert(long, type) {
    switch (type) {
      case reflection_info_1.LongType.BIGINT:
        return long.toBigInt();
      case reflection_info_1.LongType.NUMBER:
        return long.toNumber();
      default:
        return long.toString();
    }
  }
  exports.reflectionLongConvert = reflectionLongConvert;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-json-reader.js
var require_reflection_json_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionJsonReader = undefined;
  var json_typings_1 = require_json_typings();
  var base64_1 = require_base642();
  var reflection_info_1 = require_reflection_info();
  var pb_long_1 = require_pb_long();
  var assert_1 = require_assert();
  var reflection_long_convert_1 = require_reflection_long_convert();

  class ReflectionJsonReader {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      var _a;
      if (this.fMap === undefined) {
        this.fMap = {};
        const fieldsInput = (_a = this.info.fields) !== null && _a !== undefined ? _a : [];
        for (const field of fieldsInput) {
          this.fMap[field.name] = field;
          this.fMap[field.jsonName] = field;
          this.fMap[field.localName] = field;
        }
      }
    }
    assert(condition, fieldName, jsonValue) {
      if (!condition) {
        let what = json_typings_1.typeofJsonValue(jsonValue);
        if (what == "number" || what == "boolean")
          what = jsonValue.toString();
        throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
      }
    }
    read(input, message, options) {
      this.prepare();
      const oneofsHandled = [];
      for (const [jsonKey, jsonValue] of Object.entries(input)) {
        const field = this.fMap[jsonKey];
        if (!field) {
          if (!options.ignoreUnknownFields)
            throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
          continue;
        }
        const localName = field.localName;
        let target;
        if (field.oneof) {
          if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
            continue;
          }
          if (oneofsHandled.includes(field.oneof))
            throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
          oneofsHandled.push(field.oneof);
          target = message[field.oneof] = {
            oneofKind: localName
          };
        } else {
          target = message;
        }
        if (field.kind == "map") {
          if (jsonValue === null) {
            continue;
          }
          this.assert(json_typings_1.isJsonObject(jsonValue), field.name, jsonValue);
          const fieldObj = target[localName];
          for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
            this.assert(jsonObjValue !== null, field.name + " map value", null);
            let val;
            switch (field.V.kind) {
              case "message":
                val = field.V.T().internalJsonRead(jsonObjValue, options);
                break;
              case "enum":
                val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                if (val === false)
                  continue;
                break;
              case "scalar":
                val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                break;
            }
            this.assert(val !== undefined, field.name + " map value", jsonObjValue);
            let key = jsonObjKey;
            if (field.K == reflection_info_1.ScalarType.BOOL)
              key = key == "true" ? true : key == "false" ? false : key;
            key = this.scalar(key, field.K, reflection_info_1.LongType.STRING, field.name).toString();
            fieldObj[key] = val;
          }
        } else if (field.repeat) {
          if (jsonValue === null)
            continue;
          this.assert(Array.isArray(jsonValue), field.name, jsonValue);
          const fieldArr = target[localName];
          for (const jsonItem of jsonValue) {
            this.assert(jsonItem !== null, field.name, null);
            let val;
            switch (field.kind) {
              case "message":
                val = field.T().internalJsonRead(jsonItem, options);
                break;
              case "enum":
                val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                if (val === false)
                  continue;
                break;
              case "scalar":
                val = this.scalar(jsonItem, field.T, field.L, field.name);
                break;
            }
            this.assert(val !== undefined, field.name, jsonValue);
            fieldArr.push(val);
          }
        } else {
          switch (field.kind) {
            case "message":
              if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
                this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                continue;
              }
              target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
              break;
            case "enum":
              let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              target[localName] = val;
              break;
            case "scalar":
              target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
              break;
          }
        }
      }
    }
    enum(type, json, fieldName, ignoreUnknownFields) {
      if (type[0] == "google.protobuf.NullValue")
        assert_1.assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
      if (json === null)
        return 0;
      switch (typeof json) {
        case "number":
          assert_1.assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
          return json;
        case "string":
          let localEnumName = json;
          if (type[2] && json.substring(0, type[2].length) === type[2])
            localEnumName = json.substring(type[2].length);
          let enumNumber = type[1][localEnumName];
          if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
            return false;
          }
          assert_1.assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
          return enumNumber;
      }
      assert_1.assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type, longType, fieldName) {
      let e;
      try {
        switch (type) {
          case reflection_info_1.ScalarType.DOUBLE:
          case reflection_info_1.ScalarType.FLOAT:
            if (json === null)
              return 0;
            if (json === "NaN")
              return Number.NaN;
            if (json === "Infinity")
              return Number.POSITIVE_INFINITY;
            if (json === "-Infinity")
              return Number.NEGATIVE_INFINITY;
            if (json === "") {
              e = "empty string";
              break;
            }
            if (typeof json == "string" && json.trim().length !== json.length) {
              e = "extra whitespace";
              break;
            }
            if (typeof json != "string" && typeof json != "number") {
              break;
            }
            let float = Number(json);
            if (Number.isNaN(float)) {
              e = "not a number";
              break;
            }
            if (!Number.isFinite(float)) {
              e = "too large or small";
              break;
            }
            if (type == reflection_info_1.ScalarType.FLOAT)
              assert_1.assertFloat32(float);
            return float;
          case reflection_info_1.ScalarType.INT32:
          case reflection_info_1.ScalarType.FIXED32:
          case reflection_info_1.ScalarType.SFIXED32:
          case reflection_info_1.ScalarType.SINT32:
          case reflection_info_1.ScalarType.UINT32:
            if (json === null)
              return 0;
            let int32;
            if (typeof json == "number")
              int32 = json;
            else if (json === "")
              e = "empty string";
            else if (typeof json == "string") {
              if (json.trim().length !== json.length)
                e = "extra whitespace";
              else
                int32 = Number(json);
            }
            if (int32 === undefined)
              break;
            if (type == reflection_info_1.ScalarType.UINT32)
              assert_1.assertUInt32(int32);
            else
              assert_1.assertInt32(int32);
            return int32;
          case reflection_info_1.ScalarType.INT64:
          case reflection_info_1.ScalarType.SFIXED64:
          case reflection_info_1.ScalarType.SINT64:
            if (json === null)
              return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.ZERO, longType);
            if (typeof json != "number" && typeof json != "string")
              break;
            return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.from(json), longType);
          case reflection_info_1.ScalarType.FIXED64:
          case reflection_info_1.ScalarType.UINT64:
            if (json === null)
              return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.ZERO, longType);
            if (typeof json != "number" && typeof json != "string")
              break;
            return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.from(json), longType);
          case reflection_info_1.ScalarType.BOOL:
            if (json === null)
              return false;
            if (typeof json !== "boolean")
              break;
            return json;
          case reflection_info_1.ScalarType.STRING:
            if (json === null)
              return "";
            if (typeof json !== "string") {
              e = "extra whitespace";
              break;
            }
            try {
              encodeURIComponent(json);
            } catch (e2) {
              e2 = "invalid UTF8";
              break;
            }
            return json;
          case reflection_info_1.ScalarType.BYTES:
            if (json === null || json === "")
              return new Uint8Array(0);
            if (typeof json !== "string")
              break;
            return base64_1.base64decode(json);
        }
      } catch (error) {
        e = error.message;
      }
      this.assert(false, fieldName + (e ? " - " + e : ""), json);
    }
  }
  exports.ReflectionJsonReader = ReflectionJsonReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-json-writer.js
var require_reflection_json_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionJsonWriter = undefined;
  var base64_1 = require_base642();
  var pb_long_1 = require_pb_long();
  var reflection_info_1 = require_reflection_info();
  var assert_1 = require_assert();

  class ReflectionJsonWriter {
    constructor(info) {
      var _a;
      this.fields = (_a = info.fields) !== null && _a !== undefined ? _a : [];
    }
    write(message, options) {
      const json = {}, source = message;
      for (const field of this.fields) {
        if (!field.oneof) {
          let jsonValue2 = this.field(field, source[field.localName], options);
          if (jsonValue2 !== undefined)
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
          continue;
        }
        const group = source[field.oneof];
        if (group.oneofKind !== field.localName)
          continue;
        const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
        let jsonValue = this.field(field, group[field.localName], opt);
        assert_1.assert(jsonValue !== undefined);
        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
      }
      return json;
    }
    field(field, value, options) {
      let jsonValue = undefined;
      if (field.kind == "map") {
        assert_1.assert(typeof value == "object" && value !== null);
        const jsonObj = {};
        switch (field.V.kind) {
          case "scalar":
            for (const [entryKey, entryValue] of Object.entries(value)) {
              const val = this.scalar(field.V.T, entryValue, field.name, false, true);
              assert_1.assert(val !== undefined);
              jsonObj[entryKey.toString()] = val;
            }
            break;
          case "message":
            const messageType = field.V.T();
            for (const [entryKey, entryValue] of Object.entries(value)) {
              const val = this.message(messageType, entryValue, field.name, options);
              assert_1.assert(val !== undefined);
              jsonObj[entryKey.toString()] = val;
            }
            break;
          case "enum":
            const enumInfo = field.V.T();
            for (const [entryKey, entryValue] of Object.entries(value)) {
              assert_1.assert(entryValue === undefined || typeof entryValue == "number");
              const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
              assert_1.assert(val !== undefined);
              jsonObj[entryKey.toString()] = val;
            }
            break;
        }
        if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
          jsonValue = jsonObj;
      } else if (field.repeat) {
        assert_1.assert(Array.isArray(value));
        const jsonArr = [];
        switch (field.kind) {
          case "scalar":
            for (let i = 0;i < value.length; i++) {
              const val = this.scalar(field.T, value[i], field.name, field.opt, true);
              assert_1.assert(val !== undefined);
              jsonArr.push(val);
            }
            break;
          case "enum":
            const enumInfo = field.T();
            for (let i = 0;i < value.length; i++) {
              assert_1.assert(value[i] === undefined || typeof value[i] == "number");
              const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
              assert_1.assert(val !== undefined);
              jsonArr.push(val);
            }
            break;
          case "message":
            const messageType = field.T();
            for (let i = 0;i < value.length; i++) {
              const val = this.message(messageType, value[i], field.name, options);
              assert_1.assert(val !== undefined);
              jsonArr.push(val);
            }
            break;
        }
        if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
          jsonValue = jsonArr;
      } else {
        switch (field.kind) {
          case "scalar":
            jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
            break;
          case "enum":
            jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
            break;
          case "message":
            jsonValue = this.message(field.T(), value, field.name, options);
            break;
        }
      }
      return jsonValue;
    }
    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
      if (type[0] == "google.protobuf.NullValue")
        return !emitDefaultValues && !optional ? undefined : null;
      if (value === undefined) {
        assert_1.assert(optional);
        return;
      }
      if (value === 0 && !emitDefaultValues && !optional)
        return;
      assert_1.assert(typeof value == "number");
      assert_1.assert(Number.isInteger(value));
      if (enumAsInteger || !type[1].hasOwnProperty(value))
        return value;
      if (type[2])
        return type[2] + type[1][value];
      return type[1][value];
    }
    message(type, value, fieldName, options) {
      if (value === undefined)
        return options.emitDefaultValues ? null : undefined;
      return type.internalJsonWrite(value, options);
    }
    scalar(type, value, fieldName, optional, emitDefaultValues) {
      if (value === undefined) {
        assert_1.assert(optional);
        return;
      }
      const ed = emitDefaultValues || optional;
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
          if (value === 0)
            return ed ? 0 : undefined;
          assert_1.assertInt32(value);
          return value;
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.UINT32:
          if (value === 0)
            return ed ? 0 : undefined;
          assert_1.assertUInt32(value);
          return value;
        case reflection_info_1.ScalarType.FLOAT:
          assert_1.assertFloat32(value);
        case reflection_info_1.ScalarType.DOUBLE:
          if (value === 0)
            return ed ? 0 : undefined;
          assert_1.assert(typeof value == "number");
          if (Number.isNaN(value))
            return "NaN";
          if (value === Number.POSITIVE_INFINITY)
            return "Infinity";
          if (value === Number.NEGATIVE_INFINITY)
            return "-Infinity";
          return value;
        case reflection_info_1.ScalarType.STRING:
          if (value === "")
            return ed ? "" : undefined;
          assert_1.assert(typeof value == "string");
          return value;
        case reflection_info_1.ScalarType.BOOL:
          if (value === false)
            return ed ? false : undefined;
          assert_1.assert(typeof value == "boolean");
          return value;
        case reflection_info_1.ScalarType.UINT64:
        case reflection_info_1.ScalarType.FIXED64:
          assert_1.assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
          let ulong = pb_long_1.PbULong.from(value);
          if (ulong.isZero() && !ed)
            return;
          return ulong.toString();
        case reflection_info_1.ScalarType.INT64:
        case reflection_info_1.ScalarType.SFIXED64:
        case reflection_info_1.ScalarType.SINT64:
          assert_1.assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
          let long = pb_long_1.PbLong.from(value);
          if (long.isZero() && !ed)
            return;
          return long.toString();
        case reflection_info_1.ScalarType.BYTES:
          assert_1.assert(value instanceof Uint8Array);
          if (!value.byteLength)
            return ed ? "" : undefined;
          return base64_1.base64encode(value);
      }
    }
  }
  exports.ReflectionJsonWriter = ReflectionJsonWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-scalar-default.js
var require_reflection_scalar_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionScalarDefault = undefined;
  var reflection_info_1 = require_reflection_info();
  var reflection_long_convert_1 = require_reflection_long_convert();
  var pb_long_1 = require_pb_long();
  function reflectionScalarDefault(type, longType = reflection_info_1.LongType.STRING) {
    switch (type) {
      case reflection_info_1.ScalarType.BOOL:
        return false;
      case reflection_info_1.ScalarType.UINT64:
      case reflection_info_1.ScalarType.FIXED64:
        return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.ZERO, longType);
      case reflection_info_1.ScalarType.INT64:
      case reflection_info_1.ScalarType.SFIXED64:
      case reflection_info_1.ScalarType.SINT64:
        return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.ZERO, longType);
      case reflection_info_1.ScalarType.DOUBLE:
      case reflection_info_1.ScalarType.FLOAT:
        return 0;
      case reflection_info_1.ScalarType.BYTES:
        return new Uint8Array(0);
      case reflection_info_1.ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  exports.reflectionScalarDefault = reflectionScalarDefault;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-binary-reader.js
var require_reflection_binary_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionBinaryReader = undefined;
  var binary_format_contract_1 = require_binary_format_contract();
  var reflection_info_1 = require_reflection_info();
  var reflection_long_convert_1 = require_reflection_long_convert();
  var reflection_scalar_default_1 = require_reflection_scalar_default();

  class ReflectionBinaryReader {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      var _a;
      if (!this.fieldNoToField) {
        const fieldsInput = (_a = this.info.fields) !== null && _a !== undefined ? _a : [];
        this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
      }
    }
    read(reader, message, options, length) {
      this.prepare();
      const end = length === undefined ? reader.len : reader.pos + length;
      while (reader.pos < end) {
        const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
        if (!field) {
          let u = options.readUnknownField;
          if (u == "throw")
            throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? binary_format_contract_1.UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
          continue;
        }
        let target = message, repeated = field.repeat, localName = field.localName;
        if (field.oneof) {
          target = target[field.oneof];
          if (target.oneofKind !== localName)
            target = message[field.oneof] = {
              oneofKind: localName
            };
        }
        switch (field.kind) {
          case "scalar":
          case "enum":
            let T = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
            let L = field.kind == "scalar" ? field.L : undefined;
            if (repeated) {
              let arr = target[localName];
              if (wireType == binary_format_contract_1.WireType.LengthDelimited && T != reflection_info_1.ScalarType.STRING && T != reflection_info_1.ScalarType.BYTES) {
                let e = reader.uint32() + reader.pos;
                while (reader.pos < e)
                  arr.push(this.scalar(reader, T, L));
              } else
                arr.push(this.scalar(reader, T, L));
            } else
              target[localName] = this.scalar(reader, T, L);
            break;
          case "message":
            if (repeated) {
              let arr = target[localName];
              let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
              arr.push(msg);
            } else
              target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
            break;
          case "map":
            let [mapKey, mapVal] = this.mapEntry(field, reader, options);
            target[localName][mapKey] = mapVal;
            break;
        }
      }
    }
    mapEntry(field, reader, options) {
      let length = reader.uint32();
      let end = reader.pos + length;
      let key = undefined;
      let val = undefined;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            if (field.K == reflection_info_1.ScalarType.BOOL)
              key = reader.bool().toString();
            else
              key = this.scalar(reader, field.K, reflection_info_1.LongType.STRING);
            break;
          case 2:
            switch (field.V.kind) {
              case "scalar":
                val = this.scalar(reader, field.V.T, field.V.L);
                break;
              case "enum":
                val = reader.int32();
                break;
              case "message":
                val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                break;
            }
            break;
          default:
            throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
        }
      }
      if (key === undefined) {
        let keyRaw = reflection_scalar_default_1.reflectionScalarDefault(field.K);
        key = field.K == reflection_info_1.ScalarType.BOOL ? keyRaw.toString() : keyRaw;
      }
      if (val === undefined)
        switch (field.V.kind) {
          case "scalar":
            val = reflection_scalar_default_1.reflectionScalarDefault(field.V.T, field.V.L);
            break;
          case "enum":
            val = 0;
            break;
          case "message":
            val = field.V.T().create();
            break;
        }
      return [key, val];
    }
    scalar(reader, type, longType) {
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
          return reader.int32();
        case reflection_info_1.ScalarType.STRING:
          return reader.string();
        case reflection_info_1.ScalarType.BOOL:
          return reader.bool();
        case reflection_info_1.ScalarType.DOUBLE:
          return reader.double();
        case reflection_info_1.ScalarType.FLOAT:
          return reader.float();
        case reflection_info_1.ScalarType.INT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.int64(), longType);
        case reflection_info_1.ScalarType.UINT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.uint64(), longType);
        case reflection_info_1.ScalarType.FIXED64:
          return reflection_long_convert_1.reflectionLongConvert(reader.fixed64(), longType);
        case reflection_info_1.ScalarType.FIXED32:
          return reader.fixed32();
        case reflection_info_1.ScalarType.BYTES:
          return reader.bytes();
        case reflection_info_1.ScalarType.UINT32:
          return reader.uint32();
        case reflection_info_1.ScalarType.SFIXED32:
          return reader.sfixed32();
        case reflection_info_1.ScalarType.SFIXED64:
          return reflection_long_convert_1.reflectionLongConvert(reader.sfixed64(), longType);
        case reflection_info_1.ScalarType.SINT32:
          return reader.sint32();
        case reflection_info_1.ScalarType.SINT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.sint64(), longType);
      }
    }
  }
  exports.ReflectionBinaryReader = ReflectionBinaryReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-binary-writer.js
var require_reflection_binary_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionBinaryWriter = undefined;
  var binary_format_contract_1 = require_binary_format_contract();
  var reflection_info_1 = require_reflection_info();
  var assert_1 = require_assert();
  var pb_long_1 = require_pb_long();

  class ReflectionBinaryWriter {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      if (!this.fields) {
        const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
        this.fields = fieldsInput.sort((a, b) => a.no - b.no);
      }
    }
    write(message, writer, options) {
      this.prepare();
      for (const field of this.fields) {
        let value, emitDefault, repeated = field.repeat, localName = field.localName;
        if (field.oneof) {
          const group = message[field.oneof];
          if (group.oneofKind !== localName)
            continue;
          value = group[localName];
          emitDefault = true;
        } else {
          value = message[localName];
          emitDefault = false;
        }
        switch (field.kind) {
          case "scalar":
          case "enum":
            let T = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
            if (repeated) {
              assert_1.assert(Array.isArray(value));
              if (repeated == reflection_info_1.RepeatType.PACKED)
                this.packed(writer, T, field.no, value);
              else
                for (const item of value)
                  this.scalar(writer, T, field.no, item, true);
            } else if (value === undefined)
              assert_1.assert(field.opt);
            else
              this.scalar(writer, T, field.no, value, emitDefault || field.opt);
            break;
          case "message":
            if (repeated) {
              assert_1.assert(Array.isArray(value));
              for (const item of value)
                this.message(writer, options, field.T(), field.no, item);
            } else {
              this.message(writer, options, field.T(), field.no, value);
            }
            break;
          case "map":
            assert_1.assert(typeof value == "object" && value !== null);
            for (const [key, val] of Object.entries(value))
              this.mapEntry(writer, options, field, key, val);
            break;
        }
      }
      let u = options.writeUnknownFields;
      if (u !== false)
        (u === true ? binary_format_contract_1.UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
      writer.tag(field.no, binary_format_contract_1.WireType.LengthDelimited);
      writer.fork();
      let keyValue = key;
      switch (field.K) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.UINT32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
          keyValue = Number.parseInt(key);
          break;
        case reflection_info_1.ScalarType.BOOL:
          assert_1.assert(key == "true" || key == "false");
          keyValue = key == "true";
          break;
      }
      this.scalar(writer, field.K, 1, keyValue, true);
      switch (field.V.kind) {
        case "scalar":
          this.scalar(writer, field.V.T, 2, value, true);
          break;
        case "enum":
          this.scalar(writer, reflection_info_1.ScalarType.INT32, 2, value, true);
          break;
        case "message":
          this.message(writer, options, field.V.T(), 2, value);
          break;
      }
      writer.join();
    }
    message(writer, options, handler, fieldNo, value) {
      if (value === undefined)
        return;
      handler.internalBinaryWrite(value, writer.tag(fieldNo, binary_format_contract_1.WireType.LengthDelimited).fork(), options);
      writer.join();
    }
    scalar(writer, type, fieldNo, value, emitDefault) {
      let [wireType, method, isDefault] = this.scalarInfo(type, value);
      if (!isDefault || emitDefault) {
        writer.tag(fieldNo, wireType);
        writer[method](value);
      }
    }
    packed(writer, type, fieldNo, value) {
      if (!value.length)
        return;
      assert_1.assert(type !== reflection_info_1.ScalarType.BYTES && type !== reflection_info_1.ScalarType.STRING);
      writer.tag(fieldNo, binary_format_contract_1.WireType.LengthDelimited);
      writer.fork();
      let [, method] = this.scalarInfo(type);
      for (let i = 0;i < value.length; i++)
        writer[method](value[i]);
      writer.join();
    }
    scalarInfo(type, value) {
      let t = binary_format_contract_1.WireType.Varint;
      let m;
      let i = value === undefined;
      let d = value === 0;
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
          m = "int32";
          break;
        case reflection_info_1.ScalarType.STRING:
          d = i || !value.length;
          t = binary_format_contract_1.WireType.LengthDelimited;
          m = "string";
          break;
        case reflection_info_1.ScalarType.BOOL:
          d = value === false;
          m = "bool";
          break;
        case reflection_info_1.ScalarType.UINT32:
          m = "uint32";
          break;
        case reflection_info_1.ScalarType.DOUBLE:
          t = binary_format_contract_1.WireType.Bit64;
          m = "double";
          break;
        case reflection_info_1.ScalarType.FLOAT:
          t = binary_format_contract_1.WireType.Bit32;
          m = "float";
          break;
        case reflection_info_1.ScalarType.INT64:
          d = i || pb_long_1.PbLong.from(value).isZero();
          m = "int64";
          break;
        case reflection_info_1.ScalarType.UINT64:
          d = i || pb_long_1.PbULong.from(value).isZero();
          m = "uint64";
          break;
        case reflection_info_1.ScalarType.FIXED64:
          d = i || pb_long_1.PbULong.from(value).isZero();
          t = binary_format_contract_1.WireType.Bit64;
          m = "fixed64";
          break;
        case reflection_info_1.ScalarType.BYTES:
          d = i || !value.byteLength;
          t = binary_format_contract_1.WireType.LengthDelimited;
          m = "bytes";
          break;
        case reflection_info_1.ScalarType.FIXED32:
          t = binary_format_contract_1.WireType.Bit32;
          m = "fixed32";
          break;
        case reflection_info_1.ScalarType.SFIXED32:
          t = binary_format_contract_1.WireType.Bit32;
          m = "sfixed32";
          break;
        case reflection_info_1.ScalarType.SFIXED64:
          d = i || pb_long_1.PbLong.from(value).isZero();
          t = binary_format_contract_1.WireType.Bit64;
          m = "sfixed64";
          break;
        case reflection_info_1.ScalarType.SINT32:
          m = "sint32";
          break;
        case reflection_info_1.ScalarType.SINT64:
          d = i || pb_long_1.PbLong.from(value).isZero();
          m = "sint64";
          break;
      }
      return [t, m, i || d];
    }
  }
  exports.ReflectionBinaryWriter = ReflectionBinaryWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-create.js
var require_reflection_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionCreate = undefined;
  var reflection_scalar_default_1 = require_reflection_scalar_default();
  var message_type_contract_1 = require_message_type_contract();
  function reflectionCreate(type) {
    const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, message_type_contract_1.MESSAGE_TYPE, { value: type });
    for (let field of type.fields) {
      let name = field.localName;
      if (field.opt)
        continue;
      if (field.oneof)
        msg[field.oneof] = { oneofKind: undefined };
      else if (field.repeat)
        msg[name] = [];
      else
        switch (field.kind) {
          case "scalar":
            msg[name] = reflection_scalar_default_1.reflectionScalarDefault(field.T, field.L);
            break;
          case "enum":
            msg[name] = 0;
            break;
          case "map":
            msg[name] = {};
            break;
        }
    }
    return msg;
  }
  exports.reflectionCreate = reflectionCreate;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-merge-partial.js
var require_reflection_merge_partial = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionMergePartial = undefined;
  function reflectionMergePartial(info, target, source) {
    let fieldValue, input = source, output;
    for (let field of info.fields) {
      let name = field.localName;
      if (field.oneof) {
        const group = input[field.oneof];
        if ((group === null || group === undefined ? undefined : group.oneofKind) == undefined) {
          continue;
        }
        fieldValue = group[name];
        output = target[field.oneof];
        output.oneofKind = group.oneofKind;
        if (fieldValue == undefined) {
          delete output[name];
          continue;
        }
      } else {
        fieldValue = input[name];
        output = target;
        if (fieldValue == undefined) {
          continue;
        }
      }
      if (field.repeat)
        output[name].length = fieldValue.length;
      switch (field.kind) {
        case "scalar":
        case "enum":
          if (field.repeat)
            for (let i = 0;i < fieldValue.length; i++)
              output[name][i] = fieldValue[i];
          else
            output[name] = fieldValue;
          break;
        case "message":
          let T = field.T();
          if (field.repeat)
            for (let i = 0;i < fieldValue.length; i++)
              output[name][i] = T.create(fieldValue[i]);
          else if (output[name] === undefined)
            output[name] = T.create(fieldValue);
          else
            T.mergePartial(output[name], fieldValue);
          break;
        case "map":
          switch (field.V.kind) {
            case "scalar":
            case "enum":
              Object.assign(output[name], fieldValue);
              break;
            case "message":
              let T2 = field.V.T();
              for (let k of Object.keys(fieldValue))
                output[name][k] = T2.create(fieldValue[k]);
              break;
          }
          break;
      }
    }
  }
  exports.reflectionMergePartial = reflectionMergePartial;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-equals.js
var require_reflection_equals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionEquals = undefined;
  var reflection_info_1 = require_reflection_info();
  function reflectionEquals(info, a, b) {
    if (a === b)
      return true;
    if (!a || !b)
      return false;
    for (let field of info.fields) {
      let localName = field.localName;
      let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
      let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
      switch (field.kind) {
        case "enum":
        case "scalar":
          let t = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
          if (!(field.repeat ? repeatedPrimitiveEq(t, val_a, val_b) : primitiveEq(t, val_a, val_b)))
            return false;
          break;
        case "map":
          if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
            return false;
          break;
        case "message":
          let T = field.T();
          if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b)))
            return false;
          break;
      }
    }
    return true;
  }
  exports.reflectionEquals = reflectionEquals;
  var objectValues = Object.values;
  function primitiveEq(type, a, b) {
    if (a === b)
      return true;
    if (type !== reflection_info_1.ScalarType.BYTES)
      return false;
    let ba = a;
    let bb = b;
    if (ba.length !== bb.length)
      return false;
    for (let i = 0;i < ba.length; i++)
      if (ba[i] != bb[i])
        return false;
    return true;
  }
  function repeatedPrimitiveEq(type, a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0;i < a.length; i++)
      if (!primitiveEq(type, a[i], b[i]))
        return false;
    return true;
  }
  function repeatedMsgEq(type, a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0;i < a.length; i++)
      if (!type.equals(a[i], b[i]))
        return false;
    return true;
  }
});

// node_modules/@protobuf-ts/runtime/build/commonjs/message-type.js
var require_message_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageType = undefined;
  var message_type_contract_1 = require_message_type_contract();
  var reflection_info_1 = require_reflection_info();
  var reflection_type_check_1 = require_reflection_type_check();
  var reflection_json_reader_1 = require_reflection_json_reader();
  var reflection_json_writer_1 = require_reflection_json_writer();
  var reflection_binary_reader_1 = require_reflection_binary_reader();
  var reflection_binary_writer_1 = require_reflection_binary_writer();
  var reflection_create_1 = require_reflection_create();
  var reflection_merge_partial_1 = require_reflection_merge_partial();
  var json_typings_1 = require_json_typings();
  var json_format_contract_1 = require_json_format_contract();
  var reflection_equals_1 = require_reflection_equals();
  var binary_writer_1 = require_binary_writer();
  var binary_reader_1 = require_binary_reader();
  var baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));

  class MessageType {
    constructor(name, fields, options) {
      this.defaultCheckDepth = 16;
      this.typeName = name;
      this.fields = fields.map(reflection_info_1.normalizeFieldInfo);
      this.options = options !== null && options !== undefined ? options : {};
      this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [message_type_contract_1.MESSAGE_TYPE]: { value: this } }));
      this.refTypeCheck = new reflection_type_check_1.ReflectionTypeCheck(this);
      this.refJsonReader = new reflection_json_reader_1.ReflectionJsonReader(this);
      this.refJsonWriter = new reflection_json_writer_1.ReflectionJsonWriter(this);
      this.refBinReader = new reflection_binary_reader_1.ReflectionBinaryReader(this);
      this.refBinWriter = new reflection_binary_writer_1.ReflectionBinaryWriter(this);
    }
    create(value) {
      let message = reflection_create_1.reflectionCreate(this);
      if (value !== undefined) {
        reflection_merge_partial_1.reflectionMergePartial(this, message, value);
      }
      return message;
    }
    clone(message) {
      let copy = this.create();
      reflection_merge_partial_1.reflectionMergePartial(this, copy, message);
      return copy;
    }
    equals(a, b) {
      return reflection_equals_1.reflectionEquals(this, a, b);
    }
    is(arg, depth = this.defaultCheckDepth) {
      return this.refTypeCheck.is(arg, depth, false);
    }
    isAssignable(arg, depth = this.defaultCheckDepth) {
      return this.refTypeCheck.is(arg, depth, true);
    }
    mergePartial(target, source) {
      reflection_merge_partial_1.reflectionMergePartial(this, target, source);
    }
    fromBinary(data, options) {
      let opt = binary_reader_1.binaryReadOptions(options);
      return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    fromJson(json, options) {
      return this.internalJsonRead(json, json_format_contract_1.jsonReadOptions(options));
    }
    fromJsonString(json, options) {
      let value = JSON.parse(json);
      return this.fromJson(value, options);
    }
    toJson(message, options) {
      return this.internalJsonWrite(message, json_format_contract_1.jsonWriteOptions(options));
    }
    toJsonString(message, options) {
      var _a;
      let value = this.toJson(message, options);
      return JSON.stringify(value, null, (_a = options === null || options === undefined ? undefined : options.prettySpaces) !== null && _a !== undefined ? _a : 0);
    }
    toBinary(message, options) {
      let opt = binary_writer_1.binaryWriteOptions(options);
      return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    internalJsonRead(json, options, target) {
      if (json !== null && typeof json == "object" && !Array.isArray(json)) {
        let message = target !== null && target !== undefined ? target : this.create();
        this.refJsonReader.read(json, message, options);
        return message;
      }
      throw new Error(`Unable to parse message ${this.typeName} from JSON ${json_typings_1.typeofJsonValue(json)}.`);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.write(message, options);
    }
    internalBinaryWrite(message, writer, options) {
      this.refBinWriter.write(message, writer, options);
      return writer;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create();
      this.refBinReader.read(reader, message, options, length);
      return message;
    }
  }
  exports.MessageType = MessageType;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-contains-message-type.js
var require_reflection_contains_message_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.containsMessageType = undefined;
  var message_type_contract_1 = require_message_type_contract();
  function containsMessageType(msg) {
    return msg[message_type_contract_1.MESSAGE_TYPE] != null;
  }
  exports.containsMessageType = containsMessageType;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/enum-object.js
var require_enum_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listEnumNumbers = exports.listEnumNames = exports.listEnumValues = exports.isEnumObject = undefined;
  function isEnumObject(arg) {
    if (typeof arg != "object" || arg === null) {
      return false;
    }
    if (!arg.hasOwnProperty(0)) {
      return false;
    }
    for (let k of Object.keys(arg)) {
      let num = parseInt(k);
      if (!Number.isNaN(num)) {
        let nam = arg[num];
        if (nam === undefined)
          return false;
        if (arg[nam] !== num)
          return false;
      } else {
        let num2 = arg[k];
        if (num2 === undefined)
          return false;
        if (typeof num2 !== "number")
          return false;
        if (arg[num2] === undefined)
          return false;
      }
    }
    return true;
  }
  exports.isEnumObject = isEnumObject;
  function listEnumValues(enumObject) {
    if (!isEnumObject(enumObject))
      throw new Error("not a typescript enum object");
    let values = [];
    for (let [name, number] of Object.entries(enumObject))
      if (typeof number == "number")
        values.push({ name, number });
    return values;
  }
  exports.listEnumValues = listEnumValues;
  function listEnumNames(enumObject) {
    return listEnumValues(enumObject).map((val) => val.name);
  }
  exports.listEnumNames = listEnumNames;
  function listEnumNumbers(enumObject) {
    return listEnumValues(enumObject).map((val) => val.number).filter((num, index, arr) => arr.indexOf(num) == index);
  }
  exports.listEnumNumbers = listEnumNumbers;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/index.js
var require_commonjs13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var json_typings_1 = require_json_typings();
  Object.defineProperty(exports, "typeofJsonValue", { enumerable: true, get: function() {
    return json_typings_1.typeofJsonValue;
  } });
  Object.defineProperty(exports, "isJsonObject", { enumerable: true, get: function() {
    return json_typings_1.isJsonObject;
  } });
  var base64_1 = require_base642();
  Object.defineProperty(exports, "base64decode", { enumerable: true, get: function() {
    return base64_1.base64decode;
  } });
  Object.defineProperty(exports, "base64encode", { enumerable: true, get: function() {
    return base64_1.base64encode;
  } });
  var protobufjs_utf8_1 = require_protobufjs_utf8();
  Object.defineProperty(exports, "utf8read", { enumerable: true, get: function() {
    return protobufjs_utf8_1.utf8read;
  } });
  var binary_format_contract_1 = require_binary_format_contract();
  Object.defineProperty(exports, "WireType", { enumerable: true, get: function() {
    return binary_format_contract_1.WireType;
  } });
  Object.defineProperty(exports, "mergeBinaryOptions", { enumerable: true, get: function() {
    return binary_format_contract_1.mergeBinaryOptions;
  } });
  Object.defineProperty(exports, "UnknownFieldHandler", { enumerable: true, get: function() {
    return binary_format_contract_1.UnknownFieldHandler;
  } });
  var binary_reader_1 = require_binary_reader();
  Object.defineProperty(exports, "BinaryReader", { enumerable: true, get: function() {
    return binary_reader_1.BinaryReader;
  } });
  Object.defineProperty(exports, "binaryReadOptions", { enumerable: true, get: function() {
    return binary_reader_1.binaryReadOptions;
  } });
  var binary_writer_1 = require_binary_writer();
  Object.defineProperty(exports, "BinaryWriter", { enumerable: true, get: function() {
    return binary_writer_1.BinaryWriter;
  } });
  Object.defineProperty(exports, "binaryWriteOptions", { enumerable: true, get: function() {
    return binary_writer_1.binaryWriteOptions;
  } });
  var pb_long_1 = require_pb_long();
  Object.defineProperty(exports, "PbLong", { enumerable: true, get: function() {
    return pb_long_1.PbLong;
  } });
  Object.defineProperty(exports, "PbULong", { enumerable: true, get: function() {
    return pb_long_1.PbULong;
  } });
  var json_format_contract_1 = require_json_format_contract();
  Object.defineProperty(exports, "jsonReadOptions", { enumerable: true, get: function() {
    return json_format_contract_1.jsonReadOptions;
  } });
  Object.defineProperty(exports, "jsonWriteOptions", { enumerable: true, get: function() {
    return json_format_contract_1.jsonWriteOptions;
  } });
  Object.defineProperty(exports, "mergeJsonOptions", { enumerable: true, get: function() {
    return json_format_contract_1.mergeJsonOptions;
  } });
  var message_type_contract_1 = require_message_type_contract();
  Object.defineProperty(exports, "MESSAGE_TYPE", { enumerable: true, get: function() {
    return message_type_contract_1.MESSAGE_TYPE;
  } });
  var message_type_1 = require_message_type();
  Object.defineProperty(exports, "MessageType", { enumerable: true, get: function() {
    return message_type_1.MessageType;
  } });
  var reflection_info_1 = require_reflection_info();
  Object.defineProperty(exports, "ScalarType", { enumerable: true, get: function() {
    return reflection_info_1.ScalarType;
  } });
  Object.defineProperty(exports, "LongType", { enumerable: true, get: function() {
    return reflection_info_1.LongType;
  } });
  Object.defineProperty(exports, "RepeatType", { enumerable: true, get: function() {
    return reflection_info_1.RepeatType;
  } });
  Object.defineProperty(exports, "normalizeFieldInfo", { enumerable: true, get: function() {
    return reflection_info_1.normalizeFieldInfo;
  } });
  Object.defineProperty(exports, "readFieldOptions", { enumerable: true, get: function() {
    return reflection_info_1.readFieldOptions;
  } });
  Object.defineProperty(exports, "readFieldOption", { enumerable: true, get: function() {
    return reflection_info_1.readFieldOption;
  } });
  Object.defineProperty(exports, "readMessageOption", { enumerable: true, get: function() {
    return reflection_info_1.readMessageOption;
  } });
  var reflection_type_check_1 = require_reflection_type_check();
  Object.defineProperty(exports, "ReflectionTypeCheck", { enumerable: true, get: function() {
    return reflection_type_check_1.ReflectionTypeCheck;
  } });
  var reflection_create_1 = require_reflection_create();
  Object.defineProperty(exports, "reflectionCreate", { enumerable: true, get: function() {
    return reflection_create_1.reflectionCreate;
  } });
  var reflection_scalar_default_1 = require_reflection_scalar_default();
  Object.defineProperty(exports, "reflectionScalarDefault", { enumerable: true, get: function() {
    return reflection_scalar_default_1.reflectionScalarDefault;
  } });
  var reflection_merge_partial_1 = require_reflection_merge_partial();
  Object.defineProperty(exports, "reflectionMergePartial", { enumerable: true, get: function() {
    return reflection_merge_partial_1.reflectionMergePartial;
  } });
  var reflection_equals_1 = require_reflection_equals();
  Object.defineProperty(exports, "reflectionEquals", { enumerable: true, get: function() {
    return reflection_equals_1.reflectionEquals;
  } });
  var reflection_binary_reader_1 = require_reflection_binary_reader();
  Object.defineProperty(exports, "ReflectionBinaryReader", { enumerable: true, get: function() {
    return reflection_binary_reader_1.ReflectionBinaryReader;
  } });
  var reflection_binary_writer_1 = require_reflection_binary_writer();
  Object.defineProperty(exports, "ReflectionBinaryWriter", { enumerable: true, get: function() {
    return reflection_binary_writer_1.ReflectionBinaryWriter;
  } });
  var reflection_json_reader_1 = require_reflection_json_reader();
  Object.defineProperty(exports, "ReflectionJsonReader", { enumerable: true, get: function() {
    return reflection_json_reader_1.ReflectionJsonReader;
  } });
  var reflection_json_writer_1 = require_reflection_json_writer();
  Object.defineProperty(exports, "ReflectionJsonWriter", { enumerable: true, get: function() {
    return reflection_json_writer_1.ReflectionJsonWriter;
  } });
  var reflection_contains_message_type_1 = require_reflection_contains_message_type();
  Object.defineProperty(exports, "containsMessageType", { enumerable: true, get: function() {
    return reflection_contains_message_type_1.containsMessageType;
  } });
  var oneof_1 = require_oneof();
  Object.defineProperty(exports, "isOneofGroup", { enumerable: true, get: function() {
    return oneof_1.isOneofGroup;
  } });
  Object.defineProperty(exports, "setOneofValue", { enumerable: true, get: function() {
    return oneof_1.setOneofValue;
  } });
  Object.defineProperty(exports, "getOneofValue", { enumerable: true, get: function() {
    return oneof_1.getOneofValue;
  } });
  Object.defineProperty(exports, "clearOneofValue", { enumerable: true, get: function() {
    return oneof_1.clearOneofValue;
  } });
  Object.defineProperty(exports, "getSelectedOneofValue", { enumerable: true, get: function() {
    return oneof_1.getSelectedOneofValue;
  } });
  var enum_object_1 = require_enum_object();
  Object.defineProperty(exports, "listEnumValues", { enumerable: true, get: function() {
    return enum_object_1.listEnumValues;
  } });
  Object.defineProperty(exports, "listEnumNames", { enumerable: true, get: function() {
    return enum_object_1.listEnumNames;
  } });
  Object.defineProperty(exports, "listEnumNumbers", { enumerable: true, get: function() {
    return enum_object_1.listEnumNumbers;
  } });
  Object.defineProperty(exports, "isEnumObject", { enumerable: true, get: function() {
    return enum_object_1.isEnumObject;
  } });
  var lower_camel_case_1 = require_lower_camel_case();
  Object.defineProperty(exports, "lowerCamelCase", { enumerable: true, get: function() {
    return lower_camel_case_1.lowerCamelCase;
  } });
  var assert_1 = require_assert();
  Object.defineProperty(exports, "assert", { enumerable: true, get: function() {
    return assert_1.assert;
  } });
  Object.defineProperty(exports, "assertNever", { enumerable: true, get: function() {
    return assert_1.assertNever;
  } });
  Object.defineProperty(exports, "assertInt32", { enumerable: true, get: function() {
    return assert_1.assertInt32;
  } });
  Object.defineProperty(exports, "assertUInt32", { enumerable: true, get: function() {
    return assert_1.assertUInt32;
  } });
  Object.defineProperty(exports, "assertFloat32", { enumerable: true, get: function() {
    return assert_1.assertFloat32;
  } });
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/reflection-info.js
var require_reflection_info2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readServiceOption = exports.readMethodOption = exports.readMethodOptions = exports.normalizeMethodInfo = undefined;
  var runtime_1 = require_commonjs13();
  function normalizeMethodInfo(method, service) {
    var _a, _b, _c;
    let m = method;
    m.service = service;
    m.localName = (_a = m.localName) !== null && _a !== undefined ? _a : runtime_1.lowerCamelCase(m.name);
    m.serverStreaming = !!m.serverStreaming;
    m.clientStreaming = !!m.clientStreaming;
    m.options = (_b = m.options) !== null && _b !== undefined ? _b : {};
    m.idempotency = (_c = m.idempotency) !== null && _c !== undefined ? _c : undefined;
    return m;
  }
  exports.normalizeMethodInfo = normalizeMethodInfo;
  function readMethodOptions(service, methodName, extensionName, extensionType) {
    var _a;
    const options = (_a = service.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === undefined ? undefined : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
  }
  exports.readMethodOptions = readMethodOptions;
  function readMethodOption(service, methodName, extensionName, extensionType) {
    var _a;
    const options = (_a = service.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === undefined ? undefined : _a.options;
    if (!options) {
      return;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readMethodOption = readMethodOption;
  function readServiceOption(service, extensionName, extensionType) {
    const options = service.options;
    if (!options) {
      return;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readServiceOption = readServiceOption;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/service-type.js
var require_service_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServiceType = undefined;
  var reflection_info_1 = require_reflection_info2();

  class ServiceType {
    constructor(typeName, methods, options) {
      this.typeName = typeName;
      this.methods = methods.map((i) => reflection_info_1.normalizeMethodInfo(i, this));
      this.options = options !== null && options !== undefined ? options : {};
    }
  }
  exports.ServiceType = ServiceType;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-error.js
var require_rpc_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RpcError = undefined;

  class RpcError extends Error {
    constructor(message, code = "UNKNOWN", meta) {
      super(message);
      this.name = "RpcError";
      Object.setPrototypeOf(this, new.target.prototype);
      this.code = code;
      this.meta = meta !== null && meta !== undefined ? meta : {};
    }
    toString() {
      const l = [this.name + ": " + this.message];
      if (this.code) {
        l.push("");
        l.push("Code: " + this.code);
      }
      if (this.serviceName && this.methodName) {
        l.push("Method: " + this.serviceName + "/" + this.methodName);
      }
      let m = Object.entries(this.meta);
      if (m.length) {
        l.push("");
        l.push("Meta:");
        for (let [k, v] of m) {
          l.push(`  ${k}: ${v}`);
        }
      }
      return l.join(`
`);
    }
  }
  exports.RpcError = RpcError;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-options.js
var require_rpc_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeRpcOptions = undefined;
  var runtime_1 = require_commonjs13();
  function mergeRpcOptions(defaults, options) {
    if (!options)
      return defaults;
    let o = {};
    copy(defaults, o);
    copy(options, o);
    for (let key of Object.keys(options)) {
      let val = options[key];
      switch (key) {
        case "jsonOptions":
          o.jsonOptions = runtime_1.mergeJsonOptions(defaults.jsonOptions, o.jsonOptions);
          break;
        case "binaryOptions":
          o.binaryOptions = runtime_1.mergeBinaryOptions(defaults.binaryOptions, o.binaryOptions);
          break;
        case "meta":
          o.meta = {};
          copy(defaults.meta, o.meta);
          copy(options.meta, o.meta);
          break;
        case "interceptors":
          o.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();
          break;
      }
    }
    return o;
  }
  exports.mergeRpcOptions = mergeRpcOptions;
  function copy(a, into) {
    if (!a)
      return;
    let c = into;
    for (let [k, v] of Object.entries(a)) {
      if (v instanceof Date)
        c[k] = new Date(v.getTime());
      else if (Array.isArray(v))
        c[k] = v.concat();
      else
        c[k] = v;
    }
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/deferred.js
var require_deferred = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deferred = exports.DeferredState = undefined;
  var DeferredState;
  (function(DeferredState2) {
    DeferredState2[DeferredState2["PENDING"] = 0] = "PENDING";
    DeferredState2[DeferredState2["REJECTED"] = 1] = "REJECTED";
    DeferredState2[DeferredState2["RESOLVED"] = 2] = "RESOLVED";
  })(DeferredState = exports.DeferredState || (exports.DeferredState = {}));

  class Deferred {
    constructor(preventUnhandledRejectionWarning = true) {
      this._state = DeferredState.PENDING;
      this._promise = new Promise((resolve, reject) => {
        this._resolve = resolve;
        this._reject = reject;
      });
      if (preventUnhandledRejectionWarning) {
        this._promise.catch((_) => {
        });
      }
    }
    get state() {
      return this._state;
    }
    get promise() {
      return this._promise;
    }
    resolve(value) {
      if (this.state !== DeferredState.PENDING)
        throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
      this._resolve(value);
      this._state = DeferredState.RESOLVED;
    }
    reject(reason) {
      if (this.state !== DeferredState.PENDING)
        throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
      this._reject(reason);
      this._state = DeferredState.REJECTED;
    }
    resolvePending(val) {
      if (this._state === DeferredState.PENDING)
        this.resolve(val);
    }
    rejectPending(reason) {
      if (this._state === DeferredState.PENDING)
        this.reject(reason);
    }
  }
  exports.Deferred = Deferred;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-output-stream.js
var require_rpc_output_stream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RpcOutputStreamController = undefined;
  var deferred_1 = require_deferred();
  var runtime_1 = require_commonjs13();

  class RpcOutputStreamController {
    constructor() {
      this._lis = {
        nxt: [],
        msg: [],
        err: [],
        cmp: []
      };
      this._closed = false;
    }
    onNext(callback) {
      return this.addLis(callback, this._lis.nxt);
    }
    onMessage(callback) {
      return this.addLis(callback, this._lis.msg);
    }
    onError(callback) {
      return this.addLis(callback, this._lis.err);
    }
    onComplete(callback) {
      return this.addLis(callback, this._lis.cmp);
    }
    addLis(callback, list) {
      list.push(callback);
      return () => {
        let i = list.indexOf(callback);
        if (i >= 0)
          list.splice(i, 1);
      };
    }
    clearLis() {
      for (let l of Object.values(this._lis))
        l.splice(0, l.length);
    }
    get closed() {
      return this._closed !== false;
    }
    notifyNext(message, error, complete) {
      runtime_1.assert((message ? 1 : 0) + (error ? 1 : 0) + (complete ? 1 : 0) <= 1, "only one emission at a time");
      if (message)
        this.notifyMessage(message);
      if (error)
        this.notifyError(error);
      if (complete)
        this.notifyComplete();
    }
    notifyMessage(message) {
      runtime_1.assert(!this.closed, "stream is closed");
      this.pushIt({ value: message, done: false });
      this._lis.msg.forEach((l) => l(message));
      this._lis.nxt.forEach((l) => l(message, undefined, false));
    }
    notifyError(error) {
      runtime_1.assert(!this.closed, "stream is closed");
      this._closed = error;
      this.pushIt(error);
      this._lis.err.forEach((l) => l(error));
      this._lis.nxt.forEach((l) => l(undefined, error, false));
      this.clearLis();
    }
    notifyComplete() {
      runtime_1.assert(!this.closed, "stream is closed");
      this._closed = true;
      this.pushIt({ value: null, done: true });
      this._lis.cmp.forEach((l) => l());
      this._lis.nxt.forEach((l) => l(undefined, undefined, true));
      this.clearLis();
    }
    [Symbol.asyncIterator]() {
      if (!this._itState) {
        this._itState = { q: [] };
      }
      if (this._closed === true)
        this.pushIt({ value: null, done: true });
      else if (this._closed !== false)
        this.pushIt(this._closed);
      return {
        next: () => {
          let state = this._itState;
          runtime_1.assert(state, "bad state");
          runtime_1.assert(!state.p, "iterator contract broken");
          let first = state.q.shift();
          if (first)
            return "value" in first ? Promise.resolve(first) : Promise.reject(first);
          state.p = new deferred_1.Deferred;
          return state.p.promise;
        }
      };
    }
    pushIt(result) {
      let state = this._itState;
      if (!state)
        return;
      if (state.p) {
        const p = state.p;
        runtime_1.assert(p.state == deferred_1.DeferredState.PENDING, "iterator contract broken");
        "value" in result ? p.resolve(result) : p.reject(result);
        delete state.p;
      } else {
        state.q.push(result);
      }
    }
  }
  exports.RpcOutputStreamController = RpcOutputStreamController;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/unary-call.js
var require_unary_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnaryCall = undefined;

  class UnaryCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.request = request;
      this.headers = headers;
      this.response = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, undefined, undefined, function* () {
        let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          request: this.request,
          headers,
          response,
          status,
          trailers
        };
      });
    }
  }
  exports.UnaryCall = UnaryCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/server-streaming-call.js
var require_server_streaming_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerStreamingCall = undefined;

  class ServerStreamingCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.request = request;
      this.headers = headers;
      this.responses = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, undefined, undefined, function* () {
        let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          request: this.request,
          headers,
          status,
          trailers
        };
      });
    }
  }
  exports.ServerStreamingCall = ServerStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/client-streaming-call.js
var require_client_streaming_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientStreamingCall = undefined;

  class ClientStreamingCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.requests = request;
      this.headers = headers;
      this.response = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, undefined, undefined, function* () {
        let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          headers,
          response,
          status,
          trailers
        };
      });
    }
  }
  exports.ClientStreamingCall = ClientStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/duplex-streaming-call.js
var require_duplex_streaming_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DuplexStreamingCall = undefined;

  class DuplexStreamingCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.requests = request;
      this.headers = headers;
      this.responses = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, undefined, undefined, function* () {
        let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          headers,
          status,
          trailers
        };
      });
    }
  }
  exports.DuplexStreamingCall = DuplexStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/test-transport.js
var require_test_transport = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TestTransport = undefined;
  var rpc_error_1 = require_rpc_error();
  var runtime_1 = require_commonjs13();
  var rpc_output_stream_1 = require_rpc_output_stream();
  var rpc_options_1 = require_rpc_options();
  var unary_call_1 = require_unary_call();
  var server_streaming_call_1 = require_server_streaming_call();
  var client_streaming_call_1 = require_client_streaming_call();
  var duplex_streaming_call_1 = require_duplex_streaming_call();

  class TestTransport {
    constructor(data) {
      this.suppressUncaughtRejections = true;
      this.headerDelay = 10;
      this.responseDelay = 50;
      this.betweenResponseDelay = 10;
      this.afterResponseDelay = 10;
      this.data = data !== null && data !== undefined ? data : {};
    }
    get sentMessages() {
      if (this.lastInput instanceof TestInputStream) {
        return this.lastInput.sent;
      } else if (typeof this.lastInput == "object") {
        return [this.lastInput.single];
      }
      return [];
    }
    get sendComplete() {
      if (this.lastInput instanceof TestInputStream) {
        return this.lastInput.completed;
      } else if (typeof this.lastInput == "object") {
        return true;
      }
      return false;
    }
    promiseHeaders() {
      var _a;
      const headers = (_a = this.data.headers) !== null && _a !== undefined ? _a : TestTransport.defaultHeaders;
      return headers instanceof rpc_error_1.RpcError ? Promise.reject(headers) : Promise.resolve(headers);
    }
    promiseSingleResponse(method) {
      if (this.data.response instanceof rpc_error_1.RpcError) {
        return Promise.reject(this.data.response);
      }
      let r;
      if (Array.isArray(this.data.response)) {
        runtime_1.assert(this.data.response.length > 0);
        r = this.data.response[0];
      } else if (this.data.response !== undefined) {
        r = this.data.response;
      } else {
        r = method.O.create();
      }
      runtime_1.assert(method.O.is(r));
      return Promise.resolve(r);
    }
    streamResponses(method, stream, abort) {
      return __awaiter(this, undefined, undefined, function* () {
        const messages = [];
        if (this.data.response === undefined) {
          messages.push(method.O.create());
        } else if (Array.isArray(this.data.response)) {
          for (let msg of this.data.response) {
            runtime_1.assert(method.O.is(msg));
            messages.push(msg);
          }
        } else if (!(this.data.response instanceof rpc_error_1.RpcError)) {
          runtime_1.assert(method.O.is(this.data.response));
          messages.push(this.data.response);
        }
        try {
          yield delay(this.responseDelay, abort)(undefined);
        } catch (error) {
          stream.notifyError(error);
          return;
        }
        if (this.data.response instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.response);
          return;
        }
        for (let msg of messages) {
          stream.notifyMessage(msg);
          try {
            yield delay(this.betweenResponseDelay, abort)(undefined);
          } catch (error) {
            stream.notifyError(error);
            return;
          }
        }
        if (this.data.status instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.status);
          return;
        }
        if (this.data.trailers instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.trailers);
          return;
        }
        stream.notifyComplete();
      });
    }
    promiseStatus() {
      var _a;
      const status = (_a = this.data.status) !== null && _a !== undefined ? _a : TestTransport.defaultStatus;
      return status instanceof rpc_error_1.RpcError ? Promise.reject(status) : Promise.resolve(status);
    }
    promiseTrailers() {
      var _a;
      const trailers = (_a = this.data.trailers) !== null && _a !== undefined ? _a : TestTransport.defaultTrailers;
      return trailers instanceof rpc_error_1.RpcError ? Promise.reject(trailers) : Promise.resolve(trailers);
    }
    maybeSuppressUncaught(...promise) {
      if (this.suppressUncaughtRejections) {
        for (let p of promise) {
          p.catch(() => {
          });
        }
      }
    }
    mergeOptions(options) {
      return rpc_options_1.mergeRpcOptions({}, options);
    }
    unary(method, input, options) {
      var _a;
      const requestHeaders = (_a = options.meta) !== null && _a !== undefined ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_) => {
      }).then(delay(this.responseDelay, options.abort)).then((_) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_) => {
      }).then(delay(this.afterResponseDelay, options.abort)).then((_) => this.promiseStatus()), trailersPromise = responsePromise.catch((_) => {
      }).then(delay(this.afterResponseDelay, options.abort)).then((_) => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = { single: input };
      return new unary_call_1.UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);
    }
    serverStreaming(method, input, options) {
      var _a;
      const requestHeaders = (_a = options.meta) !== null && _a !== undefined ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new rpc_output_stream_1.RpcOutputStreamController, responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {
      }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = { single: input };
      return new server_streaming_call_1.ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);
    }
    clientStreaming(method, options) {
      var _a;
      const requestHeaders = (_a = options.meta) !== null && _a !== undefined ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_) => {
      }).then(delay(this.responseDelay, options.abort)).then((_) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_) => {
      }).then(delay(this.afterResponseDelay, options.abort)).then((_) => this.promiseStatus()), trailersPromise = responsePromise.catch((_) => {
      }).then(delay(this.afterResponseDelay, options.abort)).then((_) => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = new TestInputStream(this.data, options.abort);
      return new client_streaming_call_1.ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);
    }
    duplex(method, options) {
      var _a;
      const requestHeaders = (_a = options.meta) !== null && _a !== undefined ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new rpc_output_stream_1.RpcOutputStreamController, responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {
      }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = new TestInputStream(this.data, options.abort);
      return new duplex_streaming_call_1.DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);
    }
  }
  exports.TestTransport = TestTransport;
  TestTransport.defaultHeaders = {
    responseHeader: "test"
  };
  TestTransport.defaultStatus = {
    code: "OK",
    detail: "all good"
  };
  TestTransport.defaultTrailers = {
    responseTrailer: "test"
  };
  function delay(ms, abort) {
    return (v) => new Promise((resolve, reject) => {
      if (abort === null || abort === undefined ? undefined : abort.aborted) {
        reject(new rpc_error_1.RpcError("user cancel", "CANCELLED"));
      } else {
        const id = setTimeout(() => resolve(v), ms);
        if (abort) {
          abort.addEventListener("abort", (ev) => {
            clearTimeout(id);
            reject(new rpc_error_1.RpcError("user cancel", "CANCELLED"));
          });
        }
      }
    });
  }

  class TestInputStream {
    constructor(data, abort) {
      this._completed = false;
      this._sent = [];
      this.data = data;
      this.abort = abort;
    }
    get sent() {
      return this._sent;
    }
    get completed() {
      return this._completed;
    }
    send(message) {
      if (this.data.inputMessage instanceof rpc_error_1.RpcError) {
        return Promise.reject(this.data.inputMessage);
      }
      const delayMs = this.data.inputMessage === undefined ? 10 : this.data.inputMessage;
      return Promise.resolve(undefined).then(() => {
        this._sent.push(message);
      }).then(delay(delayMs, this.abort));
    }
    complete() {
      if (this.data.inputComplete instanceof rpc_error_1.RpcError) {
        return Promise.reject(this.data.inputComplete);
      }
      const delayMs = this.data.inputComplete === undefined ? 10 : this.data.inputComplete;
      return Promise.resolve(undefined).then(() => {
        this._completed = true;
      }).then(delay(delayMs, this.abort));
    }
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-interceptor.js
var require_rpc_interceptor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stackDuplexStreamingInterceptors = exports.stackClientStreamingInterceptors = exports.stackServerStreamingInterceptors = exports.stackUnaryInterceptors = exports.stackIntercept = undefined;
  var runtime_1 = require_commonjs13();
  function stackIntercept(kind, transport, method, options, input) {
    var _a, _b, _c, _d;
    if (kind == "unary") {
      let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
      for (const curr of ((_a = options.interceptors) !== null && _a !== undefined ? _a : []).filter((i) => i.interceptUnary).reverse()) {
        const next = tail;
        tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);
      }
      return tail(method, input, options);
    }
    if (kind == "serverStreaming") {
      let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
      for (const curr of ((_b = options.interceptors) !== null && _b !== undefined ? _b : []).filter((i) => i.interceptServerStreaming).reverse()) {
        const next = tail;
        tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);
      }
      return tail(method, input, options);
    }
    if (kind == "clientStreaming") {
      let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
      for (const curr of ((_c = options.interceptors) !== null && _c !== undefined ? _c : []).filter((i) => i.interceptClientStreaming).reverse()) {
        const next = tail;
        tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);
      }
      return tail(method, options);
    }
    if (kind == "duplex") {
      let tail = (mtd, opt) => transport.duplex(mtd, opt);
      for (const curr of ((_d = options.interceptors) !== null && _d !== undefined ? _d : []).filter((i) => i.interceptDuplex).reverse()) {
        const next = tail;
        tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);
      }
      return tail(method, options);
    }
    runtime_1.assertNever(kind);
  }
  exports.stackIntercept = stackIntercept;
  function stackUnaryInterceptors(transport, method, input, options) {
    return stackIntercept("unary", transport, method, options, input);
  }
  exports.stackUnaryInterceptors = stackUnaryInterceptors;
  function stackServerStreamingInterceptors(transport, method, input, options) {
    return stackIntercept("serverStreaming", transport, method, options, input);
  }
  exports.stackServerStreamingInterceptors = stackServerStreamingInterceptors;
  function stackClientStreamingInterceptors(transport, method, options) {
    return stackIntercept("clientStreaming", transport, method, options);
  }
  exports.stackClientStreamingInterceptors = stackClientStreamingInterceptors;
  function stackDuplexStreamingInterceptors(transport, method, options) {
    return stackIntercept("duplex", transport, method, options);
  }
  exports.stackDuplexStreamingInterceptors = stackDuplexStreamingInterceptors;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/server-call-context.js
var require_server_call_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerCallContextController = undefined;

  class ServerCallContextController {
    constructor(method, headers, deadline, sendResponseHeadersFn, defaultStatus = { code: "OK", detail: "" }) {
      this._cancelled = false;
      this._listeners = [];
      this.method = method;
      this.headers = headers;
      this.deadline = deadline;
      this.trailers = {};
      this._sendRH = sendResponseHeadersFn;
      this.status = defaultStatus;
    }
    notifyCancelled() {
      if (!this._cancelled) {
        this._cancelled = true;
        for (let l of this._listeners) {
          l();
        }
      }
    }
    sendResponseHeaders(data) {
      this._sendRH(data);
    }
    get cancelled() {
      return this._cancelled;
    }
    onCancel(callback) {
      const l = this._listeners;
      l.push(callback);
      return () => {
        let i = l.indexOf(callback);
        if (i >= 0)
          l.splice(i, 1);
      };
    }
  }
  exports.ServerCallContextController = ServerCallContextController;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/index.js
var require_commonjs14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var service_type_1 = require_service_type();
  Object.defineProperty(exports, "ServiceType", { enumerable: true, get: function() {
    return service_type_1.ServiceType;
  } });
  var reflection_info_1 = require_reflection_info2();
  Object.defineProperty(exports, "readMethodOptions", { enumerable: true, get: function() {
    return reflection_info_1.readMethodOptions;
  } });
  Object.defineProperty(exports, "readMethodOption", { enumerable: true, get: function() {
    return reflection_info_1.readMethodOption;
  } });
  Object.defineProperty(exports, "readServiceOption", { enumerable: true, get: function() {
    return reflection_info_1.readServiceOption;
  } });
  var rpc_error_1 = require_rpc_error();
  Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
    return rpc_error_1.RpcError;
  } });
  var rpc_options_1 = require_rpc_options();
  Object.defineProperty(exports, "mergeRpcOptions", { enumerable: true, get: function() {
    return rpc_options_1.mergeRpcOptions;
  } });
  var rpc_output_stream_1 = require_rpc_output_stream();
  Object.defineProperty(exports, "RpcOutputStreamController", { enumerable: true, get: function() {
    return rpc_output_stream_1.RpcOutputStreamController;
  } });
  var test_transport_1 = require_test_transport();
  Object.defineProperty(exports, "TestTransport", { enumerable: true, get: function() {
    return test_transport_1.TestTransport;
  } });
  var deferred_1 = require_deferred();
  Object.defineProperty(exports, "Deferred", { enumerable: true, get: function() {
    return deferred_1.Deferred;
  } });
  Object.defineProperty(exports, "DeferredState", { enumerable: true, get: function() {
    return deferred_1.DeferredState;
  } });
  var duplex_streaming_call_1 = require_duplex_streaming_call();
  Object.defineProperty(exports, "DuplexStreamingCall", { enumerable: true, get: function() {
    return duplex_streaming_call_1.DuplexStreamingCall;
  } });
  var client_streaming_call_1 = require_client_streaming_call();
  Object.defineProperty(exports, "ClientStreamingCall", { enumerable: true, get: function() {
    return client_streaming_call_1.ClientStreamingCall;
  } });
  var server_streaming_call_1 = require_server_streaming_call();
  Object.defineProperty(exports, "ServerStreamingCall", { enumerable: true, get: function() {
    return server_streaming_call_1.ServerStreamingCall;
  } });
  var unary_call_1 = require_unary_call();
  Object.defineProperty(exports, "UnaryCall", { enumerable: true, get: function() {
    return unary_call_1.UnaryCall;
  } });
  var rpc_interceptor_1 = require_rpc_interceptor();
  Object.defineProperty(exports, "stackIntercept", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackIntercept;
  } });
  Object.defineProperty(exports, "stackDuplexStreamingInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackDuplexStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackClientStreamingInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackClientStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackServerStreamingInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackServerStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackUnaryInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackUnaryInterceptors;
  } });
  var server_call_context_1 = require_server_call_context();
  Object.defineProperty(exports, "ServerCallContextController", { enumerable: true, get: function() {
    return server_call_context_1.ServerCallContextController;
  } });
});

// node_modules/@actions/cache/lib/generated/google/protobuf/timestamp.js
var require_timestamp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Timestamp = undefined;
  var runtime_1 = require_commonjs13();
  var runtime_2 = require_commonjs13();
  var runtime_3 = require_commonjs13();
  var runtime_4 = require_commonjs13();
  var runtime_5 = require_commonjs13();
  var runtime_6 = require_commonjs13();
  var runtime_7 = require_commonjs13();

  class Timestamp$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.Timestamp", [
        { no: 1, name: "seconds", kind: "scalar", T: 3 },
        { no: 2, name: "nanos", kind: "scalar", T: 5 }
      ]);
    }
    now() {
      const msg = this.create();
      const ms = Date.now();
      msg.seconds = runtime_6.PbLong.from(Math.floor(ms / 1000)).toString();
      msg.nanos = ms % 1000 * 1e6;
      return msg;
    }
    toDate(message) {
      return new Date(runtime_6.PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1e6));
    }
    fromDate(date) {
      const msg = this.create();
      const ms = date.getTime();
      msg.seconds = runtime_6.PbLong.from(Math.floor(ms / 1000)).toString();
      msg.nanos = ms % 1000 * 1e6;
      return msg;
    }
    internalJsonWrite(message, options) {
      let ms = runtime_6.PbLong.from(message.seconds).toNumber() * 1000;
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z"))
        throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
      if (message.nanos < 0)
        throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
      let z = "Z";
      if (message.nanos > 0) {
        let nanosStr = (message.nanos + 1e9).toString().substring(1);
        if (nanosStr.substring(3) === "000000")
          z = "." + nanosStr.substring(0, 3) + "Z";
        else if (nanosStr.substring(6) === "000")
          z = "." + nanosStr.substring(0, 6) + "Z";
        else
          z = "." + nanosStr + "Z";
      }
      return new Date(ms).toISOString().replace(".000Z", z);
    }
    internalJsonRead(json, options, target) {
      if (typeof json !== "string")
        throw new Error("Unable to parse Timestamp from JSON " + (0, runtime_5.typeofJsonValue)(json) + ".");
      let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!matches)
        throw new Error("Unable to parse Timestamp from JSON. Invalid format.");
      let ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
      if (Number.isNaN(ms))
        throw new Error("Unable to parse Timestamp from JSON. Invalid value.");
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z"))
        throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
      if (!target)
        target = this.create();
      target.seconds = runtime_6.PbLong.from(ms / 1000).toString();
      target.nanos = 0;
      if (matches[7])
        target.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
      return target;
    }
    create(value) {
      const message = { seconds: "0", nanos: 0 };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.seconds = reader.int64().toString();
            break;
          case 2:
            message.nanos = reader.int32();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.seconds !== "0")
        writer.tag(1, runtime_1.WireType.Varint).int64(message.seconds);
      if (message.nanos !== 0)
        writer.tag(2, runtime_1.WireType.Varint).int32(message.nanos);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.Timestamp = new Timestamp$Type;
});

// node_modules/@actions/cache/lib/generated/results/entities/v1/cacheentry.js
var require_cacheentry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheEntry = undefined;
  var runtime_1 = require_commonjs13();
  var runtime_2 = require_commonjs13();
  var runtime_3 = require_commonjs13();
  var runtime_4 = require_commonjs13();
  var runtime_5 = require_commonjs13();
  var timestamp_1 = require_timestamp();

  class CacheEntry$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.entities.v1.CacheEntry", [
        { no: 1, name: "key", kind: "scalar", T: 9 },
        { no: 2, name: "hash", kind: "scalar", T: 9 },
        { no: 3, name: "size_bytes", kind: "scalar", T: 3 },
        { no: 4, name: "scope", kind: "scalar", T: 9 },
        { no: 5, name: "version", kind: "scalar", T: 9 },
        { no: 6, name: "created_at", kind: "message", T: () => timestamp_1.Timestamp },
        { no: 7, name: "last_accessed_at", kind: "message", T: () => timestamp_1.Timestamp },
        { no: 8, name: "expires_at", kind: "message", T: () => timestamp_1.Timestamp }
      ]);
    }
    create(value) {
      const message = { key: "", hash: "", sizeBytes: "0", scope: "", version: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.key = reader.string();
            break;
          case 2:
            message.hash = reader.string();
            break;
          case 3:
            message.sizeBytes = reader.int64().toString();
            break;
          case 4:
            message.scope = reader.string();
            break;
          case 5:
            message.version = reader.string();
            break;
          case 6:
            message.createdAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
            break;
          case 7:
            message.lastAccessedAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastAccessedAt);
            break;
          case 8:
            message.expiresAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.key !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.key);
      if (message.hash !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.hash);
      if (message.sizeBytes !== "0")
        writer.tag(3, runtime_1.WireType.Varint).int64(message.sizeBytes);
      if (message.scope !== "")
        writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.scope);
      if (message.version !== "")
        writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.version);
      if (message.createdAt)
        timestamp_1.Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.lastAccessedAt)
        timestamp_1.Timestamp.internalBinaryWrite(message.lastAccessedAt, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.expiresAt)
        timestamp_1.Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CacheEntry = new CacheEntry$Type;
});

// node_modules/@actions/cache/lib/generated/results/entities/v1/cachescope.js
var require_cachescope = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheScope = undefined;
  var runtime_1 = require_commonjs13();
  var runtime_2 = require_commonjs13();
  var runtime_3 = require_commonjs13();
  var runtime_4 = require_commonjs13();
  var runtime_5 = require_commonjs13();

  class CacheScope$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.entities.v1.CacheScope", [
        { no: 1, name: "scope", kind: "scalar", T: 9 },
        { no: 2, name: "permission", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      const message = { scope: "", permission: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.scope = reader.string();
            break;
          case 2:
            message.permission = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.scope !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.scope);
      if (message.permission !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.permission);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CacheScope = new CacheScope$Type;
});

// node_modules/@actions/cache/lib/generated/results/entities/v1/cachemetadata.js
var require_cachemetadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheMetadata = undefined;
  var runtime_1 = require_commonjs13();
  var runtime_2 = require_commonjs13();
  var runtime_3 = require_commonjs13();
  var runtime_4 = require_commonjs13();
  var runtime_5 = require_commonjs13();
  var cachescope_1 = require_cachescope();

  class CacheMetadata$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.entities.v1.CacheMetadata", [
        { no: 1, name: "repository_id", kind: "scalar", T: 3 },
        { no: 2, name: "scope", kind: "message", repeat: 1, T: () => cachescope_1.CacheScope }
      ]);
    }
    create(value) {
      const message = { repositoryId: "0", scope: [] };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.repositoryId = reader.int64().toString();
            break;
          case 2:
            message.scope.push(cachescope_1.CacheScope.internalBinaryRead(reader, reader.uint32(), options));
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.repositoryId !== "0")
        writer.tag(1, runtime_1.WireType.Varint).int64(message.repositoryId);
      for (let i = 0;i < message.scope.length; i++)
        cachescope_1.CacheScope.internalBinaryWrite(message.scope[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CacheMetadata = new CacheMetadata$Type;
});

// node_modules/@actions/cache/lib/generated/results/api/v1/cache.js
var require_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheService = exports.LookupCacheEntryResponse = exports.LookupCacheEntryRequest = exports.ListCacheEntriesResponse = exports.ListCacheEntriesRequest = exports.DeleteCacheEntryResponse = exports.DeleteCacheEntryRequest = exports.GetCacheEntryDownloadURLResponse = exports.GetCacheEntryDownloadURLRequest = exports.FinalizeCacheEntryUploadResponse = exports.FinalizeCacheEntryUploadRequest = exports.CreateCacheEntryResponse = exports.CreateCacheEntryRequest = undefined;
  var runtime_rpc_1 = require_commonjs14();
  var runtime_1 = require_commonjs13();
  var runtime_2 = require_commonjs13();
  var runtime_3 = require_commonjs13();
  var runtime_4 = require_commonjs13();
  var runtime_5 = require_commonjs13();
  var cacheentry_1 = require_cacheentry();
  var cachemetadata_1 = require_cachemetadata();

  class CreateCacheEntryRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.CreateCacheEntryRequest", [
        { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
        { no: 2, name: "key", kind: "scalar", T: 9 },
        { no: 3, name: "version", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { key: "", version: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
            break;
          case 2:
            message.key = reader.string();
            break;
          case 3:
            message.version = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.metadata)
        cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.key !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
      if (message.version !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.version);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CreateCacheEntryRequest = new CreateCacheEntryRequest$Type;

  class CreateCacheEntryResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.CreateCacheEntryResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "signed_upload_url", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { ok: false, signedUploadUrl: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.signedUploadUrl = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.signedUploadUrl !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedUploadUrl);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CreateCacheEntryResponse = new CreateCacheEntryResponse$Type;

  class FinalizeCacheEntryUploadRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeCacheEntryUploadRequest", [
        { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
        { no: 2, name: "key", kind: "scalar", T: 9 },
        { no: 3, name: "size_bytes", kind: "scalar", T: 3 },
        { no: 4, name: "version", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { key: "", sizeBytes: "0", version: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
            break;
          case 2:
            message.key = reader.string();
            break;
          case 3:
            message.sizeBytes = reader.int64().toString();
            break;
          case 4:
            message.version = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.metadata)
        cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.key !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
      if (message.sizeBytes !== "0")
        writer.tag(3, runtime_1.WireType.Varint).int64(message.sizeBytes);
      if (message.version !== "")
        writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.version);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeCacheEntryUploadRequest = new FinalizeCacheEntryUploadRequest$Type;

  class FinalizeCacheEntryUploadResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeCacheEntryUploadResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "entry_id", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      const message = { ok: false, entryId: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.entryId = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.entryId !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.entryId);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeCacheEntryUploadResponse = new FinalizeCacheEntryUploadResponse$Type;

  class GetCacheEntryDownloadURLRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.GetCacheEntryDownloadURLRequest", [
        { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
        { no: 2, name: "key", kind: "scalar", T: 9 },
        { no: 3, name: "restore_keys", kind: "scalar", repeat: 2, T: 9 },
        { no: 4, name: "version", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { key: "", restoreKeys: [], version: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
            break;
          case 2:
            message.key = reader.string();
            break;
          case 3:
            message.restoreKeys.push(reader.string());
            break;
          case 4:
            message.version = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.metadata)
        cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.key !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
      for (let i = 0;i < message.restoreKeys.length; i++)
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.restoreKeys[i]);
      if (message.version !== "")
        writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.version);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.GetCacheEntryDownloadURLRequest = new GetCacheEntryDownloadURLRequest$Type;

  class GetCacheEntryDownloadURLResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.GetCacheEntryDownloadURLResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "signed_download_url", kind: "scalar", T: 9 },
        { no: 3, name: "matched_key", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { ok: false, signedDownloadUrl: "", matchedKey: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.signedDownloadUrl = reader.string();
            break;
          case 3:
            message.matchedKey = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.signedDownloadUrl !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedDownloadUrl);
      if (message.matchedKey !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.matchedKey);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.GetCacheEntryDownloadURLResponse = new GetCacheEntryDownloadURLResponse$Type;

  class DeleteCacheEntryRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.DeleteCacheEntryRequest", [
        { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
        { no: 2, name: "key", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { key: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
            break;
          case 2:
            message.key = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.metadata)
        cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.key !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.DeleteCacheEntryRequest = new DeleteCacheEntryRequest$Type;

  class DeleteCacheEntryResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.DeleteCacheEntryResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "entry_id", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      const message = { ok: false, entryId: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.entryId = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.entryId !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.entryId);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.DeleteCacheEntryResponse = new DeleteCacheEntryResponse$Type;

  class ListCacheEntriesRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.ListCacheEntriesRequest", [
        { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
        { no: 2, name: "key", kind: "scalar", T: 9 },
        { no: 3, name: "restore_keys", kind: "scalar", repeat: 2, T: 9 }
      ]);
    }
    create(value) {
      const message = { key: "", restoreKeys: [] };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
            break;
          case 2:
            message.key = reader.string();
            break;
          case 3:
            message.restoreKeys.push(reader.string());
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.metadata)
        cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.key !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
      for (let i = 0;i < message.restoreKeys.length; i++)
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.restoreKeys[i]);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.ListCacheEntriesRequest = new ListCacheEntriesRequest$Type;

  class ListCacheEntriesResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.ListCacheEntriesResponse", [
        { no: 1, name: "entries", kind: "message", repeat: 1, T: () => cacheentry_1.CacheEntry }
      ]);
    }
    create(value) {
      const message = { entries: [] };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.entries.push(cacheentry_1.CacheEntry.internalBinaryRead(reader, reader.uint32(), options));
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      for (let i = 0;i < message.entries.length; i++)
        cacheentry_1.CacheEntry.internalBinaryWrite(message.entries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.ListCacheEntriesResponse = new ListCacheEntriesResponse$Type;

  class LookupCacheEntryRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.LookupCacheEntryRequest", [
        { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
        { no: 2, name: "key", kind: "scalar", T: 9 },
        { no: 3, name: "restore_keys", kind: "scalar", repeat: 2, T: 9 },
        { no: 4, name: "version", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { key: "", restoreKeys: [], version: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
            break;
          case 2:
            message.key = reader.string();
            break;
          case 3:
            message.restoreKeys.push(reader.string());
            break;
          case 4:
            message.version = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.metadata)
        cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.key !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
      for (let i = 0;i < message.restoreKeys.length; i++)
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.restoreKeys[i]);
      if (message.version !== "")
        writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.version);
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.LookupCacheEntryRequest = new LookupCacheEntryRequest$Type;

  class LookupCacheEntryResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.LookupCacheEntryResponse", [
        { no: 1, name: "exists", kind: "scalar", T: 8 },
        { no: 2, name: "entry", kind: "message", T: () => cacheentry_1.CacheEntry }
      ]);
    }
    create(value) {
      const message = { exists: false };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.exists = reader.bool();
            break;
          case 2:
            message.entry = cacheentry_1.CacheEntry.internalBinaryRead(reader, reader.uint32(), options, message.entry);
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== false)
              (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.exists !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.exists);
      if (message.entry)
        cacheentry_1.CacheEntry.internalBinaryWrite(message.entry, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== false)
        (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.LookupCacheEntryResponse = new LookupCacheEntryResponse$Type;
  exports.CacheService = new runtime_rpc_1.ServiceType("github.actions.results.api.v1.CacheService", [
    { name: "CreateCacheEntry", options: {}, I: exports.CreateCacheEntryRequest, O: exports.CreateCacheEntryResponse },
    { name: "FinalizeCacheEntryUpload", options: {}, I: exports.FinalizeCacheEntryUploadRequest, O: exports.FinalizeCacheEntryUploadResponse },
    { name: "GetCacheEntryDownloadURL", options: {}, I: exports.GetCacheEntryDownloadURLRequest, O: exports.GetCacheEntryDownloadURLResponse },
    { name: "DeleteCacheEntry", options: {}, I: exports.DeleteCacheEntryRequest, O: exports.DeleteCacheEntryResponse },
    { name: "ListCacheEntries", options: {}, I: exports.ListCacheEntriesRequest, O: exports.ListCacheEntriesResponse },
    { name: "LookupCacheEntry", options: {}, I: exports.LookupCacheEntryRequest, O: exports.LookupCacheEntryResponse }
  ]);
});

// node_modules/@actions/cache/lib/generated/results/api/v1/cache.twirp.js
var require_cache_twirp = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createCacheServiceServer = exports.CacheServiceMethodList = exports.CacheServiceMethod = exports.CacheServiceClientProtobuf = exports.CacheServiceClientJSON = undefined;
  var twirp_ts_1 = require_twirp();
  var cache_1 = require_cache();

  class CacheServiceClientJSON {
    constructor(rpc) {
      this.rpc = rpc;
      this.CreateCacheEntry.bind(this);
      this.FinalizeCacheEntryUpload.bind(this);
      this.GetCacheEntryDownloadURL.bind(this);
      this.DeleteCacheEntry.bind(this);
      this.ListCacheEntries.bind(this);
      this.LookupCacheEntry.bind(this);
    }
    CreateCacheEntry(request) {
      const data = cache_1.CreateCacheEntryRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/json", data);
      return promise.then((data2) => cache_1.CreateCacheEntryResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    FinalizeCacheEntryUpload(request) {
      const data = cache_1.FinalizeCacheEntryUploadRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/json", data);
      return promise.then((data2) => cache_1.FinalizeCacheEntryUploadResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    GetCacheEntryDownloadURL(request) {
      const data = cache_1.GetCacheEntryDownloadURLRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/json", data);
      return promise.then((data2) => cache_1.GetCacheEntryDownloadURLResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    DeleteCacheEntry(request) {
      const data = cache_1.DeleteCacheEntryRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "DeleteCacheEntry", "application/json", data);
      return promise.then((data2) => cache_1.DeleteCacheEntryResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    ListCacheEntries(request) {
      const data = cache_1.ListCacheEntriesRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "ListCacheEntries", "application/json", data);
      return promise.then((data2) => cache_1.ListCacheEntriesResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    LookupCacheEntry(request) {
      const data = cache_1.LookupCacheEntryRequest.toJson(request, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "LookupCacheEntry", "application/json", data);
      return promise.then((data2) => cache_1.LookupCacheEntryResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
  }
  exports.CacheServiceClientJSON = CacheServiceClientJSON;

  class CacheServiceClientProtobuf {
    constructor(rpc) {
      this.rpc = rpc;
      this.CreateCacheEntry.bind(this);
      this.FinalizeCacheEntryUpload.bind(this);
      this.GetCacheEntryDownloadURL.bind(this);
      this.DeleteCacheEntry.bind(this);
      this.ListCacheEntries.bind(this);
      this.LookupCacheEntry.bind(this);
    }
    CreateCacheEntry(request) {
      const data = cache_1.CreateCacheEntryRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/protobuf", data);
      return promise.then((data2) => cache_1.CreateCacheEntryResponse.fromBinary(data2));
    }
    FinalizeCacheEntryUpload(request) {
      const data = cache_1.FinalizeCacheEntryUploadRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/protobuf", data);
      return promise.then((data2) => cache_1.FinalizeCacheEntryUploadResponse.fromBinary(data2));
    }
    GetCacheEntryDownloadURL(request) {
      const data = cache_1.GetCacheEntryDownloadURLRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/protobuf", data);
      return promise.then((data2) => cache_1.GetCacheEntryDownloadURLResponse.fromBinary(data2));
    }
    DeleteCacheEntry(request) {
      const data = cache_1.DeleteCacheEntryRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "DeleteCacheEntry", "application/protobuf", data);
      return promise.then((data2) => cache_1.DeleteCacheEntryResponse.fromBinary(data2));
    }
    ListCacheEntries(request) {
      const data = cache_1.ListCacheEntriesRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "ListCacheEntries", "application/protobuf", data);
      return promise.then((data2) => cache_1.ListCacheEntriesResponse.fromBinary(data2));
    }
    LookupCacheEntry(request) {
      const data = cache_1.LookupCacheEntryRequest.toBinary(request);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "LookupCacheEntry", "application/protobuf", data);
      return promise.then((data2) => cache_1.LookupCacheEntryResponse.fromBinary(data2));
    }
  }
  exports.CacheServiceClientProtobuf = CacheServiceClientProtobuf;
  var CacheServiceMethod;
  (function(CacheServiceMethod2) {
    CacheServiceMethod2["CreateCacheEntry"] = "CreateCacheEntry";
    CacheServiceMethod2["FinalizeCacheEntryUpload"] = "FinalizeCacheEntryUpload";
    CacheServiceMethod2["GetCacheEntryDownloadURL"] = "GetCacheEntryDownloadURL";
    CacheServiceMethod2["DeleteCacheEntry"] = "DeleteCacheEntry";
    CacheServiceMethod2["ListCacheEntries"] = "ListCacheEntries";
    CacheServiceMethod2["LookupCacheEntry"] = "LookupCacheEntry";
  })(CacheServiceMethod || (exports.CacheServiceMethod = CacheServiceMethod = {}));
  exports.CacheServiceMethodList = [
    CacheServiceMethod.CreateCacheEntry,
    CacheServiceMethod.FinalizeCacheEntryUpload,
    CacheServiceMethod.GetCacheEntryDownloadURL,
    CacheServiceMethod.DeleteCacheEntry,
    CacheServiceMethod.ListCacheEntries,
    CacheServiceMethod.LookupCacheEntry
  ];
  function createCacheServiceServer(service) {
    return new twirp_ts_1.TwirpServer({
      service,
      packageName: "github.actions.results.api.v1",
      serviceName: "CacheService",
      methodList: exports.CacheServiceMethodList,
      matchRoute: matchCacheServiceRoute
    });
  }
  exports.createCacheServiceServer = createCacheServiceServer;
  function matchCacheServiceRoute(method, events) {
    switch (method) {
      case "CreateCacheEntry":
        return (ctx, service, data, interceptors) => __awaiter(this, undefined, undefined, function* () {
          ctx = Object.assign(Object.assign({}, ctx), { methodName: "CreateCacheEntry" });
          yield events.onMatch(ctx);
          return handleCacheServiceCreateCacheEntryRequest(ctx, service, data, interceptors);
        });
      case "FinalizeCacheEntryUpload":
        return (ctx, service, data, interceptors) => __awaiter(this, undefined, undefined, function* () {
          ctx = Object.assign(Object.assign({}, ctx), { methodName: "FinalizeCacheEntryUpload" });
          yield events.onMatch(ctx);
          return handleCacheServiceFinalizeCacheEntryUploadRequest(ctx, service, data, interceptors);
        });
      case "GetCacheEntryDownloadURL":
        return (ctx, service, data, interceptors) => __awaiter(this, undefined, undefined, function* () {
          ctx = Object.assign(Object.assign({}, ctx), { methodName: "GetCacheEntryDownloadURL" });
          yield events.onMatch(ctx);
          return handleCacheServiceGetCacheEntryDownloadURLRequest(ctx, service, data, interceptors);
        });
      case "DeleteCacheEntry":
        return (ctx, service, data, interceptors) => __awaiter(this, undefined, undefined, function* () {
          ctx = Object.assign(Object.assign({}, ctx), { methodName: "DeleteCacheEntry" });
          yield events.onMatch(ctx);
          return handleCacheServiceDeleteCacheEntryRequest(ctx, service, data, interceptors);
        });
      case "ListCacheEntries":
        return (ctx, service, data, interceptors) => __awaiter(this, undefined, undefined, function* () {
          ctx = Object.assign(Object.assign({}, ctx), { methodName: "ListCacheEntries" });
          yield events.onMatch(ctx);
          return handleCacheServiceListCacheEntriesRequest(ctx, service, data, interceptors);
        });
      case "LookupCacheEntry":
        return (ctx, service, data, interceptors) => __awaiter(this, undefined, undefined, function* () {
          ctx = Object.assign(Object.assign({}, ctx), { methodName: "LookupCacheEntry" });
          yield events.onMatch(ctx);
          return handleCacheServiceLookupCacheEntryRequest(ctx, service, data, interceptors);
        });
      default:
        events.onNotFound();
        const msg = `no handler found`;
        throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.BadRoute, msg);
    }
  }
  function handleCacheServiceCreateCacheEntryRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
      case twirp_ts_1.TwirpContentType.JSON:
        return handleCacheServiceCreateCacheEntryJSON(ctx, service, data, interceptors);
      case twirp_ts_1.TwirpContentType.Protobuf:
        return handleCacheServiceCreateCacheEntryProtobuf(ctx, service, data, interceptors);
      default:
        const msg = "unexpected Content-Type";
        throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.BadRoute, msg);
    }
  }
  function handleCacheServiceFinalizeCacheEntryUploadRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
      case twirp_ts_1.TwirpContentType.JSON:
        return handleCacheServiceFinalizeCacheEntryUploadJSON(ctx, service, data, interceptors);
      case twirp_ts_1.TwirpContentType.Protobuf:
        return handleCacheServiceFinalizeCacheEntryUploadProtobuf(ctx, service, data, interceptors);
      default:
        const msg = "unexpected Content-Type";
        throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.BadRoute, msg);
    }
  }
  function handleCacheServiceGetCacheEntryDownloadURLRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
      case twirp_ts_1.TwirpContentType.JSON:
        return handleCacheServiceGetCacheEntryDownloadURLJSON(ctx, service, data, interceptors);
      case twirp_ts_1.TwirpContentType.Protobuf:
        return handleCacheServiceGetCacheEntryDownloadURLProtobuf(ctx, service, data, interceptors);
      default:
        const msg = "unexpected Content-Type";
        throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.BadRoute, msg);
    }
  }
  function handleCacheServiceDeleteCacheEntryRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
      case twirp_ts_1.TwirpContentType.JSON:
        return handleCacheServiceDeleteCacheEntryJSON(ctx, service, data, interceptors);
      case twirp_ts_1.TwirpContentType.Protobuf:
        return handleCacheServiceDeleteCacheEntryProtobuf(ctx, service, data, interceptors);
      default:
        const msg = "unexpected Content-Type";
        throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.BadRoute, msg);
    }
  }
  function handleCacheServiceListCacheEntriesRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
      case twirp_ts_1.TwirpContentType.JSON:
        return handleCacheServiceListCacheEntriesJSON(ctx, service, data, interceptors);
      case twirp_ts_1.TwirpContentType.Protobuf:
        return handleCacheServiceListCacheEntriesProtobuf(ctx, service, data, interceptors);
      default:
        const msg = "unexpected Content-Type";
        throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.BadRoute, msg);
    }
  }
  function handleCacheServiceLookupCacheEntryRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
      case twirp_ts_1.TwirpContentType.JSON:
        return handleCacheServiceLookupCacheEntryJSON(ctx, service, data, interceptors);
      case twirp_ts_1.TwirpContentType.Protobuf:
        return handleCacheServiceLookupCacheEntryProtobuf(ctx, service, data, interceptors);
      default:
        const msg = "unexpected Content-Type";
        throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.BadRoute, msg);
    }
  }
  function handleCacheServiceCreateCacheEntryJSON(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        const body = JSON.parse(data.toString() || "{}");
        request = cache_1.CreateCacheEntryRequest.fromJson(body, {
          ignoreUnknownFields: true
        });
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the json request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.CreateCacheEntry(ctx2, inputReq);
        });
      } else {
        response = yield service.CreateCacheEntry(ctx, request);
      }
      return JSON.stringify(cache_1.CreateCacheEntryResponse.toJson(response, {
        useProtoFieldName: true,
        emitDefaultValues: false
      }));
    });
  }
  function handleCacheServiceFinalizeCacheEntryUploadJSON(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        const body = JSON.parse(data.toString() || "{}");
        request = cache_1.FinalizeCacheEntryUploadRequest.fromJson(body, {
          ignoreUnknownFields: true
        });
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the json request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.FinalizeCacheEntryUpload(ctx2, inputReq);
        });
      } else {
        response = yield service.FinalizeCacheEntryUpload(ctx, request);
      }
      return JSON.stringify(cache_1.FinalizeCacheEntryUploadResponse.toJson(response, {
        useProtoFieldName: true,
        emitDefaultValues: false
      }));
    });
  }
  function handleCacheServiceGetCacheEntryDownloadURLJSON(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        const body = JSON.parse(data.toString() || "{}");
        request = cache_1.GetCacheEntryDownloadURLRequest.fromJson(body, {
          ignoreUnknownFields: true
        });
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the json request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.GetCacheEntryDownloadURL(ctx2, inputReq);
        });
      } else {
        response = yield service.GetCacheEntryDownloadURL(ctx, request);
      }
      return JSON.stringify(cache_1.GetCacheEntryDownloadURLResponse.toJson(response, {
        useProtoFieldName: true,
        emitDefaultValues: false
      }));
    });
  }
  function handleCacheServiceDeleteCacheEntryJSON(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        const body = JSON.parse(data.toString() || "{}");
        request = cache_1.DeleteCacheEntryRequest.fromJson(body, {
          ignoreUnknownFields: true
        });
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the json request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.DeleteCacheEntry(ctx2, inputReq);
        });
      } else {
        response = yield service.DeleteCacheEntry(ctx, request);
      }
      return JSON.stringify(cache_1.DeleteCacheEntryResponse.toJson(response, {
        useProtoFieldName: true,
        emitDefaultValues: false
      }));
    });
  }
  function handleCacheServiceListCacheEntriesJSON(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        const body = JSON.parse(data.toString() || "{}");
        request = cache_1.ListCacheEntriesRequest.fromJson(body, {
          ignoreUnknownFields: true
        });
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the json request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.ListCacheEntries(ctx2, inputReq);
        });
      } else {
        response = yield service.ListCacheEntries(ctx, request);
      }
      return JSON.stringify(cache_1.ListCacheEntriesResponse.toJson(response, {
        useProtoFieldName: true,
        emitDefaultValues: false
      }));
    });
  }
  function handleCacheServiceLookupCacheEntryJSON(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        const body = JSON.parse(data.toString() || "{}");
        request = cache_1.LookupCacheEntryRequest.fromJson(body, {
          ignoreUnknownFields: true
        });
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the json request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.LookupCacheEntry(ctx2, inputReq);
        });
      } else {
        response = yield service.LookupCacheEntry(ctx, request);
      }
      return JSON.stringify(cache_1.LookupCacheEntryResponse.toJson(response, {
        useProtoFieldName: true,
        emitDefaultValues: false
      }));
    });
  }
  function handleCacheServiceCreateCacheEntryProtobuf(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        request = cache_1.CreateCacheEntryRequest.fromBinary(data);
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the protobuf request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.CreateCacheEntry(ctx2, inputReq);
        });
      } else {
        response = yield service.CreateCacheEntry(ctx, request);
      }
      return Buffer.from(cache_1.CreateCacheEntryResponse.toBinary(response));
    });
  }
  function handleCacheServiceFinalizeCacheEntryUploadProtobuf(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        request = cache_1.FinalizeCacheEntryUploadRequest.fromBinary(data);
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the protobuf request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.FinalizeCacheEntryUpload(ctx2, inputReq);
        });
      } else {
        response = yield service.FinalizeCacheEntryUpload(ctx, request);
      }
      return Buffer.from(cache_1.FinalizeCacheEntryUploadResponse.toBinary(response));
    });
  }
  function handleCacheServiceGetCacheEntryDownloadURLProtobuf(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        request = cache_1.GetCacheEntryDownloadURLRequest.fromBinary(data);
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the protobuf request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.GetCacheEntryDownloadURL(ctx2, inputReq);
        });
      } else {
        response = yield service.GetCacheEntryDownloadURL(ctx, request);
      }
      return Buffer.from(cache_1.GetCacheEntryDownloadURLResponse.toBinary(response));
    });
  }
  function handleCacheServiceDeleteCacheEntryProtobuf(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        request = cache_1.DeleteCacheEntryRequest.fromBinary(data);
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the protobuf request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.DeleteCacheEntry(ctx2, inputReq);
        });
      } else {
        response = yield service.DeleteCacheEntry(ctx, request);
      }
      return Buffer.from(cache_1.DeleteCacheEntryResponse.toBinary(response));
    });
  }
  function handleCacheServiceListCacheEntriesProtobuf(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        request = cache_1.ListCacheEntriesRequest.fromBinary(data);
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the protobuf request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.ListCacheEntries(ctx2, inputReq);
        });
      } else {
        response = yield service.ListCacheEntries(ctx, request);
      }
      return Buffer.from(cache_1.ListCacheEntriesResponse.toBinary(response));
    });
  }
  function handleCacheServiceLookupCacheEntryProtobuf(ctx, service, data, interceptors) {
    return __awaiter(this, undefined, undefined, function* () {
      let request;
      let response;
      try {
        request = cache_1.LookupCacheEntryRequest.fromBinary(data);
      } catch (e) {
        if (e instanceof Error) {
          const msg = "the protobuf request could not be decoded";
          throw new twirp_ts_1.TwirpError(twirp_ts_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
      }
      if (interceptors && interceptors.length > 0) {
        const interceptor = (0, twirp_ts_1.chainInterceptors)(...interceptors);
        response = yield interceptor(ctx, request, (ctx2, inputReq) => {
          return service.LookupCacheEntry(ctx2, inputReq);
        });
      } else {
        response = yield service.LookupCacheEntry(ctx, request);
      }
      return Buffer.from(cache_1.LookupCacheEntryResponse.toBinary(response));
    });
  }
});

// node_modules/@actions/cache/lib/internal/shared/cacheTwirpClient.js
var require_cacheTwirpClient = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.internalCacheTwirpClient = undefined;
  var core_1 = require_core();
  var user_agent_1 = require_user_agent();
  var errors_1 = require_errors();
  var config_1 = require_config();
  var cacheUtils_1 = require_cacheUtils();
  var auth_1 = require_auth();
  var http_client_1 = require_lib();
  var cache_twirp_1 = require_cache_twirp();

  class CacheServiceClient {
    constructor(userAgent, maxAttempts, baseRetryIntervalMilliseconds, retryMultiplier) {
      this.maxAttempts = 5;
      this.baseRetryIntervalMilliseconds = 3000;
      this.retryMultiplier = 1.5;
      const token = (0, cacheUtils_1.getRuntimeToken)();
      this.baseUrl = (0, config_1.getCacheServiceURL)();
      if (maxAttempts) {
        this.maxAttempts = maxAttempts;
      }
      if (baseRetryIntervalMilliseconds) {
        this.baseRetryIntervalMilliseconds = baseRetryIntervalMilliseconds;
      }
      if (retryMultiplier) {
        this.retryMultiplier = retryMultiplier;
      }
      this.httpClient = new http_client_1.HttpClient(userAgent, [
        new auth_1.BearerCredentialHandler(token)
      ]);
    }
    request(service, method, contentType, data) {
      return __awaiter(this, undefined, undefined, function* () {
        const url = new URL(`/twirp/${service}/${method}`, this.baseUrl).href;
        (0, core_1.debug)(`[Request] ${method} ${url}`);
        const headers = {
          "Content-Type": contentType
        };
        try {
          const { body } = yield this.retryableRequest(() => __awaiter(this, undefined, undefined, function* () {
            return this.httpClient.post(url, JSON.stringify(data), headers);
          }));
          return body;
        } catch (error) {
          throw new Error(`Failed to ${method}: ${error.message}`);
        }
      });
    }
    retryableRequest(operation) {
      return __awaiter(this, undefined, undefined, function* () {
        let attempt = 0;
        let errorMessage = "";
        let rawBody = "";
        while (attempt < this.maxAttempts) {
          let isRetryable = false;
          try {
            const response = yield operation();
            const statusCode = response.message.statusCode;
            rawBody = yield response.readBody();
            (0, core_1.debug)(`[Response] - ${response.message.statusCode}`);
            (0, core_1.debug)(`Headers: ${JSON.stringify(response.message.headers, null, 2)}`);
            const body = JSON.parse(rawBody);
            (0, core_1.debug)(`Body: ${JSON.stringify(body, null, 2)}`);
            if (this.isSuccessStatusCode(statusCode)) {
              return { response, body };
            }
            isRetryable = this.isRetryableHttpStatusCode(statusCode);
            errorMessage = `Failed request: (${statusCode}) ${response.message.statusMessage}`;
            if (body.msg) {
              if (errors_1.UsageError.isUsageErrorMessage(body.msg)) {
                throw new errors_1.UsageError;
              }
              errorMessage = `${errorMessage}: ${body.msg}`;
            }
          } catch (error) {
            if (error instanceof SyntaxError) {
              (0, core_1.debug)(`Raw Body: ${rawBody}`);
            }
            if (error instanceof errors_1.UsageError) {
              throw error;
            }
            if (errors_1.NetworkError.isNetworkErrorCode(error === null || error === undefined ? undefined : error.code)) {
              throw new errors_1.NetworkError(error === null || error === undefined ? undefined : error.code);
            }
            isRetryable = true;
            errorMessage = error.message;
          }
          if (!isRetryable) {
            throw new Error(`Received non-retryable error: ${errorMessage}`);
          }
          if (attempt + 1 === this.maxAttempts) {
            throw new Error(`Failed to make request after ${this.maxAttempts} attempts: ${errorMessage}`);
          }
          const retryTimeMilliseconds = this.getExponentialRetryTimeMilliseconds(attempt);
          (0, core_1.info)(`Attempt ${attempt + 1} of ${this.maxAttempts} failed with error: ${errorMessage}. Retrying request in ${retryTimeMilliseconds} ms...`);
          yield this.sleep(retryTimeMilliseconds);
          attempt++;
        }
        throw new Error(`Request failed`);
      });
    }
    isSuccessStatusCode(statusCode) {
      if (!statusCode)
        return false;
      return statusCode >= 200 && statusCode < 300;
    }
    isRetryableHttpStatusCode(statusCode) {
      if (!statusCode)
        return false;
      const retryableStatusCodes = [
        http_client_1.HttpCodes.BadGateway,
        http_client_1.HttpCodes.GatewayTimeout,
        http_client_1.HttpCodes.InternalServerError,
        http_client_1.HttpCodes.ServiceUnavailable,
        http_client_1.HttpCodes.TooManyRequests
      ];
      return retryableStatusCodes.includes(statusCode);
    }
    sleep(milliseconds) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => setTimeout(resolve, milliseconds));
      });
    }
    getExponentialRetryTimeMilliseconds(attempt) {
      if (attempt < 0) {
        throw new Error("attempt should be a positive integer");
      }
      if (attempt === 0) {
        return this.baseRetryIntervalMilliseconds;
      }
      const minTime = this.baseRetryIntervalMilliseconds * Math.pow(this.retryMultiplier, attempt);
      const maxTime = minTime * this.retryMultiplier;
      return Math.trunc(Math.random() * (maxTime - minTime) + minTime);
    }
  }
  function internalCacheTwirpClient(options) {
    const client = new CacheServiceClient((0, user_agent_1.getUserAgentString)(), options === null || options === undefined ? undefined : options.maxAttempts, options === null || options === undefined ? undefined : options.retryIntervalMs, options === null || options === undefined ? undefined : options.retryMultiplier);
    return new cache_twirp_1.CacheServiceClientJSON(client);
  }
  exports.internalCacheTwirpClient = internalCacheTwirpClient;
});

// node_modules/@actions/cache/lib/internal/tar.js
var require_tar = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTar = exports.extractTar = exports.listTar = undefined;
  var exec_1 = require_exec();
  var io = __importStar(require_io());
  var fs_1 = __require("fs");
  var path = __importStar(__require("path"));
  var utils = __importStar(require_cacheUtils());
  var constants_1 = require_constants();
  var IS_WINDOWS = process.platform === "win32";
  function getTarPath() {
    return __awaiter(this, undefined, undefined, function* () {
      switch (process.platform) {
        case "win32": {
          const gnuTar = yield utils.getGnuTarPathOnWindows();
          const systemTar = constants_1.SystemTarPathOnWindows;
          if (gnuTar) {
            return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
          } else if ((0, fs_1.existsSync)(systemTar)) {
            return { path: systemTar, type: constants_1.ArchiveToolType.BSD };
          }
          break;
        }
        case "darwin": {
          const gnuTar = yield io.which("gtar", false);
          if (gnuTar) {
            return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
          } else {
            return {
              path: yield io.which("tar", true),
              type: constants_1.ArchiveToolType.BSD
            };
          }
        }
        default:
          break;
      }
      return {
        path: yield io.which("tar", true),
        type: constants_1.ArchiveToolType.GNU
      };
    });
  }
  function getTarArgs(tarPath, compressionMethod, type, archivePath = "") {
    return __awaiter(this, undefined, undefined, function* () {
      const args = [`"${tarPath.path}"`];
      const cacheFileName = utils.getCacheFileName(compressionMethod);
      const tarFile = "cache.tar";
      const workingDirectory = getWorkingDirectory();
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (type) {
        case "create":
          args.push("--posix", "-cf", BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path.sep}`, "g"), "/"), "--exclude", BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path.sep}`, "g"), "/"), "-P", "-C", workingDirectory.replace(new RegExp(`\\${path.sep}`, "g"), "/"), "--files-from", constants_1.ManifestFilename);
          break;
        case "extract":
          args.push("-xf", BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path.sep}`, "g"), "/"), "-P", "-C", workingDirectory.replace(new RegExp(`\\${path.sep}`, "g"), "/"));
          break;
        case "list":
          args.push("-tf", BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path.sep}`, "g"), "/"), "-P");
          break;
      }
      if (tarPath.type === constants_1.ArchiveToolType.GNU) {
        switch (process.platform) {
          case "win32":
            args.push("--force-local");
            break;
          case "darwin":
            args.push("--delay-directory-restore");
            break;
        }
      }
      return args;
    });
  }
  function getCommands(compressionMethod, type, archivePath = "") {
    return __awaiter(this, undefined, undefined, function* () {
      let args;
      const tarPath = yield getTarPath();
      const tarArgs = yield getTarArgs(tarPath, compressionMethod, type, archivePath);
      const compressionArgs = type !== "create" ? yield getDecompressionProgram(tarPath, compressionMethod, archivePath) : yield getCompressionProgram(tarPath, compressionMethod);
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      if (BSD_TAR_ZSTD && type !== "create") {
        args = [[...compressionArgs].join(" "), [...tarArgs].join(" ")];
      } else {
        args = [[...tarArgs].join(" "), [...compressionArgs].join(" ")];
      }
      if (BSD_TAR_ZSTD) {
        return args;
      }
      return [args.join(" ")];
    });
  }
  function getWorkingDirectory() {
    var _a;
    return (_a = process.env["GITHUB_WORKSPACE"]) !== null && _a !== undefined ? _a : process.cwd();
  }
  function getDecompressionProgram(tarPath, compressionMethod, archivePath) {
    return __awaiter(this, undefined, undefined, function* () {
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (compressionMethod) {
        case constants_1.CompressionMethod.Zstd:
          return BSD_TAR_ZSTD ? [
            "zstd -d --long=30 --force -o",
            constants_1.TarFilename,
            archivePath.replace(new RegExp(`\\${path.sep}`, "g"), "/")
          ] : [
            "--use-compress-program",
            IS_WINDOWS ? '"zstd -d --long=30"' : "unzstd --long=30"
          ];
        case constants_1.CompressionMethod.ZstdWithoutLong:
          return BSD_TAR_ZSTD ? [
            "zstd -d --force -o",
            constants_1.TarFilename,
            archivePath.replace(new RegExp(`\\${path.sep}`, "g"), "/")
          ] : ["--use-compress-program", IS_WINDOWS ? '"zstd -d"' : "unzstd"];
        default:
          return ["-z"];
      }
    });
  }
  function getCompressionProgram(tarPath, compressionMethod) {
    return __awaiter(this, undefined, undefined, function* () {
      const cacheFileName = utils.getCacheFileName(compressionMethod);
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (compressionMethod) {
        case constants_1.CompressionMethod.Zstd:
          return BSD_TAR_ZSTD ? [
            "zstd -T0 --long=30 --force -o",
            cacheFileName.replace(new RegExp(`\\${path.sep}`, "g"), "/"),
            constants_1.TarFilename
          ] : [
            "--use-compress-program",
            IS_WINDOWS ? '"zstd -T0 --long=30"' : "zstdmt --long=30"
          ];
        case constants_1.CompressionMethod.ZstdWithoutLong:
          return BSD_TAR_ZSTD ? [
            "zstd -T0 --force -o",
            cacheFileName.replace(new RegExp(`\\${path.sep}`, "g"), "/"),
            constants_1.TarFilename
          ] : ["--use-compress-program", IS_WINDOWS ? '"zstd -T0"' : "zstdmt"];
        default:
          return ["-z"];
      }
    });
  }
  function execCommands(commands, cwd) {
    return __awaiter(this, undefined, undefined, function* () {
      for (const command of commands) {
        try {
          yield (0, exec_1.exec)(command, undefined, {
            cwd,
            env: Object.assign(Object.assign({}, process.env), { MSYS: "winsymlinks:nativestrict" })
          });
        } catch (error) {
          throw new Error(`${command.split(" ")[0]} failed with error: ${error === null || error === undefined ? undefined : error.message}`);
        }
      }
    });
  }
  function listTar(archivePath, compressionMethod) {
    return __awaiter(this, undefined, undefined, function* () {
      const commands = yield getCommands(compressionMethod, "list", archivePath);
      yield execCommands(commands);
    });
  }
  exports.listTar = listTar;
  function extractTar(archivePath, compressionMethod) {
    return __awaiter(this, undefined, undefined, function* () {
      const workingDirectory = getWorkingDirectory();
      yield io.mkdirP(workingDirectory);
      const commands = yield getCommands(compressionMethod, "extract", archivePath);
      yield execCommands(commands);
    });
  }
  exports.extractTar = extractTar;
  function createTar(archiveFolder, sourceDirectories, compressionMethod) {
    return __awaiter(this, undefined, undefined, function* () {
      (0, fs_1.writeFileSync)(path.join(archiveFolder, constants_1.ManifestFilename), sourceDirectories.join(`
`));
      const commands = yield getCommands(compressionMethod, "create");
      yield execCommands(commands, archiveFolder);
    });
  }
  exports.createTar = createTar;
});

// node_modules/@actions/cache/lib/cache.js
var require_cache2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.saveCache = exports.restoreCache = exports.isFeatureAvailable = exports.ReserveCacheError = exports.ValidationError = undefined;
  var core = __importStar(require_core());
  var path = __importStar(__require("path"));
  var utils = __importStar(require_cacheUtils());
  var cacheHttpClient = __importStar(require_cacheHttpClient());
  var cacheTwirpClient = __importStar(require_cacheTwirpClient());
  var config_1 = require_config();
  var tar_1 = require_tar();
  var constants_1 = require_constants();

  class ValidationError extends Error {
    constructor(message) {
      super(message);
      this.name = "ValidationError";
      Object.setPrototypeOf(this, ValidationError.prototype);
    }
  }
  exports.ValidationError = ValidationError;

  class ReserveCacheError extends Error {
    constructor(message) {
      super(message);
      this.name = "ReserveCacheError";
      Object.setPrototypeOf(this, ReserveCacheError.prototype);
    }
  }
  exports.ReserveCacheError = ReserveCacheError;
  function checkPaths(paths) {
    if (!paths || paths.length === 0) {
      throw new ValidationError(`Path Validation Error: At least one directory or file path is required`);
    }
  }
  function checkKey(key) {
    if (key.length > 512) {
      throw new ValidationError(`Key Validation Error: ${key} cannot be larger than 512 characters.`);
    }
    const regex = /^[^,]*$/;
    if (!regex.test(key)) {
      throw new ValidationError(`Key Validation Error: ${key} cannot contain commas.`);
    }
  }
  function isFeatureAvailable() {
    return !!process.env["ACTIONS_CACHE_URL"];
  }
  exports.isFeatureAvailable = isFeatureAvailable;
  function restoreCache(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
    return __awaiter(this, undefined, undefined, function* () {
      const cacheServiceVersion = (0, config_1.getCacheServiceVersion)();
      core.debug(`Cache service version: ${cacheServiceVersion}`);
      checkPaths(paths);
      switch (cacheServiceVersion) {
        case "v2":
          return yield restoreCacheV2(paths, primaryKey, restoreKeys, options, enableCrossOsArchive);
        case "v1":
        default:
          return yield restoreCacheV1(paths, primaryKey, restoreKeys, options, enableCrossOsArchive);
      }
    });
  }
  exports.restoreCache = restoreCache;
  function restoreCacheV1(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
    return __awaiter(this, undefined, undefined, function* () {
      restoreKeys = restoreKeys || [];
      const keys = [primaryKey, ...restoreKeys];
      core.debug("Resolved Keys:");
      core.debug(JSON.stringify(keys));
      if (keys.length > 10) {
        throw new ValidationError(`Key Validation Error: Keys are limited to a maximum of 10.`);
      }
      for (const key of keys) {
        checkKey(key);
      }
      const compressionMethod = yield utils.getCompressionMethod();
      let archivePath = "";
      try {
        const cacheEntry = yield cacheHttpClient.getCacheEntry(keys, paths, {
          compressionMethod,
          enableCrossOsArchive
        });
        if (!(cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.archiveLocation)) {
          return;
        }
        if (options === null || options === undefined ? undefined : options.lookupOnly) {
          core.info("Lookup only - skipping download");
          return cacheEntry.cacheKey;
        }
        archivePath = path.join(yield utils.createTempDirectory(), utils.getCacheFileName(compressionMethod));
        core.debug(`Archive Path: ${archivePath}`);
        yield cacheHttpClient.downloadCache(cacheEntry.archiveLocation, archivePath, options);
        if (core.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
        yield (0, tar_1.extractTar)(archivePath, compressionMethod);
        core.info("Cache restored successfully");
        return cacheEntry.cacheKey;
      } catch (error) {
        const typedError = error;
        if (typedError.name === ValidationError.name) {
          throw error;
        } else {
          core.warning(`Failed to restore: ${error.message}`);
        }
      } finally {
        try {
          yield utils.unlinkFile(archivePath);
        } catch (error) {
          core.debug(`Failed to delete archive: ${error}`);
        }
      }
      return;
    });
  }
  function restoreCacheV2(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
    return __awaiter(this, undefined, undefined, function* () {
      options = Object.assign(Object.assign({}, options), { useAzureSdk: true });
      restoreKeys = restoreKeys || [];
      const keys = [primaryKey, ...restoreKeys];
      core.debug("Resolved Keys:");
      core.debug(JSON.stringify(keys));
      if (keys.length > 10) {
        throw new ValidationError(`Key Validation Error: Keys are limited to a maximum of 10.`);
      }
      for (const key of keys) {
        checkKey(key);
      }
      let archivePath = "";
      try {
        const twirpClient = cacheTwirpClient.internalCacheTwirpClient();
        const compressionMethod = yield utils.getCompressionMethod();
        const request = {
          key: primaryKey,
          restoreKeys,
          version: utils.getCacheVersion(paths, compressionMethod, enableCrossOsArchive)
        };
        const response = yield twirpClient.GetCacheEntryDownloadURL(request);
        if (!response.ok) {
          core.warning(`Cache not found for keys: ${keys.join(", ")}`);
          return;
        }
        core.info(`Cache hit for: ${request.key}`);
        if (options === null || options === undefined ? undefined : options.lookupOnly) {
          core.info("Lookup only - skipping download");
          return response.matchedKey;
        }
        archivePath = path.join(yield utils.createTempDirectory(), utils.getCacheFileName(compressionMethod));
        core.debug(`Archive path: ${archivePath}`);
        core.debug(`Starting download of archive to: ${archivePath}`);
        yield cacheHttpClient.downloadCache(response.signedDownloadUrl, archivePath, options);
        const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
        if (core.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        yield (0, tar_1.extractTar)(archivePath, compressionMethod);
        core.info("Cache restored successfully");
        return response.matchedKey;
      } catch (error) {
        const typedError = error;
        if (typedError.name === ValidationError.name) {
          throw error;
        } else {
          core.warning(`Failed to restore: ${error.message}`);
        }
      } finally {
        try {
          if (archivePath) {
            yield utils.unlinkFile(archivePath);
          }
        } catch (error) {
          core.debug(`Failed to delete archive: ${error}`);
        }
      }
      return;
    });
  }
  function saveCache(paths, key, options, enableCrossOsArchive = false) {
    return __awaiter(this, undefined, undefined, function* () {
      const cacheServiceVersion = (0, config_1.getCacheServiceVersion)();
      core.debug(`Cache service version: ${cacheServiceVersion}`);
      checkPaths(paths);
      checkKey(key);
      switch (cacheServiceVersion) {
        case "v2":
          return yield saveCacheV2(paths, key, options, enableCrossOsArchive);
        case "v1":
        default:
          return yield saveCacheV1(paths, key, options, enableCrossOsArchive);
      }
    });
  }
  exports.saveCache = saveCache;
  function saveCacheV1(paths, key, options, enableCrossOsArchive = false) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, undefined, undefined, function* () {
      const compressionMethod = yield utils.getCompressionMethod();
      let cacheId = -1;
      const cachePaths = yield utils.resolvePaths(paths);
      core.debug("Cache Paths:");
      core.debug(`${JSON.stringify(cachePaths)}`);
      if (cachePaths.length === 0) {
        throw new Error(`Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.`);
      }
      const archiveFolder = yield utils.createTempDirectory();
      const archivePath = path.join(archiveFolder, utils.getCacheFileName(compressionMethod));
      core.debug(`Archive Path: ${archivePath}`);
      try {
        yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
        if (core.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const fileSizeLimit = 10 * 1024 * 1024 * 1024;
        const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.debug(`File Size: ${archiveFileSize}`);
        if (archiveFileSize > fileSizeLimit && !(0, config_1.isGhes)()) {
          throw new Error(`Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the 10GB limit, not saving cache.`);
        }
        core.debug("Reserving Cache");
        const reserveCacheResponse = yield cacheHttpClient.reserveCache(key, paths, {
          compressionMethod,
          enableCrossOsArchive,
          cacheSize: archiveFileSize
        });
        if ((_a = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.result) === null || _a === undefined ? undefined : _a.cacheId) {
          cacheId = (_b = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.result) === null || _b === undefined ? undefined : _b.cacheId;
        } else if ((reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.statusCode) === 400) {
          throw new Error((_d = (_c = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.error) === null || _c === undefined ? undefined : _c.message) !== null && _d !== undefined ? _d : `Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the data cap limit, not saving cache.`);
        } else {
          throw new ReserveCacheError(`Unable to reserve cache with key ${key}, another job may be creating this cache. More details: ${(_e = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.error) === null || _e === undefined ? undefined : _e.message}`);
        }
        core.debug(`Saving Cache (ID: ${cacheId})`);
        yield cacheHttpClient.saveCache(cacheId, archivePath, "", options);
      } catch (error) {
        const typedError = error;
        if (typedError.name === ValidationError.name) {
          throw error;
        } else if (typedError.name === ReserveCacheError.name) {
          core.info(`Failed to save: ${typedError.message}`);
        } else {
          core.warning(`Failed to save: ${typedError.message}`);
        }
      } finally {
        try {
          yield utils.unlinkFile(archivePath);
        } catch (error) {
          core.debug(`Failed to delete archive: ${error}`);
        }
      }
      return cacheId;
    });
  }
  function saveCacheV2(paths, key, options, enableCrossOsArchive = false) {
    return __awaiter(this, undefined, undefined, function* () {
      options = Object.assign(Object.assign({}, options), { uploadChunkSize: 64 * 1024 * 1024, uploadConcurrency: 8, useAzureSdk: true });
      const compressionMethod = yield utils.getCompressionMethod();
      const twirpClient = cacheTwirpClient.internalCacheTwirpClient();
      let cacheId = -1;
      const cachePaths = yield utils.resolvePaths(paths);
      core.debug("Cache Paths:");
      core.debug(`${JSON.stringify(cachePaths)}`);
      if (cachePaths.length === 0) {
        throw new Error(`Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.`);
      }
      const archiveFolder = yield utils.createTempDirectory();
      const archivePath = path.join(archiveFolder, utils.getCacheFileName(compressionMethod));
      core.debug(`Archive Path: ${archivePath}`);
      try {
        yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
        if (core.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.debug(`File Size: ${archiveFileSize}`);
        if (archiveFileSize > constants_1.CacheFileSizeLimit && !(0, config_1.isGhes)()) {
          throw new Error(`Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the 10GB limit, not saving cache.`);
        }
        options.archiveSizeBytes = archiveFileSize;
        core.debug("Reserving Cache");
        const version = utils.getCacheVersion(paths, compressionMethod, enableCrossOsArchive);
        const request = {
          key,
          version
        };
        const response = yield twirpClient.CreateCacheEntry(request);
        if (!response.ok) {
          throw new ReserveCacheError(`Unable to reserve cache with key ${key}, another job may be creating this cache.`);
        }
        core.debug(`Attempting to upload cache located at: ${archivePath}`);
        yield cacheHttpClient.saveCache(cacheId, archivePath, response.signedUploadUrl, options);
        const finalizeRequest = {
          key,
          version,
          sizeBytes: `${archiveFileSize}`
        };
        const finalizeResponse = yield twirpClient.FinalizeCacheEntryUpload(finalizeRequest);
        core.debug(`FinalizeCacheEntryUploadResponse: ${finalizeResponse.ok}`);
        if (!finalizeResponse.ok) {
          throw new Error(`Unable to finalize cache with key ${key}, another job may be finalizing this cache.`);
        }
        cacheId = parseInt(finalizeResponse.entryId);
      } catch (error) {
        const typedError = error;
        if (typedError.name === ValidationError.name) {
          throw error;
        } else if (typedError.name === ReserveCacheError.name) {
          core.info(`Failed to save: ${typedError.message}`);
        } else {
          core.warning(`Failed to save: ${typedError.message}`);
        }
      } finally {
        try {
          yield utils.unlinkFile(archivePath);
        } catch (error) {
          core.debug(`Failed to delete archive: ${error}`);
        }
      }
      return cacheId;
    });
  }
});

export { require_cache2 as require_cache };
